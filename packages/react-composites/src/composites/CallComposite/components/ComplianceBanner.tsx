// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useRef, useState } from 'react';
import { Link, mergeStyles, MessageBar, MessageBarType, useTheme } from '@fluentui/react';
import { CompositeStrings, useLocale } from '../../localization';
import { ComplianceBannerVariant, ComplianceState, computeVariant } from '../utils';
import { complianceBannerWarningStyles } from '../styles/CallComposite.styles';

/**
 * @private
 */
export type ComplianceBannerProps = {
  callTranscribeState?: boolean;
  callRecordState?: boolean;
};

// latestBooleanState so we can compare with props.callRecordState and props.callTranscribeState easily
// latestStringState is on, off, stopped state generated by function determineStates using previous and current state values, this is used for computeVariants later
type CachedComplianceBannerProps = {
  latestBooleanState: ComplianceBannerProps;
  latestStringState: {
    callTranscribeState: ComplianceState;
    callRecordState: ComplianceState;
  };
};

/**
 * @private
 */
export const ComplianceBanner = (props: ComplianceBannerProps): JSX.Element => {
  function determineStates(previous: ComplianceState, current: boolean | undefined): ComplianceState {
    // if current state is on, then return on
    if (current) {
      return 'on';
    }
    // if current state is off
    else {
      // if previous state is on and current state is off, return stopped (on -> off)
      if (previous === 'on') {
        return 'stopped';
      }
      // otherwise remain previous state unchanged
      else {
        return previous;
      }
    }
  }

  //set variant when incoming state is different from current state
  //when variant change, return message bar
  //when message bar is dismissed,set variant to default nostate and if current state is stopped, set to off

  const strings = useLocale().strings;
  const theme = useTheme();
  const [variant, setVariant] = useState<ComplianceBannerVariant>('NO_STATE');
  const cachedProps = useRef<CachedComplianceBannerProps>({
    latestBooleanState: {
      callTranscribeState: false,
      callRecordState: false
    },
    latestStringState: {
      callTranscribeState: 'off',
      callRecordState: 'off'
    }
  });

  // Only update cached props and variant if there is _some_ change in the latest props.
  // This ensures that state machine is only updated if there is an actual change in the props.
  if (
    props.callRecordState !== cachedProps.current.latestBooleanState.callRecordState ||
    props.callTranscribeState !== cachedProps.current.latestBooleanState.callTranscribeState
  ) {
    cachedProps.current = {
      latestBooleanState: props,
      latestStringState: {
        callRecordState: determineStates(cachedProps.current.latestStringState.callRecordState, props.callRecordState),
        callTranscribeState: determineStates(
          cachedProps.current.latestStringState.callTranscribeState,
          props.callTranscribeState
        )
      }
    };
    setVariant(
      computeVariant(
        cachedProps.current.latestStringState.callRecordState,
        cachedProps.current.latestStringState.callTranscribeState
      )
    );
    // when both states are stopped, after displaying message "RECORDING_AND_TRANSCRIPTION_STOPPED", change both states to off (going back to the default state)
    if (
      cachedProps.current.latestStringState.callRecordState === 'stopped' &&
      cachedProps.current.latestStringState.callTranscribeState === 'stopped'
    ) {
      cachedProps.current.latestStringState.callRecordState = 'off';
      cachedProps.current.latestStringState.callTranscribeState = 'off';
    }
  }

  return variant === 'NO_STATE' ? (
    <></>
  ) : (
    <MessageBar
      // className={mergeStyles(complianceBannerWarningStyles(theme))}
      messageBarType={MessageBarType.warning}
      onDismiss={() => {
        // when closing the banner, change variant to nostate and change stopped state to off state.
        // Reason: on banner close, going back to the default state
        setVariant('NO_STATE');
        if (cachedProps.current.latestStringState.callRecordState === 'stopped') {
          cachedProps.current.latestStringState.callRecordState = 'off';
        }
        if (cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
          cachedProps.current.latestStringState.callTranscribeState = 'off';
        }
      }}
      dismissButtonAriaLabel={strings.call.close}
    >
      <BannerMessage variant={variant} strings={strings} />
    </MessageBar>
  );
};

function BannerMessage(props: { variant: ComplianceBannerVariant; strings: CompositeStrings }): JSX.Element {
  const { variant, strings } = props;
  switch (variant) {
    case 'TRANSCRIPTION_STOPPED_STILL_RECORDING':
      return (
        <>
          <b>{strings.call.complianceBannerTranscriptionStopped}</b>
          {` ${strings.call.complianceBannerNowOnlyRecording}`}
          <PrivacyPolicy linkText={strings.call.privacyPolicy} />
        </>
      );
    case 'RECORDING_STOPPED_STILL_TRANSCRIBING':
      return (
        <>
          <b>{strings.call.complianceBannerRecordingStopped}</b>
          {` ${strings.call.complianceBannerNowOnlyTranscription}`}
          <PrivacyPolicy linkText={strings.call.privacyPolicy} />
        </>
      );
    case 'RECORDING_AND_TRANSCRIPTION_STOPPED':
      return (
        <>
          <b>{strings.call.complianceBannerRecordingAndTranscriptionSaved}</b>
          {` ${strings.call.complianceBannerRecordingAndTranscriptionStopped}`}
          <LearnMore linkText={strings.call.learnMore} />
        </>
      );
    case 'RECORDING_AND_TRANSCRIPTION_STARTED':
      return (
        <>
          <b>{strings.call.complianceBannerRecordingAndTranscriptionStarted}</b>
          {` ${strings.call.complianceBannerTranscriptionConsent}`}
          <PrivacyPolicy linkText={strings.call.privacyPolicy} />
        </>
      );
    case 'TRANSCRIPTION_STARTED':
      return (
        <>
          <b>{strings.call.complianceBannerTranscriptionStarted}</b>
          {` ${strings.call.complianceBannerTranscriptionConsent}`}
          <PrivacyPolicy linkText={strings.call.privacyPolicy} />
        </>
      );
    case 'RECORDING_STOPPED':
      return (
        <>
          <b>{strings.call.complianceBannerRecordingSaving}</b>
          {` ${strings.call.complianceBannerRecordingStopped}`}
          <LearnMore linkText={strings.call.learnMore} />
        </>
      );
    case 'RECORDING_STARTED':
      return (
        <>
          <b>{strings.call.complianceBannerRecordingStarted}</b>
          {` ${strings.call.complianceBannerTranscriptionConsent}`}
          <PrivacyPolicy linkText={strings.call.privacyPolicy} />
        </>
      );
    case 'TRANSCRIPTION_STOPPED':
      return (
        <>
          <b>{strings.call.complianceBannerTranscriptionSaving}</b>
          {` ${strings.call.complianceBannerTranscriptionStopped}`}
          <LearnMore linkText={strings.call.learnMore} />
        </>
      );
  }
  return <></>;
}

function PrivacyPolicy(props: { linkText: string }): JSX.Element {
  return (
    <Link href="https://privacy.microsoft.com/privacystatement#mainnoticetoendusersmodule" target="_blank" underline>
      {props.linkText}
    </Link>
  );
}

function LearnMore(props: { linkText: string }): JSX.Element {
  return (
    <Link
      href="https://support.microsoft.com/office/record-a-meeting-in-teams-34dfbe7f-b07d-4a27-b4c6-de62f1348c24"
      target="_blank"
      underline
    >
      {props.linkText}
    </Link>
  );
}
