## API Report File for "@azure/communication-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import { AudioDeviceInfo } from '@azure/communication-calling';
import { Call } from '@azure/communication-calling';
import { CallAgent } from '@azure/communication-calling';
import { CallClient } from '@azure/communication-calling';
import { CallClientOptions } from '@azure/communication-calling';
import { CallDirection } from '@azure/communication-calling';
import { CallEndReason } from '@azure/communication-calling';
import { CallerInfo } from '@azure/communication-calling';
import { CallState as CallState_2 } from '@azure/communication-calling';
import { ChatClient } from '@azure/communication-chat';
import { ChatClientOptions } from '@azure/communication-chat';
import { ChatMessage as ChatMessage_2 } from '@azure/communication-chat';
import { ChatMessageReadReceipt } from '@azure/communication-chat';
import { ChatParticipant } from '@azure/communication-chat';
import { ChatThreadClient } from '@azure/communication-chat';
import { CommunicationIdentifier } from '@azure/communication-common';
import { CommunicationIdentifierKind } from '@azure/communication-common';
import { CommunicationTokenCredential } from '@azure/communication-common';
import { CommunicationUserIdentifier } from '@azure/communication-common';
import { CommunicationUserKind } from '@azure/communication-common';
import { ComponentSlotStyle } from '@fluentui/react-northstar';
import { CreateViewOptions } from '@azure/communication-calling';
import { DeviceAccess } from '@azure/communication-calling';
import { DeviceManager } from '@azure/communication-calling';
import { DominantSpeakersInfo } from '@azure/communication-calling';
import { GroupCallLocator } from '@azure/communication-calling';
import { IButtonProps } from '@fluentui/react';
import { IButtonStyles } from '@fluentui/react';
import { IContextualMenuItem } from '@fluentui/react';
import { IContextualMenuItemStyles } from '@fluentui/react';
import { IContextualMenuStyles } from '@fluentui/react';
import { IMessageBarProps } from '@fluentui/react';
import { IPersonaStyleProps } from '@fluentui/react';
import { IPersonaStyles } from '@fluentui/react';
import { IRenderFunction } from '@fluentui/react';
import { IStyle } from '@fluentui/react';
import { IStyleFunctionOrObject } from '@fluentui/react';
import { LatestMediaDiagnostics } from '@azure/communication-calling';
import { LatestNetworkDiagnostics } from '@azure/communication-calling';
import type { MediaDiagnosticChangedEventArgs } from '@azure/communication-calling';
import { MediaStreamType } from '@azure/communication-calling';
import { MicrosoftTeamsUserKind } from '@azure/communication-common';
import type { NetworkDiagnosticChangedEventArgs } from '@azure/communication-calling';
import { PartialTheme } from '@fluentui/react';
import type { PermissionConstraints } from '@azure/communication-calling';
import { PersonaInitialsColor } from '@fluentui/react';
import { PersonaPresence } from '@fluentui/react';
import { PersonaSize } from '@fluentui/react';
import { PhoneNumberIdentifier } from '@azure/communication-common';
import { PhoneNumberKind } from '@azure/communication-common';
import { default as React_2 } from 'react';
import type { RemoteParticipant } from '@azure/communication-calling';
import { RemoteParticipantState as RemoteParticipantState_2 } from '@azure/communication-calling';
import { ScalingMode } from '@azure/communication-calling';
import { SendMessageOptions } from '@azure/communication-chat';
import { StartCallOptions } from '@azure/communication-calling';
import { TeamsMeetingLinkLocator } from '@azure/communication-calling';
import { Theme } from '@fluentui/react';
import { TypingIndicatorReceivedEvent } from '@azure/communication-signaling';
import { UnknownIdentifier } from '@azure/communication-common';
import { UnknownIdentifierKind } from '@azure/communication-common';
import { VideoDeviceInfo } from '@azure/communication-calling';

// @public
export interface ActiveErrorMessage {
    timestamp?: Date;
    type: ErrorType;
}

// @public
export interface AdapterError extends Error {
    innerError: Error;
    target: string;
    timestamp: Date;
}

// @public
export type AdapterErrors = {
    [target: string]: AdapterError;
};

// @public
export interface AdapterState<TState> {
    getState(): TState;
    offStateChange(handler: (state: TState) => void): void;
    onStateChange(handler: (state: TState) => void): void;
}

// @public
export type AreEqual<A extends (props: any) => JSX.Element | undefined, B extends (props: any) => JSX.Element | undefined> = true extends AreTypeEqual<A, B> & AreParamEqual<A, B> ? true : false;

// @public
export type AreParamEqual<A extends (props: any) => JSX.Element | undefined, B extends (props: any) => JSX.Element | undefined> = AreTypeEqual<Required<Parameters<A>[0]>, Required<Parameters<B>[0]>>;

// @public
export type AreTypeEqual<A, B> = A extends B ? (B extends A ? true : false) : false;

// @public
export type AvatarPersonaData = {
    text?: string;
    imageUrl?: string;
    imageInitials?: string;
    initialsColor?: PersonaInitialsColor | string;
    initialsTextColor?: string;
};

// @public
export type AvatarPersonaDataCallback = (userId: string) => Promise<AvatarPersonaData>;

// @public
export type AzureCommunicationCallAdapterArgs = {
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    locator: TeamsMeetingLinkLocator | GroupCallLocator;
};

// @public
export type AzureCommunicationChatAdapterArgs = {
    endpoint: string;
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    threadId: string;
};

// @beta
export type AzureCommunicationMeetingAdapterArgs = {
    endpoint: string;
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    meetingLocator: CallAndChatLocator | TeamsMeetingLinkLocator;
};

// @public
export interface BaseCompositeProps<TIcons extends Record<string, JSX.Element>> {
    fluentTheme?: PartialTheme | Theme;
    icons?: TIcons;
    locale?: CompositeLocale;
    onFetchAvatarPersonaData?: AvatarPersonaDataCallback;
    onFetchParticipantMenuItems?: ParticipantMenuItemsCallback;
    rtl?: boolean;
}

// @public
export interface BaseCustomStyles {
    root?: IStyle;
}

// @public
export interface CallAdapter extends AdapterState<CallAdapterState>, Disposable, CallAdapterCallManagement, CallAdapterDeviceManagement, CallAdapterSubscribers {
}

// @public
export interface CallAdapterCallManagement {
    createStreamView(remoteUserId?: string, options?: VideoStreamOptions): Promise<void>;
    disposeStreamView(remoteUserId?: string, options?: VideoStreamOptions): Promise<void>;
    joinCall(microphoneOn?: boolean): Call | undefined;
    leaveCall(forEveryone?: boolean): Promise<void>;
    mute(): Promise<void>;
    removeParticipant(userId: string): Promise<void>;
    startCall(participants: string[]): Call | undefined;
    startCamera(options?: VideoStreamOptions): Promise<void>;
    startScreenShare(): Promise<void>;
    stopCamera(): Promise<void>;
    stopScreenShare(): Promise<void>;
    unmute(): Promise<void>;
}

// @public
export type CallAdapterClientState = {
    userId: CommunicationIdentifierKind;
    displayName?: string;
    call?: CallState;
    devices: DeviceManagerState;
    endedCall?: CallState;
    isTeamsCall: boolean;
    latestErrors: AdapterErrors;
};

// @public
export interface CallAdapterDeviceManagement {
    askDevicePermission(constrain: PermissionConstraints): Promise<void>;
    queryCameras(): Promise<VideoDeviceInfo[]>;
    queryMicrophones(): Promise<AudioDeviceInfo[]>;
    querySpeakers(): Promise<AudioDeviceInfo[]>;
    setCamera(sourceInfo: VideoDeviceInfo, options?: VideoStreamOptions): Promise<void>;
    setMicrophone(sourceInfo: AudioDeviceInfo): Promise<void>;
    setSpeaker(sourceInfo: AudioDeviceInfo): Promise<void>;
}

// @public
export type CallAdapterState = CallAdapterUiState & CallAdapterClientState;

// @public
export interface CallAdapterSubscribers {
    off(event: 'participantsJoined', listener: ParticipantsJoinedListener): void;
    off(event: 'participantsLeft', listener: ParticipantsLeftListener): void;
    off(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    off(event: 'callIdChanged', listener: CallIdChangedListener): void;
    off(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    off(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    off(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    off(event: 'callEnded', listener: CallEndedListener): void;
    off(event: 'diagnosticChanged', listener: DiagnosticChangedEventListner): void;
    off(event: 'error', listener: (e: AdapterError) => void): void;
    on(event: 'participantsJoined', listener: ParticipantsJoinedListener): void;
    on(event: 'participantsLeft', listener: ParticipantsLeftListener): void;
    on(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    on(event: 'callIdChanged', listener: CallIdChangedListener): void;
    on(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    on(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    on(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    on(event: 'callEnded', listener: CallEndedListener): void;
    on(event: 'diagnosticChanged', listener: DiagnosticChangedEventListner): void;
    on(event: 'error', listener: (e: AdapterError) => void): void;
}

// @public
export type CallAdapterUiState = {
    isLocalPreviewMicrophoneEnabled: boolean;
    page: CallCompositePage;
};

// @public
export const CallAgentProvider: (props: CallAgentProviderProps) => JSX.Element;

// @public
export interface CallAgentProviderProps {
    // (undocumented)
    callAgent?: CallAgent;
    // (undocumented)
    children: React_2.ReactNode;
}

// @public
export interface CallAgentState {
    displayName?: string;
}

// @beta
export interface CallAndChatLocator {
    callLocator: GroupCallLocator;
    chatThreadId: string;
}

// @public
export const CallClientProvider: (props: CallClientProviderProps) => JSX.Element;

// @public
export interface CallClientProviderProps {
    // (undocumented)
    callClient: StatefulCallClient;
    // (undocumented)
    children: React_2.ReactNode;
}

// @public
export interface CallClientState {
    callAgent?: CallAgentState;
    calls: {
        [key: string]: CallState;
    };
    callsEnded: {
        [key: string]: CallState;
    };
    deviceManager: DeviceManagerState;
    incomingCalls: {
        [key: string]: IncomingCallState;
    };
    incomingCallsEnded: {
        [key: string]: IncomingCallState;
    };
    latestErrors: CallErrors;
    userId: CommunicationIdentifierKind;
}

// @public
export const CallComposite: (props: CallCompositeProps) => JSX.Element;

// @public
export type CallCompositeIcons = Partial<Pick<CompositeIcons, 'ControlButtonCameraOff' | 'ControlButtonCameraOn' | 'ControlButtonEndCall' | 'ControlButtonMicOff' | 'ControlButtonMicOn' | 'ControlButtonOptions' | 'ControlButtonParticipants' | 'ControlButtonScreenShareStart' | 'ControlButtonScreenShareStop' | 'ErrorBarCallCameraAccessDenied' | 'ErrorBarCallCameraAlreadyInUse' | 'ErrorBarCallLocalVideoFreeze' | 'ErrorBarCallMacOsCameraAccessDenied' | 'ErrorBarCallMacOsMicrophoneAccessDenied' | 'ErrorBarCallMicrophoneAccessDenied' | 'ErrorBarCallMicrophoneMutedBySystem' | 'ErrorBarCallNetworkQualityLow' | 'ErrorBarCallNoMicrophoneFound' | 'ErrorBarCallNoSpeakerFound' | 'HorizontalGalleryLeftButton' | 'HorizontalGalleryRightButton' | 'LobbyScreenConnectingToCall' | 'LobbyScreenWaitingToBeAdmitted' | 'LocalDeviceSettingsCamera' | 'LocalDeviceSettingsMic' | 'LocalDeviceSettingsSpeaker' | 'LocalPreviewPlaceholder' | 'Muted' | 'NetworkReconnectIcon' | 'NoticePageAccessDeniedTeamsMeeting' | 'NoticePageJoinCallFailedDueToNoNetwork' | 'NoticePageLeftCall' | 'NoticePageRemovedFromCall' | 'OptionsCamera' | 'OptionsMic' | 'OptionsSpeaker' | 'ParticipantItemMicOff' | 'ParticipantItemOptions' | 'ParticipantItemOptionsHovered' | 'ParticipantItemScreenShareStart' | 'VideoTileMicOff' | /* @conditional-compile-remove-from(stable) */ 'LocalCameraSwitch' | /* @conditional-compile-remove-from(stable) Chat_Notification_Icon */ 'ControlBarButtonBadgeIcon'>>;

// @public
export type CallCompositeOptions = {
    errorBar?: boolean;
    callControls?: boolean | CallControlOptions;
};

// @public
export type CallCompositePage = 'accessDeniedTeamsMeeting' | 'call' | 'configuration' | 'joinCallFailedDueToNoNetwork' | 'leftCall' | 'lobby' | 'removedFromCall';

// @public
export interface CallCompositeProps extends BaseCompositeProps<CallCompositeIcons> {
    adapter: CallAdapter;
    callInvitationUrl?: string;
    formFactor?: 'desktop' | 'mobile';
    options?: CallCompositeOptions;
}

// @public
export interface CallCompositeStrings {
    cameraLabel: string;
    cameraPermissionDenied: string;
    cameraTurnedOff: string;
    close: string;
    complianceBannerNowOnlyRecording: string;
    complianceBannerNowOnlyTranscription: string;
    complianceBannerRecordingAndTranscriptionSaved: string;
    complianceBannerRecordingAndTranscriptionStarted: string;
    complianceBannerRecordingAndTranscriptionStopped: string;
    complianceBannerRecordingSaving: string;
    complianceBannerRecordingStarted: string;
    complianceBannerRecordingStopped: string;
    complianceBannerTranscriptionConsent: string;
    complianceBannerTranscriptionSaving: string;
    complianceBannerTranscriptionStarted: string;
    complianceBannerTranscriptionStopped: string;
    configurationPageCallDetails?: string;
    configurationPageTitle: string;
    defaultPlaceHolder: string;
    failedToJoinCallDueToNoNetworkMoreDetails?: string;
    failedToJoinCallDueToNoNetworkTitle: string;
    failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails?: string;
    failedToJoinTeamsMeetingReasonAccessDeniedTitle: string;
    learnMore: string;
    leftCallMoreDetails?: string;
    leftCallTitle: string;
    lobbyScreenConnectingToCallMoreDetails?: string;
    lobbyScreenConnectingToCallTitle: string;
    lobbyScreenWaitingToBeAdmittedMoreDetails?: string;
    lobbyScreenWaitingToBeAdmittedTitle: string;
    microphonePermissionDenied: string;
    microphoneToggleInLobbyNotAllowed: string;
    mutedMessage: string;
    networkReconnectMoreDetails: string;
    networkReconnectTitle: string;
    privacyPolicy: string;
    rejoinCallButtonLabel: string;
    removedFromCallMoreDetails?: string;
    removedFromCallTitle: string;
    soundLabel: string;
    startCallButtonLabel: string;
}

// @public
export type CallControlDisplayType = 'default' | 'compact';

// @public
export type CallControlOptions = {
    displayType?: CallControlDisplayType;
    cameraButton?: boolean;
    endCallButton?: boolean;
    microphoneButton?: boolean;
    devicesButton?: boolean;
    participantsButton?: boolean | {
        disabled: boolean;
    };
    screenShareButton?: boolean | {
        disabled: boolean;
    };
    onFetchCustomButtonProps?: CustomCallControlButtonCallback[];
};

// @public
export type CallEndedListener = (event: {
    callId: string;
}) => void;

// @public
export class CallError extends Error {
    constructor(target: CallErrorTarget, innerError: Error, timestamp?: Date);
    innerError: Error;
    target: CallErrorTarget;
    timestamp: Date;
}

// @public
export type CallErrorBarSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    activeErrorMessages: ActiveErrorMessage[];
};

// @public
export type CallErrors = {
    [target in CallErrorTarget]: CallError;
};

// @public
export type CallErrorTarget = 'Call.addParticipant' | 'Call.feature' | 'Call.hangUp' | 'Call.hold' | 'Call.mute' | 'Call.off' | 'Call.on' | 'Call.removeParticipant' | 'Call.resume' | 'Call.sendDtmf' | 'Call.startScreenSharing' | 'Call.startVideo' | 'Call.stopScreenSharing' | 'Call.stopVideo' | 'Call.unmute' | 'CallAgent.dispose' | 'CallAgent.join' | 'CallAgent.off' | 'CallAgent.on' | 'CallAgent.startCall' | 'CallClient.createCallAgent' | 'CallClient.getDeviceManager' | 'DeviceManager.askDevicePermission' | 'DeviceManager.getCameras' | 'DeviceManager.getMicrophones' | 'DeviceManager.getSpeakers' | 'DeviceManager.off' | 'DeviceManager.on' | 'DeviceManager.selectMicrophone' | 'DeviceManager.selectSpeaker';

// @public
export type CallIdChangedListener = (event: {
    callId: string;
}) => void;

// @public
export type CallingBaseSelectorProps = {
    callId: string;
};

// @public
export type CallingHandlers = {
    onStartLocalVideo: () => Promise<void>;
    onToggleCamera: (options?: VideoStreamOptions) => Promise<void>;
    onStartCall: (participants: (CommunicationUserIdentifier | PhoneNumberIdentifier | UnknownIdentifier)[], options?: StartCallOptions) => Call | undefined;
    onSelectMicrophone: (device: AudioDeviceInfo) => Promise<void>;
    onSelectSpeaker: (device: AudioDeviceInfo) => Promise<void>;
    onSelectCamera: (device: VideoDeviceInfo, options?: VideoStreamOptions) => Promise<void>;
    onToggleMicrophone: () => Promise<void>;
    onStartScreenShare: () => Promise<void>;
    onStopScreenShare: () => Promise<void>;
    onToggleScreenShare: () => Promise<void>;
    onHangUp: () => Promise<void>;
    onCreateLocalStreamView: (options?: VideoStreamOptions) => Promise<void>;
    onCreateRemoteStreamView: (userId: string, options?: VideoStreamOptions) => Promise<void>;
    onRemoveParticipant: (userId: string) => Promise<void>;
    onDisposeRemoteStreamView: (userId: string) => Promise<void>;
    onDisposeLocalStreamView: () => Promise<void>;
};

// @public
export type CallingReturnProps<Component extends (props: any) => JSX.Element> = GetCallingSelector<Component> extends (state: CallClientState, props: any) => any ? ReturnType<GetCallingSelector<Component>> & Common<CallingHandlers, Parameters<Component>[0]> : never;

// @public
export interface CallingTheme {
    // (undocumented)
    callingPalette: {
        callRed: string;
        callRedDark: string;
        callRedDarker: string;
        iconWhite: string;
    };
}

// @public
export type CallParticipantListParticipant = ParticipantListParticipant & {
    state: 'Idle' | 'Connecting' | 'Ringing' | 'Connected' | 'Hold' | 'InLobby' | 'EarlyMedia' | 'Disconnected';
    isScreenSharing?: boolean;
    isMuted?: boolean;
    isSpeaking?: boolean;
};

// @public
export const CallProvider: (props: CallProviderProps) => JSX.Element;

// @public
export interface CallProviderProps {
    // (undocumented)
    call?: Call;
    // (undocumented)
    children: React_2.ReactNode;
}

// @public
export interface CallState {
    callEndReason?: CallEndReason;
    callerInfo: CallerInfo;
    diagnostics: DiagnosticsCallFeatureState;
    direction: CallDirection;
    dominantSpeakers?: DominantSpeakersInfo;
    endTime: Date | undefined;
    id: string;
    isMuted: boolean;
    isScreenSharingOn: boolean;
    localVideoStreams: LocalVideoStreamState[];
    recording: RecordingCallFeature;
    remoteParticipants: {
        [keys: string]: RemoteParticipantState;
    };
    remoteParticipantsEnded: {
        [keys: string]: RemoteParticipantState;
    };
    screenShareRemoteParticipant?: string;
    startTime: Date;
    state: CallState_2;
    transcription: TranscriptionCallFeature;
}

// @public
export const CameraButton: (props: CameraButtonProps) => JSX.Element;

// @public
export interface CameraButtonContextualMenuStyles extends IContextualMenuStyles {
    menuItemStyles?: IContextualMenuItemStyles;
}

// @public
export interface CameraButtonProps extends ControlBarButtonProps {
    cameras?: OptionsDevice[];
    enableDeviceSelectionMenu?: boolean;
    localVideoViewOptions?: VideoStreamOptions;
    onSelectCamera?: (device: OptionsDevice) => Promise<void>;
    onToggleCamera?: (options?: VideoStreamOptions) => Promise<void>;
    selectedCamera?: OptionsDevice;
    strings?: Partial<CameraButtonStrings>;
    styles?: Partial<CameraButtonStyles>;
}

// @public
export type CameraButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    disabled: boolean;
    checked: boolean;
    cameras: VideoDeviceInfo[];
    selectedCamera?: VideoDeviceInfo;
};

// @public
export interface CameraButtonStrings {
    cameraMenuTitle: string;
    cameraMenuTooltip: string;
    offLabel: string;
    onLabel: string;
    tooltipDisabledContent?: string;
    tooltipOffContent?: string;
    tooltipOnContent?: string;
    tooltipVideoLoadingContent?: string;
}

// @public
export interface CameraButtonStyles extends ControlBarButtonStyles {
    menuStyles?: Partial<CameraButtonContextualMenuStyles>;
}

// Warning: (ae-incompatible-release-tags) The symbol "ChatAdapter" is marked as @public, but its signature references "FileUploadAdapter" which is marked as @beta
//
// @public
export type ChatAdapter = ChatAdapterThreadManagement & AdapterState<ChatAdapterState> & Disposable & ChatAdapterSubscribers & FileUploadAdapter;

// @public
export type ChatAdapterState = ChatAdapterUiState & ChatCompositeClientState;

// @public
export interface ChatAdapterSubscribers {
    off(event: 'messageReceived', listener: MessageReceivedListener): void;
    off(event: 'messageSent', listener: MessageSentListener): void;
    off(event: 'messageRead', listener: MessageReadListener): void;
    off(event: 'participantsAdded', listener: ParticipantsAddedListener): void;
    off(event: 'participantsRemoved', listener: ParticipantsRemovedListener): void;
    off(event: 'topicChanged', listener: TopicChangedListener): void;
    off(event: 'error', listener: (e: AdapterError) => void): void;
    on(event: 'messageReceived', listener: MessageReceivedListener): void;
    on(event: 'messageSent', listener: MessageSentListener): void;
    on(event: 'messageRead', listener: MessageReadListener): void;
    on(event: 'participantsAdded', listener: ParticipantsAddedListener): void;
    on(event: 'participantsRemoved', listener: ParticipantsRemovedListener): void;
    on(event: 'topicChanged', listener: TopicChangedListener): void;
    on(event: 'error', listener: (e: AdapterError) => void): void;
}

// @public
export interface ChatAdapterThreadManagement {
    deleteMessage(messageId: string): Promise<void>;
    fetchInitialData(): Promise<void>;
    loadPreviousChatMessages(messagesToLoad: number): Promise<boolean>;
    removeParticipant(userId: string): Promise<void>;
    sendMessage(content: string, options?: SendMessageOptions): Promise<void>;
    sendReadReceipt(chatMessageId: string): Promise<void>;
    sendTypingIndicator(): Promise<void>;
    setTopic(topicName: string): Promise<void>;
    updateMessage(messageId: string, content: string): Promise<void>;
}

// @public
export type ChatAdapterUiState = {
    error?: Error;
    fileUploads?: FileUploadsUiState;
};

// @public
export type ChatBaseSelectorProps = {
    threadId: string;
};

// @public
export const ChatClientProvider: (props: ChatClientProviderProps) => JSX.Element;

// @public
export type ChatClientProviderProps = {
    children: React_2.ReactNode;
    chatClient: StatefulChatClient;
};

// @public
export type ChatClientState = {
    userId: CommunicationIdentifierKind;
    displayName: string;
    threads: {
        [key: string]: ChatThreadClientState;
    };
    latestErrors: ChatErrors;
};

// @public
export const ChatComposite: (props: ChatCompositeProps) => JSX.Element;

// @public
export type ChatCompositeClientState = {
    userId: CommunicationIdentifierKind;
    displayName: string;
    thread: ChatThreadClientState;
    latestErrors: AdapterErrors;
};

// @public
export type ChatCompositeIcons = Partial<Pick<CompositeIcons, 'MessageDelivered' | 'MessageFailed' | 'MessageSeen' | 'MessageSending' | 'MessageEdit' | 'MessageRemove' | 'ParticipantItemOptions' | 'ParticipantItemOptionsHovered' | 'SendBoxSend' | 'SendBoxSendHovered' | 'EditBoxCancel' | 'EditBoxSubmit' | /* @conditional-compile-remove-from(stable): FILE_SHARING */ 'SendBoxAttachFile'>>;

// @public
export type ChatCompositeOptions = {
    errorBar?: boolean;
    participantPane?: boolean;
    topic?: boolean;
    autoFocus?: 'sendBoxTextField' | false;
    fileSharing?: FileSharingOptions;
};

// @public
export interface ChatCompositeProps extends BaseCompositeProps<ChatCompositeIcons> {
    adapter: ChatAdapter;
    onRenderMessage?: (messageProps: MessageProps, defaultOnRender?: MessageRenderer) => JSX.Element;
    onRenderTypingIndicator?: (typingUsers: CommunicationParticipant[]) => JSX.Element;
    options?: ChatCompositeOptions;
}

// @public
export interface ChatCompositeStrings {
    chatListHeader: string;
}

// @public
export class ChatError extends Error {
    constructor(target: ChatErrorTarget, innerError: Error, timestamp?: Date);
    innerError: Error;
    target: ChatErrorTarget;
    timestamp: Date;
}

// @public
export type ChatErrorBarSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    activeErrorMessages: ActiveErrorMessage[];
};

// @public
export type ChatErrors = {
    [target in ChatErrorTarget]: ChatError;
};

// @public
export type ChatErrorTarget = 'ChatClient.createChatThread' | 'ChatClient.deleteChatThread' | 'ChatClient.getChatThreadClient' | 'ChatClient.listChatThreads' | 'ChatClient.off' | 'ChatClient.on' | 'ChatClient.startRealtimeNotifications' | 'ChatClient.stopRealtimeNotifications' | 'ChatThreadClient.addParticipants' | 'ChatThreadClient.deleteMessage' | 'ChatThreadClient.getMessage' | 'ChatThreadClient.getProperties' | 'ChatThreadClient.listMessages' | 'ChatThreadClient.listParticipants' | 'ChatThreadClient.listReadReceipts' | 'ChatThreadClient.removeParticipant' | 'ChatThreadClient.sendMessage' | 'ChatThreadClient.sendReadReceipt' | 'ChatThreadClient.sendTypingNotification' | 'ChatThreadClient.updateMessage' | 'ChatThreadClient.updateTopic';

// @public
export type ChatHandlers = {
    onSendMessage: (content: string, options?: SendMessageOptions) => Promise<void>;
    onMessageSeen: (chatMessageId: string) => Promise<void>;
    onTyping: () => Promise<void>;
    onRemoveParticipant: (userId: string) => Promise<void>;
    updateThreadTopicName: (topicName: string) => Promise<void>;
    onLoadPreviousChatMessages: (messagesToLoad: number) => Promise<boolean>;
    onUpdateMessage: (messageId: string, content: string) => Promise<void>;
    onDeleteMessage: (messageId: string) => Promise<void>;
};

// @public
export interface ChatMessage extends MessageCommon {
    // (undocumented)
    attached?: MessageAttachedStatus;
    // (undocumented)
    clientMessageId?: string;
    // (undocumented)
    content?: string;
    // (undocumented)
    contentType: MessageContentType;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    editedOn?: Date;
    // (undocumented)
    messageType: 'chat';
    metadata?: Record<string, string>;
    // (undocumented)
    mine?: boolean;
    // (undocumented)
    senderDisplayName?: string;
    // (undocumented)
    senderId?: string;
    // (undocumented)
    status?: MessageStatus;
}

// @public
export type ChatMessageWithStatus = ChatMessage_2 & {
    clientMessageId?: string;
    status: MessageStatus;
};

// @public
export type ChatParticipantListSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    myUserId: string;
    participants: ParticipantListParticipant[];
};

// @public
export type ChatReturnProps<Component extends (props: any) => JSX.Element> = GetChatSelector<Component> extends (state: ChatClientState, props: any) => any ? ReturnType<GetChatSelector<Component>> & Common<ChatHandlers, Parameters<Component>[0]> : never;

// @public
export const ChatThreadClientProvider: (props: ChatThreadClientProviderProps) => JSX.Element;

// @public
export type ChatThreadClientProviderProps = {
    children: React_2.ReactNode;
    chatThreadClient: ChatThreadClient;
};

// @public
export type ChatThreadClientState = {
    chatMessages: {
        [key: string]: ChatMessageWithStatus;
    };
    participants: {
        [key: string]: ChatParticipant;
    };
    threadId: string;
    properties?: ChatThreadProperties;
    readReceipts: ChatMessageReadReceipt[];
    typingIndicators: TypingIndicatorReceivedEvent[];
    latestReadTime: Date;
};

// @public
export type ChatThreadProperties = {
    topic?: string;
};

// @public
export type ClientState = CallClientState & ChatClientState;

// @public
export type Common<A, B> = Pick<A, CommonProperties<A, B>>;

// @public
export type CommonProperties<A, B> = {
    [P in keyof A & keyof B]: A[P] extends B[P] ? P : never;
}[keyof A & keyof B];

// @public
export type CommunicationParticipant = {
    userId: string;
    displayName?: string;
};

// @public
export const COMPONENT_LOCALE_DE_DE: ComponentLocale;

// @public
export const COMPONENT_LOCALE_EN_GB: ComponentLocale;

// @public
export const COMPONENT_LOCALE_EN_US: ComponentLocale;

// @public
export const COMPONENT_LOCALE_ES_ES: ComponentLocale;

// @public
export const COMPONENT_LOCALE_FR_FR: ComponentLocale;

// @public
export const COMPONENT_LOCALE_IT_IT: ComponentLocale;

// @public
export const COMPONENT_LOCALE_JA_JP: ComponentLocale;

// @public
export const COMPONENT_LOCALE_KO_KR: ComponentLocale;

// @public
export const COMPONENT_LOCALE_NL_NL: ComponentLocale;

// @public
export const COMPONENT_LOCALE_PT_BR: ComponentLocale;

// @public
export const COMPONENT_LOCALE_RU_RU: ComponentLocale;

// @public
export const COMPONENT_LOCALE_TR_TR: ComponentLocale;

// @public
export const COMPONENT_LOCALE_ZH_CN: ComponentLocale;

// @public
export const COMPONENT_LOCALE_ZH_TW: ComponentLocale;

// @public
export type ComponentIcons = Record<keyof typeof DEFAULT_COMPONENT_ICONS, JSX.Element>;

// @public
export interface ComponentLocale {
    strings: ComponentStrings;
}

// @public
export type ComponentProps<Component extends (props: any) => JSX.Element> = ChatReturnProps<Component> extends never ? CallingReturnProps<Component> extends never ? undefined : CallingReturnProps<Component> : ChatReturnProps<Component>;

// @public
export interface ComponentStrings {
    cameraButton: CameraButtonStrings;
    devicesButton: DevicesButtonStrings;
    endCallButton: EndCallButtonStrings;
    errorBar: ErrorBarStrings;
    messageStatusIndicator: MessageStatusIndicatorStrings;
    messageThread: MessageThreadStrings;
    microphoneButton: MicrophoneButtonStrings;
    participantItem: ParticipantItemStrings;
    participantsButton: ParticipantsButtonStrings;
    screenShareButton: ScreenShareButtonStrings;
    sendBox: SendBoxStrings;
    typingIndicator: TypingIndicatorStrings;
    videoGallery: VideoGalleryStrings;
}

// @public
export const COMPOSITE_LOCALE_DE_DE: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_EN_GB: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_EN_US: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_ES_ES: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_FR_FR: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_IT_IT: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_JA_JP: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_KO_KR: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_NL_NL: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_PT_BR: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_RU_RU: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_TR_TR: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_ZH_CN: CompositeLocale;

// @public
export const COMPOSITE_LOCALE_ZH_TW: CompositeLocale;

// @public
export const COMPOSITE_ONLY_ICONS: {
    LobbyScreenConnectingToCall: JSX.Element;
    LobbyScreenWaitingToBeAdmitted: JSX.Element;
    LocalDeviceSettingsCamera: JSX.Element;
    LocalDeviceSettingsMic: JSX.Element;
    LocalDeviceSettingsSpeaker: JSX.Element;
    LocalPreviewPlaceholder: JSX.Element;
    LocalCameraSwitch: JSX.Element;
    ControlBarButtonBadgeIcon: JSX.Element;
    Muted: JSX.Element;
    NetworkReconnectIcon: JSX.Element;
    NoticePageAccessDeniedTeamsMeeting: JSX.Element;
    NoticePageJoinCallFailedDueToNoNetwork: JSX.Element;
    NoticePageLeftCall: JSX.Element;
    NoticePageRemovedFromCall: JSX.Element;
    SendBoxAttachFile: JSX.Element;
};

// @public
export type CompositeIcons = ComponentIcons & Record<keyof typeof COMPOSITE_ONLY_ICONS, JSX.Element>;

// @public
export interface CompositeLocale {
    component: ComponentLocale;
    strings: CompositeStrings;
}

// @public
export interface CompositeStrings {
    call: CallCompositeStrings;
    chat: ChatCompositeStrings;
    meeting: MeetingCompositeStrings;
}

// @public
export interface ContentSystemMessage extends SystemMessageCommon {
    // (undocumented)
    content: string;
    // (undocumented)
    systemMessageType: 'content';
}

// @public
export const ControlBar: (props: ControlBarProps) => JSX.Element;

// @public
export const ControlBarButton: (props: ControlBarButtonProps) => JSX.Element;

// @public
export interface ControlBarButtonProps extends IButtonProps {
    labelKey?: string;
    onRenderOffIcon?: IRenderFunction<IButtonProps>;
    onRenderOnIcon?: IRenderFunction<IButtonProps>;
    showLabel?: boolean;
    strings?: ControlBarButtonStrings;
    styles?: ControlBarButtonStyles;
    tooltipId?: string;
}

// @public
export interface ControlBarButtonStrings {
    label?: string;
    offLabel?: string;
    onLabel?: string;
    tooltipContent?: string;
    tooltipDisabledContent?: string;
    tooltipOffContent?: string;
    tooltipOnContent?: string;
}

// @public
export type ControlBarButtonStyles = IButtonStyles;

// @public
export type ControlBarLayout = 'horizontal' | 'vertical' | 'dockedTop' | 'dockedBottom' | 'dockedLeft' | 'dockedRight' | 'floatingTop' | 'floatingBottom' | 'floatingLeft' | 'floatingRight';

// @public
export interface ControlBarProps {
    children?: React_2.ReactNode;
    layout?: ControlBarLayout;
    styles?: BaseCustomStyles;
}

// @public
export const createAzureCommunicationCallAdapter: ({ userId, displayName, credential, locator }: AzureCommunicationCallAdapterArgs) => Promise<CallAdapter>;

// @public
export const createAzureCommunicationCallAdapterFromClient: (callClient: StatefulCallClient, callAgent: CallAgent, locator: TeamsMeetingLinkLocator | GroupCallLocator) => Promise<CallAdapter>;

// @public
export const createAzureCommunicationChatAdapter: ({ endpoint: endpointUrl, userId, displayName, credential, threadId }: AzureCommunicationChatAdapterArgs) => Promise<ChatAdapter>;

// @public
export const createAzureCommunicationChatAdapterFromClient: (chatClient: StatefulChatClient, chatThreadClient: ChatThreadClient) => Promise<ChatAdapter>;

// @beta
export const createAzureCommunicationMeetingAdapter: ({ userId, displayName, credential, endpoint, meetingLocator }: AzureCommunicationMeetingAdapterArgs) => Promise<MeetingAdapter>;

// @public
export const createDefaultCallingHandlers: (callClient: StatefulCallClient, callAgent: CallAgent | undefined, deviceManager: StatefulDeviceManager | undefined, call: Call | undefined) => CallingHandlers;

// @public
export const createDefaultChatHandlers: (chatClient: StatefulChatClient, chatThreadClient: ChatThreadClient) => ChatHandlers;

// @public
export const createStatefulCallClient: (args: StatefulCallClientArgs, options?: StatefulCallClientOptions | undefined) => StatefulCallClient;

// @public
export const createStatefulChatClient: (args: StatefulChatClientArgs, options?: StatefulChatClientOptions | undefined) => StatefulChatClient;

// @public
export type CustomAvatarOptions = {
    coinSize?: number;
    hidePersonaDetails?: boolean;
    initialsTextColor?: string;
    noVideoAvailableAriaLabel?: string;
    presence?: PersonaPresence;
    size?: PersonaSize;
    styles?: IStyleFunctionOrObject<IPersonaStyleProps, IPersonaStyles>;
    text?: string;
};

// @beta
export type CustomCallControlButtonCallback = (args: CustomCallControlButtonCallbackArgs) => CustomCallControlButtonProps;

// @beta
export interface CustomCallControlButtonCallbackArgs {
    displayType?: CallControlDisplayType;
}

// @beta
export type CustomCallControlButtonPlacement = 'first' | 'last' | 'afterCameraButton' | 'afterEndCallButton' | 'afterMicrophoneButton' | 'afterOptionsButton' | 'afterParticipantsButton' | 'afterScreenShareButton';

// @beta
export interface CustomCallControlButtonProps extends ControlBarButtonProps {
    placement: CustomCallControlButtonPlacement;
}

// @public
export interface CustomMessage extends MessageCommon {
    // (undocumented)
    content: string;
    // (undocumented)
    messageType: 'custom';
}

// @public
export const darkTheme: PartialTheme & CallingTheme;

// @public
export const DEFAULT_COMPONENT_ICONS: {
    ControlButtonCameraOff: JSX.Element;
    ControlButtonCameraOn: JSX.Element;
    ControlButtonEndCall: JSX.Element;
    ControlButtonMicOff: JSX.Element;
    ControlButtonMicOn: JSX.Element;
    ControlButtonOptions: JSX.Element;
    ControlButtonParticipants: JSX.Element;
    ControlButtonScreenShareStart: JSX.Element;
    ControlButtonScreenShareStop: JSX.Element;
    EditBoxCancel: JSX.Element;
    EditBoxSubmit: JSX.Element;
    ErrorBarCallCameraAccessDenied: JSX.Element;
    ErrorBarCallCameraAlreadyInUse: JSX.Element;
    ErrorBarCallLocalVideoFreeze: JSX.Element;
    ErrorBarCallMacOsCameraAccessDenied: JSX.Element;
    ErrorBarCallMacOsMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneMutedBySystem: JSX.Element;
    ErrorBarCallNetworkQualityLow: JSX.Element;
    ErrorBarCallNoMicrophoneFound: JSX.Element;
    ErrorBarCallNoSpeakerFound: JSX.Element;
    HorizontalGalleryLeftButton: JSX.Element;
    HorizontalGalleryRightButton: JSX.Element;
    MessageDelivered: JSX.Element;
    MessageEdit: JSX.Element;
    MessageFailed: JSX.Element;
    MessageRemove: JSX.Element;
    MessageSeen: JSX.Element;
    MessageSending: JSX.Element;
    OptionsCamera: JSX.Element;
    OptionsMic: JSX.Element;
    OptionsSpeaker: JSX.Element;
    ParticipantItemMicOff: JSX.Element;
    ParticipantItemOptions: JSX.Element;
    ParticipantItemOptionsHovered: JSX.Element;
    ParticipantItemScreenShareStart: JSX.Element;
    SendBoxSend: JSX.Element;
    SendBoxSendHovered: JSX.Element;
    VideoTileMicOff: JSX.Element;
};

// @public
export const DEFAULT_COMPOSITE_ICONS: {
    LobbyScreenConnectingToCall: JSX.Element;
    LobbyScreenWaitingToBeAdmitted: JSX.Element;
    LocalDeviceSettingsCamera: JSX.Element;
    LocalDeviceSettingsMic: JSX.Element;
    LocalDeviceSettingsSpeaker: JSX.Element;
    LocalPreviewPlaceholder: JSX.Element;
    LocalCameraSwitch: JSX.Element;
    ControlBarButtonBadgeIcon: JSX.Element;
    Muted: JSX.Element;
    NetworkReconnectIcon: JSX.Element;
    NoticePageAccessDeniedTeamsMeeting: JSX.Element;
    NoticePageJoinCallFailedDueToNoNetwork: JSX.Element;
    NoticePageLeftCall: JSX.Element;
    NoticePageRemovedFromCall: JSX.Element;
    SendBoxAttachFile: JSX.Element;
    ControlButtonCameraOff: JSX.Element;
    ControlButtonCameraOn: JSX.Element;
    ControlButtonEndCall: JSX.Element;
    ControlButtonMicOff: JSX.Element;
    ControlButtonMicOn: JSX.Element;
    ControlButtonOptions: JSX.Element;
    ControlButtonParticipants: JSX.Element;
    ControlButtonScreenShareStart: JSX.Element;
    ControlButtonScreenShareStop: JSX.Element;
    EditBoxCancel: JSX.Element;
    EditBoxSubmit: JSX.Element;
    ErrorBarCallCameraAccessDenied: JSX.Element;
    ErrorBarCallCameraAlreadyInUse: JSX.Element;
    ErrorBarCallLocalVideoFreeze: JSX.Element;
    ErrorBarCallMacOsCameraAccessDenied: JSX.Element;
    ErrorBarCallMacOsMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneAccessDenied: JSX.Element;
    ErrorBarCallMicrophoneMutedBySystem: JSX.Element;
    ErrorBarCallNetworkQualityLow: JSX.Element;
    ErrorBarCallNoMicrophoneFound: JSX.Element;
    ErrorBarCallNoSpeakerFound: JSX.Element;
    HorizontalGalleryLeftButton: JSX.Element;
    HorizontalGalleryRightButton: JSX.Element;
    MessageDelivered: JSX.Element;
    MessageEdit: JSX.Element;
    MessageFailed: JSX.Element;
    MessageRemove: JSX.Element;
    MessageSeen: JSX.Element;
    MessageSending: JSX.Element;
    OptionsCamera: JSX.Element;
    OptionsMic: JSX.Element;
    OptionsSpeaker: JSX.Element;
    ParticipantItemMicOff: JSX.Element;
    ParticipantItemOptions: JSX.Element;
    ParticipantItemOptionsHovered: JSX.Element;
    ParticipantItemScreenShareStart: JSX.Element;
    SendBoxSend: JSX.Element;
    SendBoxSendHovered: JSX.Element;
    VideoTileMicOff: JSX.Element;
};

// @public
export type DeviceManagerState = {
    isSpeakerSelectionAvailable: boolean;
    selectedMicrophone?: AudioDeviceInfo;
    selectedSpeaker?: AudioDeviceInfo;
    selectedCamera?: VideoDeviceInfo;
    cameras: VideoDeviceInfo[];
    microphones: AudioDeviceInfo[];
    speakers: AudioDeviceInfo[];
    deviceAccess?: DeviceAccess;
    unparentedViews: LocalVideoStreamState[];
};

// @public
export const DevicesButton: (props: DevicesButtonProps) => JSX.Element;

// @public
export interface DevicesButtonContextualMenuStyles extends IContextualMenuStyles {
    menuItemStyles?: IContextualMenuItemStyles;
}

// @public
export interface DevicesButtonProps extends ControlBarButtonProps {
    cameras?: OptionsDevice[];
    microphones?: OptionsDevice[];
    onSelectCamera?: (device: OptionsDevice) => Promise<void>;
    onSelectMicrophone?: (device: OptionsDevice) => Promise<void>;
    onSelectSpeaker?: (device: OptionsDevice) => Promise<void>;
    selectedCamera?: OptionsDevice;
    selectedMicrophone?: OptionsDevice;
    selectedSpeaker?: OptionsDevice;
    speakers?: OptionsDevice[];
    strings?: Partial<DevicesButtonStrings>;
    styles?: DevicesButtonStyles;
}

// @public
export type DevicesButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    microphones: AudioDeviceInfo[];
    speakers: AudioDeviceInfo[];
    cameras: VideoDeviceInfo[];
    selectedMicrophone?: AudioDeviceInfo;
    selectedSpeaker?: AudioDeviceInfo;
    selectedCamera?: VideoDeviceInfo;
};

// @public
export interface DevicesButtonStrings {
    cameraMenuTitle: string;
    cameraMenuTooltip: string;
    label: string;
    microphoneMenuTitle: string;
    microphoneMenuTooltip: string;
    speakerMenuTitle: string;
    speakerMenuTooltip: string;
    tooltipContent?: string;
}

// @public
export interface DevicesButtonStyles extends ControlBarButtonStyles {
    menuStyles?: Partial<DevicesButtonContextualMenuStyles>;
}

// @public
export type DiagnosticChangedEventListner = (event: MediaDiagnosticChangedEvent | NetworkDiagnosticChangedEvent) => void;

// @public
export interface DiagnosticsCallFeatureState {
    media: MediaDiagnosticsState;
    network: NetworkDiagnosticsState;
}

// @public
export type DisplayNameChangedListener = (event: {
    participantId: CommunicationIdentifierKind;
    displayName: string;
}) => void;

// @public
export interface Disposable {
    dispose(): void;
}

// @public
export type EmptySelector = () => Record<string, never>;

// @public
export const EndCallButton: (props: EndCallButtonProps) => JSX.Element;

// @public
export interface EndCallButtonProps extends ControlBarButtonProps {
    onHangUp?: () => Promise<void>;
    strings?: EndCallButtonStrings;
}

// @public
export interface EndCallButtonStrings {
    label: string;
    tooltipContent?: string;
}

// @public
export const ErrorBar: (props: ErrorBarProps) => JSX.Element;

// @public
export interface ErrorBarProps extends IMessageBarProps {
    activeErrorMessages: ActiveErrorMessage[];
    strings?: ErrorBarStrings;
}

// @public
export interface ErrorBarStrings {
    accessDenied: string;
    callCameraAccessDenied: string;
    callCameraAlreadyInUse: string;
    callLocalVideoFreeze: string;
    callMacOsCameraAccessDenied: string;
    callMacOsMicrophoneAccessDenied: string;
    callMacOsScreenShareAccessDenied: string;
    callMicrophoneAccessDenied: string;
    callMicrophoneMutedBySystem: string;
    callNetworkQualityLow: string;
    callNoMicrophoneFound: string;
    callNoSpeakerFound: string;
    muteGeneric: string;
    sendMessageGeneric: string;
    sendMessageNotInChatThread: string;
    startScreenShareGeneric: string;
    startVideoGeneric: string;
    stopScreenShareGeneric: string;
    stopVideoGeneric: string;
    unableToReachChatService: string;
    unmuteGeneric: string;
    userNotInChatThread: string;
}

// @public
export type ErrorType = keyof ErrorBarStrings;

// @beta
export interface FileMetadata {
    extension: string;
    name: string;
    url: string;
}

// @beta
export interface FileSharingOptions {
    accept?: string;
    multiple?: boolean;
    uploadHandler: FileUploadHandler;
}

// @beta (undocumented)
export interface FileUploadAdapter {
    // (undocumented)
    cancelFileUpload?: (id: string) => void;
    // (undocumented)
    clearFileUploads?: () => void;
    // (undocumented)
    registerFileUploads?: (fileUploads: ObservableFileUpload[]) => void;
}

// @beta (undocumented)
export interface FileUploadEventEmitter {
    off(event: 'uploadProgressed', listener: UploadProgressListener): void;
    off(event: 'uploadCompleted', listener: UploadCompleteListener): void;
    off(event: 'uploadFailed', listener: UploadFailedListener): void;
    on(event: 'uploadProgressed', listener: UploadProgressListener): void;
    on(event: 'uploadCompleted', listener: UploadCompleteListener): void;
    on(event: 'uploadFailed', listener: UploadFailedListener): void;
}

// @beta
export type FileUploadHandler = (userId: CommunicationIdentifierKind, fileUploads: FileUploadManager[]) => void;

// @beta
export interface FileUploadManager {
    file: File;
    notifyUploadCompleted: (metadata: FileMetadata) => void;
    notifyUploadFailed: (message: string) => void;
    notifyUploadProgressed: (value: number) => void;
}

// @beta
export interface FileUploadState {
    errorMessage?: string;
    filename: string;
    id: string;
    metadata?: FileMetadata;
    progress: number;
}

// @beta
export type FileUploadsUiState = Record<string, FileUploadState>;

// @public
export const FluentThemeProvider: (props: FluentThemeProviderProps) => JSX.Element;

// @public
export interface FluentThemeProviderProps {
    children: React_2.ReactNode;
    fluentTheme?: PartialTheme | Theme;
    rtl?: boolean;
}

// @public
export const fromFlatCommunicationIdentifier: (id: string) => CommunicationIdentifier;

// @public
export type GetCallingSelector<Component extends (props: any) => JSX.Element | undefined> = AreEqual<Component, typeof VideoGallery> extends true ? VideoGallerySelector : AreEqual<Component, typeof DevicesButton> extends true ? DevicesButtonSelector : AreEqual<Component, typeof MicrophoneButton> extends true ? MicrophoneButtonSelector : AreEqual<Component, typeof CameraButton> extends true ? CameraButtonSelector : AreEqual<Component, typeof ScreenShareButton> extends true ? ScreenShareButtonSelector : AreEqual<Component, typeof ParticipantList> extends true ? ParticipantListSelector : AreEqual<Component, typeof ParticipantsButton> extends true ? ParticipantsButtonSelector : AreEqual<Component, typeof EndCallButton> extends true ? EmptySelector : AreEqual<Component, typeof ErrorBar> extends true ? CallErrorBarSelector : undefined;

// @public
export const getCallingSelector: <Component extends (props: any) => JSX.Element | undefined>(component: Component) => GetCallingSelector<Component>;

// @public
export type GetChatSelector<Component extends (props: any) => JSX.Element | undefined> = AreEqual<Component, typeof SendBox> extends true ? SendBoxSelector : AreEqual<Component, typeof MessageThread> extends true ? MessageThreadSelector : AreEqual<Component, typeof TypingIndicator> extends true ? TypingIndicatorSelector : AreEqual<Component, typeof ParticipantList> extends true ? ChatParticipantListSelector : AreEqual<Component, typeof ErrorBar> extends true ? ChatErrorBarSelector : undefined;

// @public
export const getChatSelector: <Component extends (props: any) => JSX.Element | undefined>(component: Component) => GetChatSelector<Component>;

// @public
export const GridLayout: (props: GridLayoutProps) => JSX.Element;

// @public
export interface GridLayoutProps {
    // (undocumented)
    children: React_2.ReactNode;
    styles?: BaseCustomStyles;
}

// @public
export interface GridLayoutStyles extends BaseCustomStyles {
    children?: IStyle;
}

// @public
export interface HorizontalGalleryStyles extends BaseCustomStyles {
    children?: IStyle;
    nextButton?: IStyle;
    previousButton?: IStyle;
}

// @internal
export const _IdentifierProvider: (props: _IdentifierProviderProps) => JSX.Element;

// @internal
export interface _IdentifierProviderProps {
    // (undocumented)
    children: React_2.ReactNode;
    // (undocumented)
    identifiers?: _Identifiers;
}

// @internal
export interface _Identifiers {
    horizontalGalleryLeftNavButton: string;
    horizontalGalleryRightNavButton: string;
    messageContent: string;
    messageTimestamp: string;
    participantButtonPeopleMenuItem: string;
    participantItemMenuButton: string;
    participantList: string;
    participantListPeopleButton: string;
    participantListRemoveParticipantButton: string;
    sendboxTextField: string;
    typingIndicator: string;
    videoGallery: string;
    videoTile: string;
}

// @public
export interface IncomingCallState {
    callEndReason?: CallEndReason;
    callerInfo: CallerInfo;
    endTime?: Date;
    id: string;
    startTime: Date;
}

// @public
export type IsLocalScreenSharingActiveChangedListener = (event: {
    isScreenSharingOn: boolean;
}) => void;

// @public
export type IsMutedChangedListener = (event: {
    identifier: CommunicationIdentifierKind;
    isMuted: boolean;
}) => void;

// @public
export type IsSpeakingChangedListener = (event: {
    identifier: CommunicationIdentifierKind;
    isSpeaking: boolean;
}) => void;

// @public
export interface JumpToNewMessageButtonProps {
    onClick: () => void;
    text: string;
}

// @public
export const lightTheme: PartialTheme & CallingTheme;

// @public
export const LocalizationProvider: (props: LocalizationProviderProps) => JSX.Element;

// @public
export type LocalizationProviderProps = {
    locale: ComponentLocale;
    children: React_2.ReactNode;
};

// @beta (undocumented)
export interface LocalVideoCameraCycleButtonProps {
    cameras?: OptionsDevice[];
    label?: string;
    onSelectCamera?: (device: OptionsDevice) => Promise<void>;
    selectedCamera?: OptionsDevice;
}

// @public
export interface LocalVideoStreamState {
    mediaStreamType: MediaStreamType;
    source: VideoDeviceInfo;
    view?: VideoStreamRendererViewState;
}

// @public
export type MediaDiagnosticChangedEvent = MediaDiagnosticChangedEventArgs & {
    type: 'media';
};

// @public
export interface MediaDiagnosticsState {
    // (undocumented)
    latest: LatestMediaDiagnostics;
}

// @beta
export interface MeetingAdapter extends MeetingAdapterMeetingManagement, AdapterState<MeetingAdapterState>, Disposable, MeetingAdapterSubscriptions {
}

// @beta
export interface MeetingAdapterClientState extends Pick<CallAdapterClientState, 'devices' | 'isTeamsCall'> {
    displayName: string | undefined;
    meeting: MeetingState | undefined;
    userId: CommunicationIdentifierKind;
}

// @beta
export interface MeetingAdapterMeetingManagement extends Pick<CallAdapterCallManagement, 'startCamera' | 'stopCamera' | 'mute' | 'unmute' | 'startScreenShare' | 'stopScreenShare' | 'createStreamView' | 'disposeStreamView'>, Pick<CallAdapterDeviceManagement, 'setCamera' | 'setMicrophone' | 'setSpeaker' | 'askDevicePermission' | 'queryCameras' | 'queryMicrophones' | 'querySpeakers'>, Pick<ChatAdapterThreadManagement, 'fetchInitialData' | 'sendMessage' | 'sendReadReceipt' | 'sendTypingIndicator' | 'loadPreviousChatMessages' | 'updateMessage' | 'deleteMessage'> {
    joinMeeting(microphoneOn?: boolean): Call | undefined;
    leaveMeeting(): Promise<void>;
    removeParticipant(userId: string): Promise<void>;
    startMeeting(participants: string[]): Call | undefined;
}

// @beta
export interface MeetingAdapterState extends MeetingAdapterUiState, MeetingAdapterClientState {
}

// @beta
export interface MeetingAdapterSubscriptions {
    // (undocumented)
    off(event: 'participantsJoined', listener: ParticipantsJoinedListener): void;
    // (undocumented)
    off(event: 'participantsLeft', listener: ParticipantsLeftListener): void;
    // (undocumented)
    off(event: 'meetingEnded', listener: CallEndedListener): void;
    // (undocumented)
    off(event: 'error', listener: (e: Error) => void): void;
    // (undocumented)
    off(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    // (undocumented)
    off(event: 'callIdChanged', listener: CallIdChangedListener): void;
    // (undocumented)
    off(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    // (undocumented)
    off(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    // (undocumented)
    off(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    // (undocumented)
    off(event: 'messageReceived', listener: MessageReceivedListener): void;
    // (undocumented)
    off(event: 'messageSent', listener: MessageSentListener): void;
    // (undocumented)
    off(event: 'messageRead', listener: MessageReadListener): void;
    // (undocumented)
    on(event: 'participantsJoined', listener: ParticipantsJoinedListener): void;
    // (undocumented)
    on(event: 'participantsLeft', listener: ParticipantsLeftListener): void;
    // (undocumented)
    on(event: 'meetingEnded', listener: CallEndedListener): void;
    // (undocumented)
    on(event: 'error', listener: (e: Error) => void): void;
    // (undocumented)
    on(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    // (undocumented)
    on(event: 'callIdChanged', listener: CallIdChangedListener): void;
    // (undocumented)
    on(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    // (undocumented)
    on(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    // (undocumented)
    on(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    // (undocumented)
    on(event: 'messageReceived', listener: MessageReceivedListener): void;
    // (undocumented)
    on(event: 'messageSent', listener: MessageSentListener): void;
    // (undocumented)
    on(event: 'messageRead', listener: MessageReadListener): void;
}

// @beta
export interface MeetingAdapterUiState extends Pick<CallAdapterUiState, 'isLocalPreviewMicrophoneEnabled'> {
    page: MeetingCompositePage;
}

// @beta
export interface MeetingCallControlOptions extends Pick<CallControlOptions, 'cameraButton' | 'microphoneButton' | 'screenShareButton' | 'devicesButton' | 'displayType'> {
    chatButton?: boolean;
    peopleButton?: boolean;
}

// @beta
export const MeetingComposite: (props: MeetingCompositeProps) => JSX.Element;

// @beta
export type MeetingCompositeOptions = {
    callControls?: boolean | MeetingCallControlOptions;
};

// @beta
export type MeetingCompositePage = 'accessDeniedTeamsMeeting' | 'configuration' | 'joinMeetingFailedDueToNoNetwork' | 'leftMeeting' | 'lobby' | 'meeting' | 'removedFromMeeting';

// @beta
export interface MeetingCompositeProps extends BaseCompositeProps<CallCompositeIcons & ChatCompositeIcons> {
    fluentTheme?: PartialTheme | Theme;
    formFactor?: 'desktop' | 'mobile';
    // (undocumented)
    meetingAdapter: MeetingAdapter;
    meetingInvitationURL?: string;
    options?: MeetingCompositeOptions;
}

// @public
export interface MeetingCompositeStrings {
    chatButtonLabel: string;
    chatPaneTitle: string;
    peopleButtonLabel: string;
    peoplePaneSubTitle: string;
    peoplePaneTitle: string;
    pictureInPictureTileAriaLabel: string;
}

// @beta
export type MeetingEndReason = CallEndReason;

// @beta
export type MeetingEvent = 'participantsJoined' | 'participantsLeft' | 'meetingEnded' | 'isMutedChanged' | 'callIdChanged' | 'isLocalScreenSharingActiveChanged' | 'displayNameChanged' | 'isSpeakingChanged' | 'messageReceived' | 'messageSent' | 'messageRead' | 'error';

// @beta
export interface MeetingParticipant extends Pick<RemoteParticipantState, 'displayName' | 'state' | 'videoStreams' | 'isMuted' | 'isSpeaking'> {
    id: CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind;
    meetingEndReason?: MeetingEndReason;
}

// @beta
export interface MeetingState extends Pick<CallState, 'callerInfo' | 'state' | 'isMuted' | 'isScreenSharingOn' | 'localVideoStreams' | 'transcription' | 'recording' | 'screenShareRemoteParticipant' | 'startTime' | 'endTime' | 'diagnostics' | 'dominantSpeakers'>, Pick<ChatThreadClientState, 'chatMessages' | 'threadId' | 'properties' | 'readReceipts' | 'typingIndicators' | 'latestReadTime'> {
    id: string;
    meetingEndReason?: MeetingEndReason;
    participants: {
        [key: string]: MeetingParticipant;
    };
    participantsEnded: {
        [keys: string]: MeetingParticipant;
    };
}

// @public
export type Message = ChatMessage | SystemMessage | CustomMessage;

// @public
export type MessageAttachedStatus = 'bottom' | 'top' | boolean;

// @public
export interface MessageCommon {
    // (undocumented)
    createdOn: Date;
    // (undocumented)
    messageId: string;
}

// @public
export type MessageContentType = 'text' | 'html' | 'richtext/html' | 'unknown';

// @public
export type MessageProps = {
    message: Message;
    strings: MessageThreadStrings;
    messageContainerStyle?: ComponentSlotStyle;
    showDate?: boolean;
    disableEditing?: boolean;
    onUpdateMessage?: (messageId: string, content: string) => Promise<void>;
    onDeleteMessage?: (messageId: string) => Promise<void>;
};

// @public
export type MessageReadListener = (event: {
    message: ChatMessage_2;
    readBy: CommunicationUserKind;
}) => void;

// @public
export type MessageReceivedListener = (event: {
    message: ChatMessage_2;
}) => void;

// @public
export type MessageRenderer = (props: MessageProps) => JSX.Element;

// @public
export type MessageSentListener = MessageReceivedListener;

// @public
export type MessageStatus = 'delivered' | 'sending' | 'seen' | 'failed';

// @public
export const MessageStatusIndicator: (props: MessageStatusIndicatorProps) => JSX.Element;

// @public
export interface MessageStatusIndicatorProps {
    status?: MessageStatus;
    strings?: MessageStatusIndicatorStrings;
    styles?: BaseCustomStyles;
}

// @public
export interface MessageStatusIndicatorStrings {
    deliveredAriaLabel?: string;
    deliveredTooltipText: string;
    failedToSendAriaLabel?: string;
    failedToSendTooltipText: string;
    seenAriaLabel?: string;
    seenTooltipText: string;
    sendingAriaLabel?: string;
    sendingTooltipText: string;
}

// @public
export const MessageThread: (props: MessageThreadProps) => JSX.Element;

// @public
export type MessageThreadProps = {
    userId: string;
    messages: (ChatMessage | SystemMessage | CustomMessage)[];
    styles?: MessageThreadStyles;
    disableJumpToNewMessageButton?: boolean;
    showMessageDate?: boolean;
    showMessageStatus?: boolean;
    numberOfChatMessagesToReload?: number;
    onMessageSeen?: (messageId: string) => Promise<void>;
    onRenderMessageStatus?: (messageStatusIndicatorProps: MessageStatusIndicatorProps) => JSX.Element | null;
    onRenderAvatar?: OnRenderAvatarCallback;
    onRenderJumpToNewMessageButton?: (newMessageButtonProps: JumpToNewMessageButtonProps) => JSX.Element;
    onLoadPreviousChatMessages?: (messagesToLoad: number) => Promise<boolean>;
    onRenderMessage?: (messageProps: MessageProps, messageRenderer?: MessageRenderer) => JSX.Element;
    onUpdateMessage?: (messageId: string, content: string) => Promise<void>;
    onDeleteMessage?: (messageId: string) => Promise<void>;
    disableEditing?: boolean;
    strings?: Partial<MessageThreadStrings>;
};

// @public
export type MessageThreadSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    userId: string;
    showMessageStatus: boolean;
    messages: Message[];
};

// @public
export interface MessageThreadStrings {
    editBoxCancelButton: string;
    editBoxPlaceholderText: string;
    editBoxSubmitButton: string;
    editBoxTextLimit: string;
    editedTag: string;
    editMessage: string;
    friday: string;
    liveAuthorIntro: string;
    monday: string;
    newMessagesIndicator: string;
    noDisplayNameSub: string;
    participantJoined: string;
    participantLeft: string;
    removeMessage: string;
    saturday: string;
    sunday: string;
    thursday: string;
    tuesday: string;
    wednesday: string;
    yesterday: string;
}

// @public
export interface MessageThreadStyles extends BaseCustomStyles {
    chatContainer?: ComponentSlotStyle;
    chatItemMessageContainer?: ComponentSlotStyle;
    chatMessageContainer?: ComponentSlotStyle;
    loadPreviousMessagesButtonContainer?: IStyle;
    messageStatusContainer?: (mine: boolean) => IStyle;
    myChatItemMessageContainer?: ComponentSlotStyle;
    myChatMessageContainer?: ComponentSlotStyle;
    newMessageButtonContainer?: IStyle;
    systemMessageContainer?: ComponentSlotStyle;
}

// @public
export const MicrophoneButton: (props: MicrophoneButtonProps) => JSX.Element;

// @public
export interface MicrophoneButtonContextualMenuStyles extends IContextualMenuStyles {
    menuItemStyles?: IContextualMenuItemStyles;
}

// @public
export interface MicrophoneButtonProps extends ControlBarButtonProps {
    enableDeviceSelectionMenu?: boolean;
    microphones?: OptionsDevice[];
    onSelectMicrophone?: (device: OptionsDevice) => Promise<void>;
    onSelectSpeaker?: (device: OptionsDevice) => Promise<void>;
    onToggleMicrophone?: () => Promise<void>;
    selectedMicrophone?: OptionsDevice;
    selectedSpeaker?: OptionsDevice;
    speakers?: OptionsDevice[];
    strings?: Partial<MicrophoneButtonStrings>;
    styles?: Partial<MicrophoneButtonStyles>;
}

// @public
export type MicrophoneButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    disabled: boolean;
    checked: boolean;
    microphones: AudioDeviceInfo[];
    speakers: AudioDeviceInfo[];
    selectedMicrophone?: AudioDeviceInfo;
    selectedSpeaker?: AudioDeviceInfo;
};

// @public
export interface MicrophoneButtonStrings {
    microphoneMenuTitle?: string;
    microphoneMenuTooltip?: string;
    offLabel: string;
    onLabel: string;
    speakerMenuTitle?: string;
    speakerMenuTooltip?: string;
    tooltipDisabledContent?: string;
    tooltipOffContent?: string;
    tooltipOnContent?: string;
}

// @public
export interface MicrophoneButtonStyles extends ControlBarButtonStyles {
    menuStyles?: Partial<MicrophoneButtonContextualMenuStyles>;
}

// @public
export type NetworkDiagnosticChangedEvent = NetworkDiagnosticChangedEventArgs & {
    type: 'network';
};

// @public
export interface NetworkDiagnosticsState {
    // (undocumented)
    latest: LatestNetworkDiagnostics;
}

// @beta
export interface ObservableFileUpload extends FileUploadEventEmitter {
    file: File;
    id: string;
}

// @public
export type OnRenderAvatarCallback = (
userId?: string, options?: CustomAvatarOptions,
defaultOnRender?: (props: CustomAvatarOptions) => JSX.Element) => JSX.Element;

// @public
export interface OptionsDevice {
    id: string;
    name: string;
}

// @public
export interface ParticipantAddedSystemMessage extends SystemMessageCommon {
    // (undocumented)
    participants: CommunicationParticipant[];
    // (undocumented)
    systemMessageType: 'participantAdded';
}

// @public
export const ParticipantItem: (props: ParticipantItemProps) => JSX.Element;

// @public
export interface ParticipantItemProps {
    displayName: string;
    me?: boolean;
    menuItems?: IContextualMenuItem[];
    onRenderAvatar?: OnRenderAvatarCallback;
    onRenderIcon?: (props?: ParticipantItemProps) => JSX.Element | null;
    presence?: PersonaPresence;
    strings?: Partial<ParticipantItemStrings>;
    styles?: ParticipantItemStyles;
    userId?: string;
}

// @public
export interface ParticipantItemStrings {
    isMeText: string;
    menuTitle: string;
    mutedIconLabel: string;
    removeButtonLabel: string;
    sharingIconLabel: string;
}

// @public
export interface ParticipantItemStyles extends BaseCustomStyles {
    avatar?: IStyle;
    iconContainer?: IStyle;
    me?: IStyle;
    menu?: IStyle;
}

// @public
export const ParticipantList: (props: ParticipantListProps) => JSX.Element;

// @public
export interface ParticipantListItemStyles extends ParticipantItemStyles {
    participantSubMenuItemsStyles?: IContextualMenuItemStyles;
}

// @public
export type ParticipantListParticipant = CommunicationParticipant & {
    isRemovable: boolean;
};

// @public
export type ParticipantListProps = {
    participants: ParticipantListParticipant[];
    myUserId?: string;
    excludeMe?: boolean;
    onRenderParticipant?: (participant: ParticipantListParticipant) => JSX.Element | null;
    onRenderAvatar?: OnRenderAvatarCallback;
    onRemoveParticipant?: (userId: string) => void;
    onFetchParticipantMenuItems?: ParticipantMenuItemsCallback;
    styles?: ParticipantListStyles;
};

// @public
export type ParticipantListSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    participants: CallParticipantListParticipant[];
    myUserId: string;
};

// @public
export interface ParticipantListStyles extends BaseCustomStyles {
    participantItemStyles?: ParticipantListItemStyles;
}

// @public
export type ParticipantMenuItemsCallback = (participantUserId: string, userId?: string, defaultMenuItems?: IContextualMenuItem[]) => IContextualMenuItem[];

// @public
export interface ParticipantRemovedSystemMessage extends SystemMessageCommon {
    // (undocumented)
    participants: CommunicationParticipant[];
    // (undocumented)
    systemMessageType: 'participantRemoved';
}

// @public
export type ParticipantsAddedListener = (event: {
    participantsAdded: ChatParticipant[];
    addedBy: ChatParticipant;
}) => void;

// @public
export const ParticipantsButton: (props: ParticipantsButtonProps) => JSX.Element;

// @public
export interface ParticipantsButtonContextualMenuStyles extends IContextualMenuStyles {
    menuItemStyles?: IContextualMenuItemStyles;
    participantListStyles?: ParticipantListStyles;
}

// @public
export interface ParticipantsButtonProps extends ControlBarButtonProps {
    callInvitationURL?: string;
    excludeMe?: boolean;
    myUserId?: string;
    onFetchParticipantMenuItems?: ParticipantMenuItemsCallback;
    onMuteAll?: () => void;
    onRemoveParticipant?: (userId: string) => void;
    onRenderAvatar?: OnRenderAvatarCallback;
    onRenderParticipant?: (participant: CommunicationParticipant) => JSX.Element | null;
    onRenderParticipantList?: (props: ParticipantListProps) => JSX.Element | null;
    participants: ParticipantListParticipant[];
    strings?: Partial<ParticipantsButtonStrings>;
    styles?: ParticipantsButtonStyles;
}

// @public
export type ParticipantsButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    participants: CallParticipantListParticipant[];
    myUserId: string;
};

// @public
export interface ParticipantsButtonStrings {
    copyInviteLinkButtonLabel: string;
    label: string;
    menuHeader: string;
    muteAllButtonLabel: string;
    participantsListButtonLabel: string;
    tooltipContent?: string;
}

// @public
export interface ParticipantsButtonStyles extends ControlBarButtonStyles {
    menuStyles?: Partial<ParticipantsButtonContextualMenuStyles>;
}

// @public
export type ParticipantsJoinedListener = (event: {
    joined: RemoteParticipant[];
}) => void;

// @public
export type ParticipantsLeftListener = (event: {
    removed: RemoteParticipant[];
}) => void;

// @public
export type ParticipantsRemovedListener = (event: {
    participantsRemoved: ChatParticipant[];
    removedBy: ChatParticipant;
}) => void;

// @public
export interface RecordingCallFeature {
    isRecordingActive: boolean;
}

// @public
export interface RemoteParticipantState {
    callEndReason?: CallEndReason;
    displayName?: string;
    identifier: CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind;
    isMuted: boolean;
    isSpeaking: boolean;
    state: RemoteParticipantState_2;
    videoStreams: {
        [key: number]: RemoteVideoStreamState;
    };
}

// @public
export interface RemoteVideoStreamState {
    id: number;
    isAvailable: boolean;
    mediaStreamType: MediaStreamType;
    view?: VideoStreamRendererViewState;
}

// @public
export const ScreenShareButton: (props: ScreenShareButtonProps) => JSX.Element;

// @public
export interface ScreenShareButtonProps extends ControlBarButtonProps {
    onToggleScreenShare?: () => Promise<void>;
    strings?: Partial<ScreenShareButtonStrings>;
}

// @public
export type ScreenShareButtonSelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    checked?: boolean;
};

// @public
export interface ScreenShareButtonStrings {
    offLabel: string;
    onLabel: string;
    tooltipDisabledContent?: string;
    tooltipOffContent?: string;
    tooltipOnContent?: string;
}

// @public
export type Selector = (state: ClientState, props: any) => any;

// @public
export const SendBox: (props: SendBoxProps) => JSX.Element;

// @public
export interface SendBoxProps {
    autoFocus?: 'sendBoxTextField' | false;
    disabled?: boolean;
    onRenderIcon?: (isHover: boolean) => JSX.Element;
    onRenderSystemMessage?: (systemMessage: string | undefined) => React_2.ReactElement;
    onSendMessage?: (content: string) => Promise<void>;
    onTyping?: () => Promise<void>;
    strings?: Partial<SendBoxStrings>;
    styles?: SendBoxStylesProps;
    supportNewline?: boolean;
    systemMessage?: string;
}

// @public
export type SendBoxSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    displayName: string;
    userId: string;
};

// @public
export interface SendBoxStrings {
    placeholderText: string;
    sendButtonAriaLabel: string;
    textTooLong: string;
}

// @public
export interface SendBoxStylesProps extends BaseCustomStyles {
    sendMessageIcon?: IStyle;
    sendMessageIconContainer?: IStyle;
    systemMessage?: IStyle;
    textField?: IStyle;
    textFieldContainer?: IStyle;
}

// @public
export interface StatefulCallClient extends CallClient {
    createView(callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState, options?: CreateViewOptions): Promise<void>;
    disposeView(callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState): void;
    getState(): CallClientState;
    offStateChange(handler: (state: CallClientState) => void): void;
    onStateChange(handler: (state: CallClientState) => void): void;
}

// @public
export type StatefulCallClientArgs = {
    userId: CommunicationUserIdentifier;
};

// @public
export type StatefulCallClientOptions = {
    callClientOptions: CallClientOptions;
    maxStateChangeListeners?: number;
};

// @public
export interface StatefulChatClient extends ChatClient {
    getState(): ChatClientState;
    offStateChange(handler: (state: ChatClientState) => void): void;
    onStateChange(handler: (state: ChatClientState) => void): void;
}

// @public
export type StatefulChatClientArgs = {
    userId: CommunicationUserIdentifier;
    displayName: string;
    endpoint: string;
    credential: CommunicationTokenCredential;
};

// @public
export type StatefulChatClientOptions = {
    chatClientOptions: ChatClientOptions;
    maxStateChangeListeners?: number;
};

// @public
export interface StatefulDeviceManager extends DeviceManager {
    selectCamera: (VideoDeviceInfo: any) => void;
}

// @public
export const StreamMedia: (props: StreamMediaProps) => JSX.Element;

// @public
export interface StreamMediaProps {
    isMirrored?: boolean;
    styles?: BaseCustomStyles;
    videoStreamElement: HTMLElement | null;
}

// @public
export type SystemMessage = ParticipantAddedSystemMessage | ParticipantRemovedSystemMessage | TopicUpdatedSystemMessage | ContentSystemMessage;

// @public
export interface SystemMessageCommon extends MessageCommon {
    // (undocumented)
    iconName: string;
    // (undocumented)
    messageType: 'system';
}

// @public
export const toFlatCommunicationIdentifier: (identifier: CommunicationIdentifier) => string;

// @public
export type TopicChangedListener = (event: {
    topic: string;
}) => void;

// @public
export interface TopicUpdatedSystemMessage extends SystemMessageCommon {
    // (undocumented)
    systemMessageType: 'topicUpdated';
    // (undocumented)
    topic: string;
}

// @public
export interface TranscriptionCallFeature {
    isTranscriptionActive: boolean;
}

// @public
export const TypingIndicator: (props: TypingIndicatorProps) => JSX.Element;

// @public
export interface TypingIndicatorProps {
    onRenderUser?: (users: CommunicationParticipant) => JSX.Element;
    strings?: Partial<TypingIndicatorStrings>;
    styles?: TypingIndicatorStylesProps;
    typingUsers: CommunicationParticipant[];
}

// @public
export type TypingIndicatorSelector = (state: ChatClientState, props: ChatBaseSelectorProps) => {
    typingUsers: CommunicationParticipant[];
};

// @public
export interface TypingIndicatorStrings {
    delimiter: string;
    multipleUsers: string;
    multipleUsersAbbreviateMany: string;
    multipleUsersAbbreviateOne: string;
    singleUser: string;
}

// @public
export interface TypingIndicatorStylesProps extends BaseCustomStyles {
    typingString?: IStyle;
    typingUserDisplayName?: IStyle;
}

// @beta
export type UploadCompleteListener = (id: string, metadata: FileMetadata) => void;

// @beta
export type UploadFailedListener = (id: string, message: string) => void;

// @beta
export type UploadProgressListener = (id: string, value: number) => void;

// @public
export const useCall: () => Call | undefined;

// @public
export const useCallAgent: () => CallAgent | undefined;

// @public
export const useCallClient: () => StatefulCallClient;

// @public
export const useChatClient: () => StatefulChatClient;

// @public
export const useChatThreadClient: () => ChatThreadClient;

// @public
export const useDeviceManager: () => StatefulDeviceManager | undefined;

// @public
export const usePropsFor: <Component extends (props: any) => JSX.Element>(component: Component, type?: "chat" | "calling" | undefined) => ComponentProps<Component>;

// @public
export const useSelector: <ParamT extends Selector | undefined>(selector: ParamT, selectorProps?: (ParamT extends Selector ? Parameters<ParamT>[1] : undefined) | undefined, type?: "chat" | "calling" | undefined) => ParamT extends Selector ? ReturnType<ParamT> : undefined;

// @public
export const useTheme: () => Theme;

// @public
export const VideoGallery: (props: VideoGalleryProps) => JSX.Element;

// @public
export type VideoGalleryLocalParticipant = VideoGalleryParticipant;

// @public
export type VideoGalleryParticipant = {
    userId: string;
    isMuted?: boolean;
    displayName?: string;
    videoStream?: VideoGalleryStream;
    isScreenSharingOn?: boolean;
};

// @public
export interface VideoGalleryProps {
    dominantSpeakers?: string[];
    layout?: 'default' | 'floatingLocalVideo';
    localParticipant: VideoGalleryLocalParticipant;
    // Warning: (ae-incompatible-release-tags) The symbol "localVideoCameraCycleButtonProps" is marked as @public, but its signature references "LocalVideoCameraCycleButtonProps" which is marked as @beta
    localVideoCameraCycleButtonProps?: LocalVideoCameraCycleButtonProps;
    localVideoViewOptions?: VideoStreamOptions;
    maxRemoteVideoStreams?: number;
    onCreateLocalStreamView?: (options?: VideoStreamOptions) => Promise<void>;
    onCreateRemoteStreamView?: (userId: string, options?: VideoStreamOptions) => Promise<void>;
    onDisposeLocalStreamView?: () => void;
    onDisposeRemoteStreamView?: (userId: string) => Promise<void>;
    onRenderAvatar?: OnRenderAvatarCallback;
    onRenderLocalVideoTile?: (localParticipant: VideoGalleryLocalParticipant) => JSX.Element;
    onRenderRemoteVideoTile?: (remoteParticipant: VideoGalleryRemoteParticipant) => JSX.Element;
    remoteParticipants?: VideoGalleryRemoteParticipant[];
    remoteVideoViewOptions?: VideoStreamOptions;
    showCamerSwitcherInLocalPreview?: boolean;
    showMuteIndicator?: boolean;
    strings?: Partial<VideoGalleryStrings>;
    styles?: VideoGalleryStyles;
}

// @public
export interface VideoGalleryRemoteParticipant extends VideoGalleryParticipant {
    isSpeaking?: boolean;
    screenShareStream?: VideoGalleryStream;
}

// @public
export type VideoGallerySelector = (state: CallClientState, props: CallingBaseSelectorProps) => {
    screenShareParticipant: VideoGalleryRemoteParticipant | undefined;
    localParticipant: VideoGalleryLocalParticipant;
    remoteParticipants: VideoGalleryRemoteParticipant[];
    dominantSpeakers?: string[];
};

// @public
export interface VideoGalleryStream {
    id?: number;
    isAvailable?: boolean;
    isMirrored?: boolean;
    renderElement?: HTMLElement;
}

// @public
export interface VideoGalleryStrings {
    localVideoCameraSwitcherLabel: string;
    localVideoLabel: string;
    screenIsBeingSharedMessage: string;
    screenShareLoadingMessage: string;
}

// @public
export interface VideoGalleryStyles extends BaseCustomStyles {
    gridLayout?: GridLayoutStyles;
    horizontalGallery?: HorizontalGalleryStyles;
    localVideo?: IStyle;
}

// @public
export interface VideoStreamOptions {
    isMirrored?: boolean;
    scalingMode?: 'Stretch' | 'Crop' | 'Fit';
}

// @public
export interface VideoStreamRendererViewState {
    isMirrored: boolean;
    scalingMode: ScalingMode;
    target: HTMLElement;
}

// @public
export const VideoTile: (props: VideoTileProps) => JSX.Element;

// @public
export interface VideoTileProps {
    children?: React_2.ReactNode;
    displayName?: string;
    initialsName?: string;
    isMirrored?: boolean;
    isMuted?: boolean;
    isSpeaking?: boolean;
    noVideoAvailableAriaLabel?: string;
    onRenderPlaceholder?: OnRenderAvatarCallback;
    personaMaxSize?: number;
    personaMinSize?: number;
    renderElement?: JSX.Element | null;
    showLabel?: boolean;
    showMuteIndicator?: boolean;
    styles?: VideoTileStylesProps;
    userId?: string;
}

// @public
export interface VideoTileStylesProps extends BaseCustomStyles {
    displayNameContainer?: IStyle;
    overlayContainer?: IStyle;
    videoContainer?: IStyle;
}

```
