{"version":3,"file":"SourceMapper.js","sourceRoot":"","sources":["../../src/collector/SourceMapper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport { SourceMapConsumer, RawSourceMap, MappingItem, Position } from 'source-map';\r\nimport { IExtractorMessageOptions } from '../api/ExtractorMessage';\r\nimport { FileSystem, InternalError, JsonFile, NewlineKind } from '@rushstack/node-core-library';\r\n\r\ninterface ISourceMap {\r\n  sourceMapConsumer: SourceMapConsumer;\r\n\r\n  // SourceMapConsumer.originalPositionFor() is useless because the mapping contains numerous gaps,\r\n  // and the API provides no way to find the nearest match.  So instead we extract all the mapping items\r\n  // and search them using SourceMapper._findNearestMappingItem().\r\n  mappingItems: MappingItem[];\r\n}\r\n\r\ninterface IOriginalFileInfo {\r\n  // Whether the .ts file exists\r\n  fileExists: boolean;\r\n\r\n  // This is used to check whether the guessed position is out of bounds.\r\n  // Since column/line numbers are 1-based, the 0th item in this array is unused.\r\n  maxColumnForLine: number[];\r\n}\r\n\r\nexport class SourceMapper {\r\n  // Map from .d.ts file path --> ISourceMap if a source map was found, or null if not found\r\n  private _sourceMapByFilePath: Map<string, ISourceMap | null> = new Map<string, ISourceMap | null>();\r\n\r\n  // Cache the FileSystem.exists() result for mapped .ts files\r\n  private _originalFileInfoByPath: Map<string, IOriginalFileInfo> = new Map<string, IOriginalFileInfo>();\r\n\r\n  /**\r\n   * If the `IExtractorMessageOptions` refers to a `.d.ts` file, look for a `.d.ts.map` and\r\n   * if possible update the coordinates to refer to the original `.ts` file.\r\n   */\r\n  public updateExtractorMessageOptions(options: IExtractorMessageOptions): void {\r\n    if (!options.sourceFilePath) {\r\n      return;\r\n    }\r\n\r\n    if (!FileSystem.exists(options.sourceFilePath)) {\r\n      // Sanity check\r\n      throw new InternalError('The referenced path was not found: ' + options.sourceFilePath);\r\n    }\r\n\r\n    let sourceMap: ISourceMap | null | undefined = this._sourceMapByFilePath.get(options.sourceFilePath);\r\n\r\n    if (sourceMap === undefined) {\r\n      // Normalize the path and redo the lookup\r\n      const normalizedPath: string = FileSystem.getRealPath(options.sourceFilePath);\r\n\r\n      sourceMap = this._sourceMapByFilePath.get(normalizedPath);\r\n      if (sourceMap !== undefined) {\r\n        // Copy the result from the normalized to the non-normalized key\r\n        this._sourceMapByFilePath.set(options.sourceFilePath, sourceMap);\r\n      } else {\r\n        // Given \"folder/file.d.ts\", check for a corresponding \"folder/file.d.ts.map\"\r\n        const sourceMapPath: string = normalizedPath + '.map';\r\n        if (FileSystem.exists(sourceMapPath)) {\r\n          // Load up the source map\r\n          const rawSourceMap: RawSourceMap = JsonFile.load(sourceMapPath) as RawSourceMap;\r\n\r\n          const sourceMapConsumer: SourceMapConsumer = new SourceMapConsumer(rawSourceMap);\r\n          const mappingItems: MappingItem[] = [];\r\n\r\n          // Extract the list of mapping items\r\n          sourceMapConsumer.eachMapping(\r\n            (mappingItem: MappingItem) => {\r\n              mappingItems.push({\r\n                ...mappingItem,\r\n                // The \"source-map\" package inexplicably uses 1-based line numbers but 0-based column numbers.\r\n                // Fix that up proactively so we don't have to deal with it later.\r\n                generatedColumn: mappingItem.generatedColumn + 1,\r\n                originalColumn: mappingItem.originalColumn + 1\r\n              });\r\n            },\r\n            this,\r\n            SourceMapConsumer.GENERATED_ORDER\r\n          );\r\n\r\n          sourceMap = { sourceMapConsumer, mappingItems };\r\n        } else {\r\n          // No source map for this filename\r\n          sourceMap = null;\r\n        }\r\n\r\n        this._sourceMapByFilePath.set(normalizedPath, sourceMap);\r\n        if (options.sourceFilePath !== normalizedPath) {\r\n          // Add both keys to the map\r\n          this._sourceMapByFilePath.set(options.sourceFilePath, sourceMap);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (sourceMap === null) {\r\n      // No source map for this filename\r\n      return;\r\n    }\r\n\r\n    // Make sure sourceFileLine and sourceFileColumn are defined\r\n    if (options.sourceFileLine === undefined) {\r\n      options.sourceFileLine = 1;\r\n    }\r\n    if (options.sourceFileColumn === undefined) {\r\n      options.sourceFileColumn = 1;\r\n    }\r\n\r\n    const nearestMappingItem: MappingItem | undefined = SourceMapper._findNearestMappingItem(\r\n      sourceMap.mappingItems,\r\n      {\r\n        line: options.sourceFileLine,\r\n        column: options.sourceFileColumn\r\n      }\r\n    );\r\n\r\n    if (nearestMappingItem === undefined) {\r\n      // No mapping for this location\r\n      return;\r\n    }\r\n\r\n    const mappedFilePath: string = path.resolve(\r\n      path.dirname(options.sourceFilePath),\r\n      nearestMappingItem.source\r\n    );\r\n\r\n    // Does the mapped filename exist?  Use a cache to remember the answer.\r\n    let originalFileInfo: IOriginalFileInfo | undefined = this._originalFileInfoByPath.get(mappedFilePath);\r\n    if (originalFileInfo === undefined) {\r\n      originalFileInfo = {\r\n        fileExists: FileSystem.exists(mappedFilePath),\r\n        maxColumnForLine: []\r\n      };\r\n\r\n      if (originalFileInfo.fileExists) {\r\n        // Read the file and measure the length of each line\r\n        originalFileInfo.maxColumnForLine = FileSystem.readFile(mappedFilePath, {\r\n          convertLineEndings: NewlineKind.Lf\r\n        })\r\n          .split('\\n')\r\n          .map((x) => x.length + 1); // +1 since columns are 1-based\r\n        originalFileInfo.maxColumnForLine.unshift(0); // Extra item since lines are 1-based\r\n      }\r\n\r\n      this._originalFileInfoByPath.set(mappedFilePath, originalFileInfo);\r\n    }\r\n\r\n    if (!originalFileInfo.fileExists) {\r\n      // Don't translate coordinates to a file that doesn't exist\r\n      return;\r\n    }\r\n\r\n    // The nearestMappingItem anchor may be above/left of the real position, due to gaps in the mapping.  Calculate\r\n    // the delta and apply it to the original position.\r\n    const guessedPosition: Position = {\r\n      line: nearestMappingItem.originalLine + options.sourceFileLine - nearestMappingItem.generatedLine,\r\n      column:\r\n        nearestMappingItem.originalColumn + options.sourceFileColumn - nearestMappingItem.generatedColumn\r\n    };\r\n\r\n    // Verify that the result is not out of bounds, in cause our heuristic failed\r\n    if (\r\n      guessedPosition.line >= 1 &&\r\n      guessedPosition.line < originalFileInfo.maxColumnForLine.length &&\r\n      guessedPosition.column >= 1 &&\r\n      guessedPosition.column <= originalFileInfo.maxColumnForLine[guessedPosition.line]\r\n    ) {\r\n      options.sourceFilePath = mappedFilePath;\r\n      options.sourceFileLine = guessedPosition.line;\r\n      options.sourceFileColumn = guessedPosition.column;\r\n    } else {\r\n      // The guessed position was out of bounds, so use the nearestMappingItem position instead.\r\n      options.sourceFilePath = mappedFilePath;\r\n      options.sourceFileLine = nearestMappingItem.originalLine;\r\n      options.sourceFileColumn = nearestMappingItem.originalColumn;\r\n    }\r\n  }\r\n\r\n  // The `mappingItems` array is sorted by generatedLine/generatedColumn (GENERATED_ORDER).\r\n  // The _findNearestMappingItem() lookup is a simple binary search that returns the previous item\r\n  // if there is no exact match.\r\n  private static _findNearestMappingItem(\r\n    mappingItems: MappingItem[],\r\n    position: Position\r\n  ): MappingItem | undefined {\r\n    if (mappingItems.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    let startIndex: number = 0;\r\n    let endIndex: number = mappingItems.length - 1;\r\n\r\n    while (startIndex <= endIndex) {\r\n      const middleIndex: number = startIndex + Math.floor((endIndex - startIndex) / 2);\r\n\r\n      const diff: number = SourceMapper._compareMappingItem(mappingItems[middleIndex], position);\r\n\r\n      if (diff < 0) {\r\n        startIndex = middleIndex + 1;\r\n      } else if (diff > 0) {\r\n        endIndex = middleIndex - 1;\r\n      } else {\r\n        // Exact match\r\n        return mappingItems[middleIndex];\r\n      }\r\n    }\r\n\r\n    // If we didn't find an exact match, then endIndex < startIndex.\r\n    // Take endIndex because it's the smaller value.\r\n    return mappingItems[endIndex];\r\n  }\r\n\r\n  private static _compareMappingItem(mappingItem: MappingItem, position: Position): number {\r\n    const diff: number = mappingItem.generatedLine - position.line;\r\n    if (diff !== 0) {\r\n      return diff;\r\n    }\r\n    return mappingItem.generatedColumn - position.column;\r\n  }\r\n}\r\n"]}