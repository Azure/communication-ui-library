{"version":3,"file":"Collector.js","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\nimport { PackageJsonLookup, Sort, InternalError } from '@rushstack/node-core-library';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\n\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\n\r\nimport { CollectorEntity } from './CollectorEntity';\r\nimport { AstSymbolTable, AstEntity } from '../analyzer/AstSymbolTable';\r\nimport { AstModule, AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport { AstImport } from '../analyzer/AstImport';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { WorkingPackage } from './WorkingPackage';\r\nimport { PackageDocComment } from '../aedoc/PackageDocComment';\r\nimport { DeclarationMetadata, InternalDeclarationMetadata } from './DeclarationMetadata';\r\nimport { ApiItemMetadata, IApiItemMetadataOptions } from './ApiItemMetadata';\r\nimport { SymbolMetadata } from './SymbolMetadata';\r\nimport { TypeScriptInternals, IGlobalVariableAnalyzer } from '../analyzer/TypeScriptInternals';\r\nimport { MessageRouter } from './MessageRouter';\r\nimport { AstReferenceResolver } from '../analyzer/AstReferenceResolver';\r\nimport { ExtractorConfig } from '../api/ExtractorConfig';\r\n\r\nconst toAlphaNumericCamelCase = (str: string): string =>\r\n  str.replace(/(\\W+[a-z])/g, (g) => g[g.length - 1].toUpperCase()).replace(/\\W/g, '');\r\n\r\n/**\r\n * Options for Collector constructor.\r\n */\r\nexport interface ICollectorOptions {\r\n  /**\r\n   * Configuration for the TypeScript compiler.  The most important options to set are:\r\n   *\r\n   * - target: ts.ScriptTarget.ES5\r\n   * - module: ts.ModuleKind.CommonJS\r\n   * - moduleResolution: ts.ModuleResolutionKind.NodeJs\r\n   * - rootDir: inputFolder\r\n   */\r\n  program: ts.Program;\r\n\r\n  messageRouter: MessageRouter;\r\n\r\n  extractorConfig: ExtractorConfig;\r\n}\r\n\r\n/**\r\n * The `Collector` manages the overall data set that is used by `ApiModelGenerator`,\r\n * `DtsRollupGenerator`, and `ApiReportGenerator`.  Starting from the working package's entry point,\r\n * the `Collector` collects all exported symbols, determines how to import any symbols they reference,\r\n * assigns unique names, and sorts everything into a normalized alphabetical ordering.\r\n */\r\nexport class Collector {\r\n  public readonly program: ts.Program;\r\n  public readonly typeChecker: ts.TypeChecker;\r\n  public readonly globalVariableAnalyzer: IGlobalVariableAnalyzer;\r\n  public readonly astSymbolTable: AstSymbolTable;\r\n  public readonly astReferenceResolver: AstReferenceResolver;\r\n\r\n  public readonly packageJsonLookup: PackageJsonLookup;\r\n  public readonly messageRouter: MessageRouter;\r\n\r\n  public readonly workingPackage: WorkingPackage;\r\n\r\n  public readonly extractorConfig: ExtractorConfig;\r\n\r\n  /**\r\n   * The `ExtractorConfig.bundledPackages` names in a set.\r\n   */\r\n  public readonly bundledPackageNames: ReadonlySet<string>;\r\n\r\n  private readonly _program: ts.Program;\r\n\r\n  private readonly _tsdocParser: tsdoc.TSDocParser;\r\n\r\n  private _astEntryPoint: AstModule | undefined;\r\n\r\n  private readonly _entities: CollectorEntity[] = [];\r\n  private readonly _entitiesByAstEntity: Map<AstEntity, CollectorEntity> = new Map<\r\n    AstEntity,\r\n    CollectorEntity\r\n  >();\r\n\r\n  private readonly _starExportedExternalModulePaths: string[] = [];\r\n\r\n  private readonly _dtsTypeReferenceDirectives: Set<string> = new Set<string>();\r\n  private readonly _dtsLibReferenceDirectives: Set<string> = new Set<string>();\r\n\r\n  // Used by getOverloadIndex()\r\n  private readonly _cachedOverloadIndexesByDeclaration: Map<AstDeclaration, number>;\r\n\r\n  public constructor(options: ICollectorOptions) {\r\n    this.packageJsonLookup = new PackageJsonLookup();\r\n\r\n    this._program = options.program;\r\n    this.extractorConfig = options.extractorConfig;\r\n\r\n    const entryPointSourceFile: ts.SourceFile | undefined = options.program.getSourceFile(\r\n      this.extractorConfig.mainEntryPointFilePath\r\n    );\r\n\r\n    if (!entryPointSourceFile) {\r\n      throw new Error('Unable to load file: ' + this.extractorConfig.mainEntryPointFilePath);\r\n    }\r\n\r\n    if (!this.extractorConfig.packageFolder || !this.extractorConfig.packageJson) {\r\n      // TODO: We should be able to analyze projects that don't have any package.json.\r\n      // The ExtractorConfig class is already designed to allow this.\r\n      throw new Error('Unable to find a package.json file for the project being analyzed');\r\n    }\r\n\r\n    this.workingPackage = new WorkingPackage({\r\n      packageFolder: this.extractorConfig.packageFolder,\r\n      packageJson: this.extractorConfig.packageJson,\r\n      entryPointSourceFile\r\n    });\r\n\r\n    this.messageRouter = options.messageRouter;\r\n\r\n    this.program = options.program;\r\n    this.typeChecker = options.program.getTypeChecker();\r\n    this.globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(this.program);\r\n\r\n    this._tsdocParser = new tsdoc.TSDocParser(this.extractorConfig.tsdocConfiguration);\r\n\r\n    this.bundledPackageNames = new Set<string>(this.extractorConfig.bundledPackages);\r\n\r\n    this.astSymbolTable = new AstSymbolTable(\r\n      this.program,\r\n      this.typeChecker,\r\n      this.packageJsonLookup,\r\n      this.bundledPackageNames,\r\n      this.messageRouter\r\n    );\r\n    this.astReferenceResolver = new AstReferenceResolver(this);\r\n\r\n    this._cachedOverloadIndexesByDeclaration = new Map<AstDeclaration, number>();\r\n  }\r\n\r\n  /**\r\n   * Returns a list of names (e.g. \"example-library\") that should appear in a reference like this:\r\n   *\r\n   * ```\r\n   * /// <reference types=\"example-library\" />\r\n   * ```\r\n   */\r\n  public get dtsTypeReferenceDirectives(): ReadonlySet<string> {\r\n    return this._dtsTypeReferenceDirectives;\r\n  }\r\n\r\n  /**\r\n   * A list of names (e.g. \"runtime-library\") that should appear in a reference like this:\r\n   *\r\n   * ```\r\n   * /// <reference lib=\"runtime-library\" />\r\n   * ```\r\n   */\r\n  public get dtsLibReferenceDirectives(): ReadonlySet<string> {\r\n    return this._dtsLibReferenceDirectives;\r\n  }\r\n\r\n  public get entities(): ReadonlyArray<CollectorEntity> {\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * A list of module specifiers (e.g. `\"@rushstack/node-core-library/lib/FileSystem\"`) that should be emitted\r\n   * as star exports (e.g. `export * from \"@rushstack/node-core-library/lib/FileSystem\"`).\r\n   */\r\n  public get starExportedExternalModulePaths(): ReadonlyArray<string> {\r\n    return this._starExportedExternalModulePaths;\r\n  }\r\n\r\n  /**\r\n   * Perform the analysis.\r\n   */\r\n  public analyze(): void {\r\n    if (this._astEntryPoint) {\r\n      throw new Error('DtsRollupGenerator.analyze() was already called');\r\n    }\r\n\r\n    // This runs a full type analysis, and then augments the Abstract Syntax Tree (i.e. declarations)\r\n    // with semantic information (i.e. symbols).  The \"diagnostics\" are a subset of the everyday\r\n    // compile errors that would result from a full compilation.\r\n    for (const diagnostic of this._program.getSemanticDiagnostics()) {\r\n      this.messageRouter.addCompilerDiagnostic(diagnostic);\r\n    }\r\n\r\n    if (this.messageRouter.showDiagnostics) {\r\n      this.messageRouter.logDiagnosticHeader('Root filenames');\r\n      for (const fileName of this.program.getRootFileNames()) {\r\n        this.messageRouter.logDiagnostic(fileName);\r\n      }\r\n      this.messageRouter.logDiagnosticFooter();\r\n\r\n      this.messageRouter.logDiagnosticHeader('Files analyzed by compiler');\r\n      for (const sourceFile of this.program.getSourceFiles()) {\r\n        this.messageRouter.logDiagnostic(sourceFile.fileName);\r\n      }\r\n      this.messageRouter.logDiagnosticFooter();\r\n    }\r\n\r\n    // Build the entry point\r\n    const entryPointSourceFile: ts.SourceFile = this.workingPackage.entryPointSourceFile;\r\n\r\n    const astEntryPoint: AstModule =\r\n      this.astSymbolTable.fetchAstModuleFromWorkingPackage(entryPointSourceFile);\r\n    this._astEntryPoint = astEntryPoint;\r\n\r\n    const packageDocCommentTextRange: ts.TextRange | undefined = PackageDocComment.tryFindInSourceFile(\r\n      entryPointSourceFile,\r\n      this\r\n    );\r\n\r\n    if (packageDocCommentTextRange) {\r\n      const range: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\r\n        entryPointSourceFile.text,\r\n        packageDocCommentTextRange.pos,\r\n        packageDocCommentTextRange.end\r\n      );\r\n\r\n      this.workingPackage.tsdocParserContext = this._tsdocParser.parseRange(range);\r\n\r\n      this.messageRouter.addTsdocMessages(this.workingPackage.tsdocParserContext, entryPointSourceFile);\r\n\r\n      this.workingPackage.tsdocComment = this.workingPackage.tsdocParserContext!.docComment;\r\n    }\r\n\r\n    const exportedAstEntities: AstEntity[] = [];\r\n\r\n    // Create a CollectorEntity for each top-level export\r\n\r\n    const astModuleExportInfo: AstModuleExportInfo =\r\n      this.astSymbolTable.fetchAstModuleExportInfo(astEntryPoint);\r\n    for (const [exportName, astEntity] of astModuleExportInfo.exportedLocalEntities) {\r\n      this._createCollectorEntity(astEntity, exportName);\r\n\r\n      exportedAstEntities.push(astEntity);\r\n    }\r\n\r\n    // Create a CollectorEntity for each indirectly referenced export.\r\n    // Note that we do this *after* the above loop, so that references to exported AstSymbols\r\n    // are encountered first as exports.\r\n    const alreadySeenAstSymbols: Set<AstSymbol> = new Set<AstSymbol>();\r\n    for (const exportedAstEntity of exportedAstEntities) {\r\n      this._createEntityForIndirectReferences(exportedAstEntity, alreadySeenAstSymbols);\r\n\r\n      if (exportedAstEntity instanceof AstSymbol) {\r\n        this.fetchSymbolMetadata(exportedAstEntity);\r\n      }\r\n    }\r\n\r\n    this._makeUniqueNames();\r\n\r\n    for (const starExportedExternalModule of astModuleExportInfo.starExportedExternalModules) {\r\n      if (starExportedExternalModule.externalModulePath !== undefined) {\r\n        this._starExportedExternalModulePaths.push(starExportedExternalModule.externalModulePath);\r\n      }\r\n    }\r\n\r\n    Sort.sortBy(this._entities, (x) => x.getSortKey());\r\n    Sort.sortSet(this._dtsTypeReferenceDirectives);\r\n    Sort.sortSet(this._dtsLibReferenceDirectives);\r\n    this._starExportedExternalModulePaths.sort();\r\n  }\r\n\r\n  /**\r\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the CollectorEntity that\r\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\r\n   * @remarks\r\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\r\n   */\r\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): CollectorEntity | undefined {\r\n    const astEntity: AstEntity | undefined = this.astSymbolTable.tryGetEntityForNode(identifier);\r\n    if (astEntity) {\r\n      return this._entitiesByAstEntity.get(astEntity);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the associated `CollectorEntity` for the given `astEntity`, if one was created during analysis.\r\n   */\r\n  public tryGetCollectorEntity(astEntity: AstEntity): CollectorEntity | undefined {\r\n    return this._entitiesByAstEntity.get(astEntity);\r\n  }\r\n\r\n  public fetchSymbolMetadata(astSymbol: AstSymbol): SymbolMetadata {\r\n    if (astSymbol.symbolMetadata === undefined) {\r\n      this._fetchSymbolMetadata(astSymbol);\r\n    }\r\n    return astSymbol.symbolMetadata as SymbolMetadata;\r\n  }\r\n\r\n  public fetchDeclarationMetadata(astDeclaration: AstDeclaration): DeclarationMetadata {\r\n    if (astDeclaration.declarationMetadata === undefined) {\r\n      // Fetching the SymbolMetadata always constructs the DeclarationMetadata\r\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\r\n    }\r\n    return astDeclaration.declarationMetadata as DeclarationMetadata;\r\n  }\r\n\r\n  public fetchApiItemMetadata(astDeclaration: AstDeclaration): ApiItemMetadata {\r\n    if (astDeclaration.apiItemMetadata === undefined) {\r\n      // Fetching the SymbolMetadata always constructs the ApiItemMetadata\r\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\r\n    }\r\n    return astDeclaration.apiItemMetadata as ApiItemMetadata;\r\n  }\r\n\r\n  public tryFetchMetadataForAstEntity(astEntity: AstEntity): SymbolMetadata | undefined {\r\n    if (astEntity instanceof AstSymbol) {\r\n      return this.fetchSymbolMetadata(astEntity);\r\n    }\r\n    if (astEntity.astSymbol) {\r\n      // astImport\r\n      return this.fetchSymbolMetadata(astEntity.astSymbol);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  public isAncillaryDeclaration(astDeclaration: AstDeclaration): boolean {\r\n    const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\r\n    return declarationMetadata.isAncillary;\r\n  }\r\n\r\n  public getNonAncillaryDeclarations(astSymbol: AstSymbol): ReadonlyArray<AstDeclaration> {\r\n    const result: AstDeclaration[] = [];\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\r\n      if (!declarationMetadata.isAncillary) {\r\n        result.push(astDeclaration);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Removes the leading underscore, for example: \"_Example\" --> \"example*Example*_\"\r\n   *\r\n   * @remarks\r\n   * This causes internal definitions to sort alphabetically case-insensitive, then case-sensitive, and\r\n   * initially ignoring the underscore prefix, while still deterministically comparing it.\r\n   * The star is used as a delimiter because it is not a legal  identifier character.\r\n   */\r\n  public static getSortKeyIgnoringUnderscore(identifier: string | undefined): string {\r\n    if (!identifier) return '';\r\n\r\n    let parts: string[];\r\n\r\n    if (identifier[0] === '_') {\r\n      const withoutUnderscore: string = identifier.substr(1);\r\n      parts = [withoutUnderscore.toLowerCase(), '*', withoutUnderscore, '*', '_'];\r\n    } else {\r\n      parts = [identifier.toLowerCase(), '*', identifier];\r\n    }\r\n\r\n    return parts.join('');\r\n  }\r\n\r\n  /**\r\n   * For function-like signatures, this returns the TSDoc \"overload index\" which can be used to identify\r\n   * a specific overload.\r\n   */\r\n  public getOverloadIndex(astDeclaration: AstDeclaration): number {\r\n    const allDeclarations: ReadonlyArray<AstDeclaration> = astDeclaration.astSymbol.astDeclarations;\r\n    if (allDeclarations.length === 1) {\r\n      return 1; // trivial case\r\n    }\r\n\r\n    let overloadIndex: number | undefined = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\r\n\r\n    if (overloadIndex === undefined) {\r\n      // TSDoc index selectors are positive integers counting from 1\r\n      let nextIndex: number = 1;\r\n      for (const other of allDeclarations) {\r\n        // Filter out other declarations that are not overloads.  For example, an overloaded function can also\r\n        // be a namespace.\r\n        if (other.declaration.kind === astDeclaration.declaration.kind) {\r\n          this._cachedOverloadIndexesByDeclaration.set(other, nextIndex);\r\n          ++nextIndex;\r\n        }\r\n      }\r\n      overloadIndex = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\r\n    }\r\n\r\n    if (overloadIndex === undefined) {\r\n      // This should never happen\r\n      throw new InternalError('Error calculating overload index for declaration');\r\n    }\r\n\r\n    return overloadIndex;\r\n  }\r\n\r\n  private _createCollectorEntity(astEntity: AstEntity, exportedName: string | undefined): void {\r\n    let entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\r\n\r\n    if (!entity) {\r\n      entity = new CollectorEntity(astEntity);\r\n\r\n      this._entitiesByAstEntity.set(astEntity, entity);\r\n      this._entities.push(entity);\r\n\r\n      if (astEntity instanceof AstSymbol) {\r\n        this._collectReferenceDirectives(astEntity);\r\n      }\r\n    }\r\n\r\n    if (exportedName) {\r\n      entity.addExportName(exportedName);\r\n    }\r\n  }\r\n\r\n  private _createEntityForIndirectReferences(\r\n    astEntity: AstEntity,\r\n    alreadySeenAstEntities: Set<AstEntity>\r\n  ): void {\r\n    if (alreadySeenAstEntities.has(astEntity)) {\r\n      return;\r\n    }\r\n    alreadySeenAstEntities.add(astEntity);\r\n\r\n    if (astEntity instanceof AstSymbol) {\r\n      astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\r\n          if (referencedAstEntity instanceof AstSymbol) {\r\n            // We only create collector entities for root-level symbols.\r\n            // For example, if a symbols is nested inside a namespace, only the root-level namespace\r\n            // get a collector entity\r\n            if (referencedAstEntity.parentAstSymbol === undefined) {\r\n              this._createCollectorEntity(referencedAstEntity, undefined);\r\n            }\r\n          } else {\r\n            this._createCollectorEntity(referencedAstEntity, undefined);\r\n          }\r\n\r\n          this._createEntityForIndirectReferences(referencedAstEntity, alreadySeenAstEntities);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures a unique name for each item in the package typings file.\r\n   */\r\n  private _makeUniqueNames(): void {\r\n    // The following examples illustrate the nameForEmit heuristics:\r\n    //\r\n    // Example 1:\r\n    //   class X { } <--- nameForEmit should be \"A\" to simplify things and reduce possibility of conflicts\r\n    //   export { X as A };\r\n    //\r\n    // Example 2:\r\n    //   class X { } <--- nameForEmit should be \"X\" because choosing A or B would be nondeterministic\r\n    //   export { X as A };\r\n    //   export { X as B };\r\n    //\r\n    // Example 3:\r\n    //   class X { } <--- nameForEmit should be \"X_1\" because Y has a stronger claim to the name\r\n    //   export { X as A };\r\n    //   export { X as B };\r\n    //   class Y { } <--- nameForEmit should be \"X\"\r\n    //   export { Y as X };\r\n\r\n    // Set of names that should NOT be used when generating a unique nameForEmit\r\n    const usedNames: Set<string> = new Set<string>();\r\n\r\n    // First collect the names of explicit package exports, and perform a sanity check.\r\n    for (const entity of this._entities) {\r\n      for (const exportName of entity.exportNames) {\r\n        if (usedNames.has(exportName)) {\r\n          // This should be impossible\r\n          throw new InternalError(`A package cannot have two exports with the name \"${exportName}\"`);\r\n        }\r\n        usedNames.add(exportName);\r\n      }\r\n    }\r\n\r\n    // Ensure that each entity has a unique nameForEmit\r\n    for (const entity of this._entities) {\r\n      // What name would we ideally want to emit it as?\r\n      let idealNameForEmit: string;\r\n\r\n      // If this entity is exported exactly once, then we prefer the exported name\r\n      if (\r\n        entity.singleExportName !== undefined &&\r\n        entity.singleExportName !== ts.InternalSymbolName.Default\r\n      ) {\r\n        idealNameForEmit = entity.singleExportName;\r\n      } else if (entity.astEntity instanceof AstImport) {\r\n        // otherwise use the local name or modulePath\r\n        idealNameForEmit = entity.astEntity.localName || toAlphaNumericCamelCase(entity.astEntity.modulePath);\r\n      } else {\r\n        // otherwise use the local name\r\n        idealNameForEmit = entity.astEntity.localName;\r\n      }\r\n\r\n      if (idealNameForEmit.includes('.')) {\r\n        // For an ImportType with a namespace chain, only the top namespace is imported.\r\n        idealNameForEmit = idealNameForEmit.split('.')[0];\r\n      }\r\n\r\n      // If the idealNameForEmit happens to be the same as one of the exports, then we're safe to use that...\r\n      if (entity.exportNames.has(idealNameForEmit)) {\r\n        // ...except that if it conflicts with a global name, then the global name wins\r\n        if (!this.globalVariableAnalyzer.hasGlobalName(idealNameForEmit)) {\r\n          // ...also avoid \"default\" which can interfere with \"export { default } from 'some-module;'\"\r\n          if (idealNameForEmit !== 'default') {\r\n            entity.nameForEmit = idealNameForEmit;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Generate a unique name based on idealNameForEmit\r\n      let suffix: number = 1;\r\n      let nameForEmit: string = idealNameForEmit;\r\n\r\n      // Choose a name that doesn't conflict with usedNames or a global name\r\n      while (usedNames.has(nameForEmit) || this.globalVariableAnalyzer.hasGlobalName(nameForEmit)) {\r\n        nameForEmit = `${idealNameForEmit}_${++suffix}`;\r\n      }\r\n      entity.nameForEmit = nameForEmit;\r\n      usedNames.add(nameForEmit);\r\n    }\r\n  }\r\n\r\n  private _fetchSymbolMetadata(astSymbol: AstSymbol): void {\r\n    if (astSymbol.symbolMetadata) {\r\n      return;\r\n    }\r\n\r\n    // When we solve an astSymbol, then we always also solve all of its parents and all of its declarations.\r\n    // The parent is solved first.\r\n    if (astSymbol.parentAstSymbol && astSymbol.parentAstSymbol.symbolMetadata === undefined) {\r\n      this._fetchSymbolMetadata(astSymbol.parentAstSymbol);\r\n    }\r\n\r\n    // Construct the DeclarationMetadata objects, and detect any ancillary declarations\r\n    this._calculateDeclarationMetadataForDeclarations(astSymbol);\r\n\r\n    // Calculate the ApiItemMetadata objects\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      this._calculateApiItemMetadata(astDeclaration);\r\n    }\r\n\r\n    // The most public effectiveReleaseTag for all declarations\r\n    let maxEffectiveReleaseTag: ReleaseTag = ReleaseTag.None;\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      // We know we solved this above\r\n      const apiItemMetadata: ApiItemMetadata = astDeclaration.apiItemMetadata as ApiItemMetadata;\r\n\r\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n      if (effectiveReleaseTag > maxEffectiveReleaseTag) {\r\n        maxEffectiveReleaseTag = effectiveReleaseTag;\r\n      }\r\n    }\r\n\r\n    // Update this last when we're sure no exceptions were thrown\r\n    astSymbol.symbolMetadata = new SymbolMetadata({\r\n      maxEffectiveReleaseTag\r\n    });\r\n  }\r\n\r\n  private _calculateDeclarationMetadataForDeclarations(astSymbol: AstSymbol): void {\r\n    // Initialize DeclarationMetadata for each declaration\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      if (astDeclaration.declarationMetadata) {\r\n        throw new InternalError(\r\n          'AstDeclaration.declarationMetadata is not expected to have been initialized yet'\r\n        );\r\n      }\r\n\r\n      const metadata: InternalDeclarationMetadata = new InternalDeclarationMetadata();\r\n      metadata.tsdocParserContext = this._parseTsdocForAstDeclaration(astDeclaration);\r\n\r\n      astDeclaration.declarationMetadata = metadata;\r\n    }\r\n\r\n    // Detect ancillary declarations\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      // For a getter/setter pair, make the setter ancillary to the getter\r\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\r\n        let foundGetter: boolean = false;\r\n        for (const getterAstDeclaration of astDeclaration.astSymbol.astDeclarations) {\r\n          if (getterAstDeclaration.declaration.kind === ts.SyntaxKind.GetAccessor) {\r\n            // Associate it with the getter\r\n            this._addAncillaryDeclaration(getterAstDeclaration, astDeclaration);\r\n\r\n            foundGetter = true;\r\n          }\r\n        }\r\n\r\n        if (!foundGetter) {\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.MissingGetter,\r\n            `The property \"${astDeclaration.astSymbol.localName}\" has a setter but no getter.`,\r\n            astDeclaration\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _addAncillaryDeclaration(\r\n    mainAstDeclaration: AstDeclaration,\r\n    ancillaryAstDeclaration: AstDeclaration\r\n  ): void {\r\n    const mainMetadata: InternalDeclarationMetadata =\r\n      mainAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\r\n    const ancillaryMetadata: InternalDeclarationMetadata =\r\n      ancillaryAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\r\n\r\n    if (mainMetadata.ancillaryDeclarations.indexOf(ancillaryAstDeclaration) >= 0) {\r\n      return; // already added\r\n    }\r\n\r\n    if (mainAstDeclaration.astSymbol !== ancillaryAstDeclaration.astSymbol) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because declarations do not' +\r\n          ' belong to the same symbol'\r\n      );\r\n    }\r\n\r\n    if (mainMetadata.isAncillary) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because the target is ancillary itself'\r\n      );\r\n    }\r\n\r\n    if (ancillaryMetadata.isAncillary) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because source is already ancillary' +\r\n          ' to another declaration'\r\n      );\r\n    }\r\n\r\n    if (mainAstDeclaration.apiItemMetadata || ancillaryAstDeclaration.apiItemMetadata) {\r\n      throw new InternalError(\r\n        'Invalid call to _addAncillaryDeclaration() because the API item metadata' +\r\n          ' has already been constructed'\r\n      );\r\n    }\r\n\r\n    ancillaryMetadata.isAncillary = true;\r\n    mainMetadata.ancillaryDeclarations.push(ancillaryAstDeclaration);\r\n  }\r\n\r\n  private _calculateApiItemMetadata(astDeclaration: AstDeclaration): void {\r\n    const declarationMetadata: InternalDeclarationMetadata =\r\n      astDeclaration.declarationMetadata as InternalDeclarationMetadata;\r\n    if (declarationMetadata.isAncillary) {\r\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\r\n        if (declarationMetadata.tsdocParserContext) {\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.SetterWithDocs,\r\n            `The doc comment for the property \"${astDeclaration.astSymbol.localName}\"` +\r\n              ` must appear on the getter, not the setter.`,\r\n            astDeclaration\r\n          );\r\n        }\r\n      }\r\n\r\n      // We never calculate ApiItemMetadata for an ancillary declaration; instead, it is assigned when\r\n      // the main declaration is processed.\r\n      return;\r\n    }\r\n\r\n    const options: IApiItemMetadataOptions = {\r\n      declaredReleaseTag: ReleaseTag.None,\r\n      effectiveReleaseTag: ReleaseTag.None,\r\n      isEventProperty: false,\r\n      isOverride: false,\r\n      isSealed: false,\r\n      isVirtual: false,\r\n      isPreapproved: false,\r\n      releaseTagSameAsParent: false\r\n    };\r\n\r\n    const parserContext: tsdoc.ParserContext | undefined = declarationMetadata.tsdocParserContext;\r\n    if (parserContext) {\r\n      const modifierTagSet: tsdoc.StandardModifierTagSet = parserContext.docComment.modifierTagSet;\r\n\r\n      let declaredReleaseTag: ReleaseTag = ReleaseTag.None;\r\n      let extraReleaseTags: boolean = false;\r\n\r\n      if (modifierTagSet.isPublic()) {\r\n        declaredReleaseTag = ReleaseTag.Public;\r\n      }\r\n      if (modifierTagSet.isBeta()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Beta;\r\n        }\r\n      }\r\n      if (modifierTagSet.isAlpha()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Alpha;\r\n        }\r\n      }\r\n      if (modifierTagSet.isInternal()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Internal;\r\n        }\r\n      }\r\n\r\n      if (extraReleaseTags) {\r\n        if (!astDeclaration.astSymbol.isExternal) {\r\n          // for now, don't report errors for external code\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.ExtraReleaseTag,\r\n            'The doc comment should not contain more than one release tag',\r\n            astDeclaration\r\n          );\r\n        }\r\n      }\r\n\r\n      options.declaredReleaseTag = declaredReleaseTag;\r\n\r\n      options.isEventProperty = modifierTagSet.isEventProperty();\r\n      options.isOverride = modifierTagSet.isOverride();\r\n      options.isSealed = modifierTagSet.isSealed();\r\n      options.isVirtual = modifierTagSet.isVirtual();\r\n      const preapprovedTag: tsdoc.TSDocTagDefinition | void =\r\n        this.extractorConfig.tsdocConfiguration.tryGetTagDefinition('@preapproved');\r\n\r\n      if (preapprovedTag && modifierTagSet.hasTag(preapprovedTag)) {\r\n        // This feature only makes sense for potentially big declarations.\r\n        switch (astDeclaration.declaration.kind) {\r\n          case ts.SyntaxKind.ClassDeclaration:\r\n          case ts.SyntaxKind.EnumDeclaration:\r\n          case ts.SyntaxKind.InterfaceDeclaration:\r\n          case ts.SyntaxKind.ModuleDeclaration:\r\n            if (declaredReleaseTag === ReleaseTag.Internal) {\r\n              options.isPreapproved = true;\r\n            } else {\r\n              this.messageRouter.addAnalyzerIssue(\r\n                ExtractorMessageId.PreapprovedBadReleaseTag,\r\n                `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\r\n                  ` without an @internal release tag`,\r\n                astDeclaration\r\n              );\r\n            }\r\n            break;\r\n          default:\r\n            this.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.PreapprovedUnsupportedType,\r\n              `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\r\n                ` because it is not a supported declaration type`,\r\n              astDeclaration\r\n            );\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // This needs to be set regardless of whether or not a parserContext exists\r\n    if (astDeclaration.parent) {\r\n      const parentApiItemMetadata: ApiItemMetadata = this.fetchApiItemMetadata(astDeclaration.parent);\r\n      options.effectiveReleaseTag =\r\n        options.declaredReleaseTag === ReleaseTag.None\r\n          ? parentApiItemMetadata.effectiveReleaseTag\r\n          : options.declaredReleaseTag;\r\n\r\n      options.releaseTagSameAsParent =\r\n        parentApiItemMetadata.effectiveReleaseTag === options.effectiveReleaseTag;\r\n    } else {\r\n      options.effectiveReleaseTag = options.declaredReleaseTag;\r\n    }\r\n\r\n    if (options.effectiveReleaseTag === ReleaseTag.None) {\r\n      if (!astDeclaration.astSymbol.isExternal) {\r\n        // for now, don't report errors for external code\r\n        // Don't report missing release tags for forgotten exports\r\n        const astSymbol: AstSymbol = astDeclaration.astSymbol;\r\n        const entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astSymbol.rootAstSymbol);\r\n        if (entity && entity.exported) {\r\n          // We also don't report errors for the default export of an entry point, since its doc comment\r\n          // isn't easy to obtain from the .d.ts file\r\n          if (astSymbol.rootAstSymbol.localName !== '_default') {\r\n            this.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.MissingReleaseTag,\r\n              `\"${entity.astEntity.localName}\" is exported by the package, but it is missing ` +\r\n                `a release tag (@alpha, @beta, @public, or @internal)`,\r\n              astSymbol\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      options.effectiveReleaseTag = ReleaseTag.Public;\r\n    }\r\n\r\n    const apiItemMetadata: ApiItemMetadata = new ApiItemMetadata(options);\r\n    if (parserContext) {\r\n      apiItemMetadata.tsdocComment = parserContext.docComment;\r\n    }\r\n\r\n    astDeclaration.apiItemMetadata = apiItemMetadata;\r\n\r\n    // Lastly, share the result with any ancillary declarations\r\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\r\n      ancillaryDeclaration.apiItemMetadata = apiItemMetadata;\r\n    }\r\n  }\r\n\r\n  private _parseTsdocForAstDeclaration(astDeclaration: AstDeclaration): tsdoc.ParserContext | undefined {\r\n    const declaration: ts.Declaration = astDeclaration.declaration;\r\n    let nodeForComment: ts.Node = declaration;\r\n\r\n    if (ts.isVariableDeclaration(declaration)) {\r\n      // Variable declarations are special because they can be combined into a list.  For example:\r\n      //\r\n      // /** A */ export /** B */ const /** C */ x = 1, /** D **/ [ /** E */ y, z] = [3, 4];\r\n      //\r\n      // The compiler will only emit comments A and C in the .d.ts file, so in general there isn't a well-defined\r\n      // way to document these parts.  API Extractor requires you to break them into separate exports like this:\r\n      //\r\n      // /** A */ export const x = 1;\r\n      //\r\n      // But _getReleaseTagForDeclaration() still receives a node corresponding to \"x\", so we need to walk upwards\r\n      // and find the containing statement in order for getJSDocCommentRanges() to read the comment that we expect.\r\n      const statement: ts.VariableStatement | undefined = TypeScriptHelpers.findFirstParent(\r\n        declaration,\r\n        ts.SyntaxKind.VariableStatement\r\n      ) as ts.VariableStatement | undefined;\r\n      if (statement !== undefined) {\r\n        // For a compound declaration, fall back to looking for C instead of A\r\n        if (statement.declarationList.declarations.length === 1) {\r\n          nodeForComment = statement;\r\n        }\r\n      }\r\n    }\r\n\r\n    const sourceFileText: string = declaration.getSourceFile().text;\r\n    const ranges: ts.CommentRange[] =\r\n      TypeScriptInternals.getJSDocCommentRanges(nodeForComment, sourceFileText) || [];\r\n\r\n    if (ranges.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    // We use the JSDoc comment block that is closest to the definition, i.e.\r\n    // the last one preceding it\r\n    const range: ts.TextRange = ranges[ranges.length - 1];\r\n\r\n    const tsdocTextRange: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\r\n      sourceFileText,\r\n      range.pos,\r\n      range.end\r\n    );\r\n\r\n    const parserContext: tsdoc.ParserContext = this._tsdocParser.parseRange(tsdocTextRange);\r\n\r\n    this.messageRouter.addTsdocMessages(parserContext, declaration.getSourceFile(), astDeclaration);\r\n\r\n    // We delete the @privateRemarks block as early as possible, to ensure that it never leaks through\r\n    // into one of the output files.\r\n    parserContext.docComment.privateRemarks = undefined;\r\n\r\n    return parserContext;\r\n  }\r\n\r\n  private _collectReferenceDirectives(astSymbol: AstSymbol): void {\r\n    const seenFilenames: Set<string> = new Set<string>();\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const sourceFile: ts.SourceFile = astDeclaration.declaration.getSourceFile();\r\n      if (sourceFile && sourceFile.fileName) {\r\n        if (!seenFilenames.has(sourceFile.fileName)) {\r\n          seenFilenames.add(sourceFile.fileName);\r\n\r\n          for (const typeReferenceDirective of sourceFile.typeReferenceDirectives) {\r\n            const name: string = sourceFile.text.substring(\r\n              typeReferenceDirective.pos,\r\n              typeReferenceDirective.end\r\n            );\r\n            this._dtsTypeReferenceDirectives.add(name);\r\n          }\r\n\r\n          for (const libReferenceDirective of sourceFile.libReferenceDirectives) {\r\n            const name: string = sourceFile.text.substring(\r\n              libReferenceDirective.pos,\r\n              libReferenceDirective.end\r\n            );\r\n            this._dtsLibReferenceDirectives.add(name);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}