{"version":3,"file":"ExcerptBuilder.js","sourceRoot":"","sources":["../../src/generators/ExcerptBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\r\nimport { ExcerptTokenKind, IExcerptToken, IExcerptTokenRange } from '@microsoft/api-extractor-model';\r\n\r\nimport { Span } from '../analyzer/Span';\r\nimport { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\n\r\n/**\r\n * Used to provide ExcerptBuilder with a list of nodes whose token range we want to capture.\r\n */\r\nexport interface IExcerptBuilderNodeToCapture {\r\n  /**\r\n   * The node to capture\r\n   */\r\n  node: ts.Node | undefined;\r\n  /**\r\n   * The token range whose startIndex/endIndex will be overwritten with the indexes for the\r\n   * tokens corresponding to IExcerptBuilderNodeToCapture.node\r\n   */\r\n  tokenRange: IExcerptTokenRange;\r\n}\r\n\r\n/**\r\n * Internal state for ExcerptBuilder\r\n */\r\ninterface IBuildSpanState {\r\n  referenceGenerator: DeclarationReferenceGenerator;\r\n\r\n  /**\r\n   * The AST node that we will traverse to extract tokens\r\n   */\r\n  startingNode: ts.Node;\r\n\r\n  /**\r\n   * Normally, the excerpt will include all child nodes for `startingNode`; whereas if `childKindToStopBefore`\r\n   * is specified, then the node traversal will stop before (i.e. excluding) the first immediate child\r\n   * of `startingNode` with the specified syntax kind.\r\n   *\r\n   * @remarks\r\n   * For example, suppose the signature is `interface X: Y { z: string }`.  The token `{` has syntax kind\r\n   * `ts.SyntaxKind.FirstPunctuation`, so we can specify that to truncate the excerpt to `interface X: Y`.\r\n   */\r\n  stopBeforeChildKind: ts.SyntaxKind | undefined;\r\n\r\n  tokenRangesByNode: Map<ts.Node, IExcerptTokenRange>;\r\n\r\n  /**\r\n   * Normally adjacent tokens of the same kind get merged, to avoid creating lots of unnecessary extra tokens.\r\n   * However when an captured excerpt needs to start/end at a specific character, we temporarily disable merging by\r\n   * setting this flag.  After the new token is added, this flag is cleared.\r\n   */\r\n  disableMergingForNextToken: boolean;\r\n}\r\n\r\nexport class ExcerptBuilder {\r\n  /**\r\n   * Appends a blank line to the `excerptTokens` list.\r\n   * @param excerptTokens - The target token list to append to\r\n   */\r\n  public static addBlankLine(excerptTokens: IExcerptToken[]): void {\r\n    let newlines: string = '\\n\\n';\r\n    // If the existing text already ended with a newline, then only append one newline\r\n    if (excerptTokens.length > 0) {\r\n      const previousText: string = excerptTokens[excerptTokens.length - 1].text;\r\n      if (/\\n$/.test(previousText)) {\r\n        newlines = '\\n';\r\n      }\r\n    }\r\n    excerptTokens.push({ kind: ExcerptTokenKind.Content, text: newlines });\r\n  }\r\n\r\n  /**\r\n   * Appends the signature for the specified `AstDeclaration` to the `excerptTokens` list.\r\n   * @param excerptTokens - The target token list to append to\r\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\r\n   */\r\n  public static addDeclaration(\r\n    excerptTokens: IExcerptToken[],\r\n    astDeclaration: AstDeclaration,\r\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\r\n    referenceGenerator: DeclarationReferenceGenerator\r\n  ): void {\r\n    let stopBeforeChildKind: ts.SyntaxKind | undefined = undefined;\r\n\r\n    switch (astDeclaration.declaration.kind) {\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n        // FirstPunctuation = \"{\"\r\n        stopBeforeChildKind = ts.SyntaxKind.FirstPunctuation;\r\n        break;\r\n      case ts.SyntaxKind.ModuleDeclaration:\r\n        // ModuleBlock = the \"{ ... }\" block\r\n        stopBeforeChildKind = ts.SyntaxKind.ModuleBlock;\r\n        break;\r\n    }\r\n\r\n    const span: Span = new Span(astDeclaration.declaration);\r\n\r\n    const tokenRangesByNode: Map<ts.Node, IExcerptTokenRange> = new Map<ts.Node, IExcerptTokenRange>();\r\n    for (const excerpt of nodesToCapture || []) {\r\n      if (excerpt.node) {\r\n        tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);\r\n      }\r\n    }\r\n\r\n    ExcerptBuilder._buildSpan(excerptTokens, span, {\r\n      referenceGenerator: referenceGenerator,\r\n      startingNode: span.node,\r\n      stopBeforeChildKind,\r\n      tokenRangesByNode,\r\n      disableMergingForNextToken: false\r\n    });\r\n  }\r\n\r\n  public static createEmptyTokenRange(): IExcerptTokenRange {\r\n    return { startIndex: 0, endIndex: 0 };\r\n  }\r\n\r\n  private static _buildSpan(excerptTokens: IExcerptToken[], span: Span, state: IBuildSpanState): boolean {\r\n    if (span.kind === ts.SyntaxKind.JSDocComment) {\r\n      // Discard any comments\r\n      return true;\r\n    }\r\n\r\n    // Can this node start a excerpt?\r\n    const capturedTokenRange: IExcerptTokenRange | undefined = state.tokenRangesByNode.get(span.node);\r\n    let excerptStartIndex: number = 0;\r\n\r\n    if (capturedTokenRange) {\r\n      // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended\r\n      excerptStartIndex = excerptTokens.length;\r\n      state.disableMergingForNextToken = true;\r\n    }\r\n\r\n    if (span.prefix) {\r\n      let canonicalReference: DeclarationReference | undefined = undefined;\r\n\r\n      if (span.kind === ts.SyntaxKind.Identifier) {\r\n        const name: ts.Identifier = span.node as ts.Identifier;\r\n        if (!ExcerptBuilder._isDeclarationName(name)) {\r\n          canonicalReference = state.referenceGenerator.getDeclarationReferenceForIdentifier(name);\r\n        }\r\n      }\r\n\r\n      if (canonicalReference) {\r\n        ExcerptBuilder._appendToken(\r\n          excerptTokens,\r\n          ExcerptTokenKind.Reference,\r\n          span.prefix,\r\n          state,\r\n          canonicalReference\r\n        );\r\n      } else {\r\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.prefix, state);\r\n      }\r\n    }\r\n\r\n    for (const child of span.children) {\r\n      if (span.node === state.startingNode) {\r\n        if (state.stopBeforeChildKind && child.kind === state.stopBeforeChildKind) {\r\n          // We reached the a child whose kind is stopBeforeChildKind, so stop traversing\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!this._buildSpan(excerptTokens, child, state)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (span.suffix) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.suffix, state);\r\n    }\r\n    if (span.separator) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.separator, state);\r\n    }\r\n\r\n    // Are we building a excerpt?  If so, set its range\r\n    if (capturedTokenRange) {\r\n      capturedTokenRange.startIndex = excerptStartIndex;\r\n\r\n      // We will assign capturedTokenRange.startIndex to be the index after the last token that was appended so far\r\n      capturedTokenRange.endIndex = excerptTokens.length;\r\n\r\n      state.disableMergingForNextToken = true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private static _appendToken(\r\n    excerptTokens: IExcerptToken[],\r\n    excerptTokenKind: ExcerptTokenKind,\r\n    text: string,\r\n    state: IBuildSpanState,\r\n    canonicalReference?: DeclarationReference\r\n  ): void {\r\n    if (text.length === 0) {\r\n      return;\r\n    }\r\n\r\n    if (excerptTokenKind !== ExcerptTokenKind.Content) {\r\n      if (\r\n        excerptTokenKind === ExcerptTokenKind.Reference &&\r\n        excerptTokens.length > 1 &&\r\n        !state.disableMergingForNextToken\r\n      ) {\r\n        // If the previous two tokens were a Reference and a '.', then concatenate\r\n        // all three tokens as a qualified name Reference.\r\n        const previousTokenM1: IExcerptToken = excerptTokens[excerptTokens.length - 1];\r\n        const previousTokenM2: IExcerptToken = excerptTokens[excerptTokens.length - 2];\r\n        if (\r\n          previousTokenM1.kind === ExcerptTokenKind.Content &&\r\n          previousTokenM1.text.trim() === '.' &&\r\n          previousTokenM2.kind === ExcerptTokenKind.Reference\r\n        ) {\r\n          previousTokenM2.text += '.' + text;\r\n          if (canonicalReference !== undefined) {\r\n            previousTokenM2.canonicalReference = canonicalReference.toString();\r\n          }\r\n          excerptTokens.pop(); // remove previousTokenM1;\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      // If someone referenced this index, then we need to start a new token\r\n      if (excerptTokens.length > 0 && !state.disableMergingForNextToken) {\r\n        // Otherwise, can we merge with the previous token?\r\n        const previousToken: IExcerptToken = excerptTokens[excerptTokens.length - 1];\r\n        if (previousToken.kind === excerptTokenKind) {\r\n          previousToken.text += text;\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    const excerptToken: IExcerptToken = { kind: excerptTokenKind, text: text };\r\n    if (canonicalReference !== undefined) {\r\n      excerptToken.canonicalReference = canonicalReference.toString();\r\n    }\r\n    excerptTokens.push(excerptToken);\r\n    state.disableMergingForNextToken = false;\r\n  }\r\n\r\n  private static _isDeclarationName(name: ts.Identifier): boolean {\r\n    return ExcerptBuilder._isDeclaration(name.parent) && name.parent.name === name;\r\n  }\r\n\r\n  private static _isDeclaration(node: ts.Node): node is ts.NamedDeclaration {\r\n    switch (node.kind) {\r\n      case ts.SyntaxKind.FunctionDeclaration:\r\n      case ts.SyntaxKind.FunctionExpression:\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n      case ts.SyntaxKind.Parameter:\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n      case ts.SyntaxKind.ClassExpression:\r\n      case ts.SyntaxKind.ModuleDeclaration:\r\n      case ts.SyntaxKind.MethodDeclaration:\r\n      case ts.SyntaxKind.MethodSignature:\r\n      case ts.SyntaxKind.PropertyDeclaration:\r\n      case ts.SyntaxKind.PropertySignature:\r\n      case ts.SyntaxKind.GetAccessor:\r\n      case ts.SyntaxKind.SetAccessor:\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n      case ts.SyntaxKind.TypeAliasDeclaration:\r\n      case ts.SyntaxKind.TypeParameter:\r\n      case ts.SyntaxKind.EnumMember:\r\n      case ts.SyntaxKind.BindingElement:\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}\r\n"]}