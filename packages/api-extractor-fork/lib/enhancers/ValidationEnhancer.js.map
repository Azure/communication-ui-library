{"version":3,"file":"ValidationEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/ValidationEnhancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\n\r\nimport { Collector } from '../collector/Collector';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport { SymbolMetadata } from '../collector/SymbolMetadata';\r\nimport { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\n\r\nexport class ValidationEnhancer {\r\n  public static analyze(collector: Collector): void {\r\n    const alreadyWarnedSymbols: Set<AstSymbol> = new Set<AstSymbol>();\r\n\r\n    for (const entity of collector.entities) {\r\n      if (entity.astEntity instanceof AstSymbol) {\r\n        if (entity.exported) {\r\n          entity.astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n            ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedSymbols);\r\n          });\r\n\r\n          const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(entity.astEntity);\r\n          ValidationEnhancer._checkForInternalUnderscore(collector, entity, entity.astEntity, symbolMetadata);\r\n          ValidationEnhancer._checkForInconsistentReleaseTags(collector, entity.astEntity, symbolMetadata);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkForInternalUnderscore(\r\n    collector: Collector,\r\n    collectorEntity: CollectorEntity,\r\n    astSymbol: AstSymbol,\r\n    symbolMetadata: SymbolMetadata\r\n  ): void {\r\n    let needsUnderscore: boolean = false;\r\n\r\n    if (symbolMetadata.maxEffectiveReleaseTag === ReleaseTag.Internal) {\r\n      if (!astSymbol.parentAstSymbol) {\r\n        // If it's marked as @internal and has no parent, then it needs and underscore.\r\n        // We use maxEffectiveReleaseTag because a merged declaration would NOT need an underscore in a case like this:\r\n        //\r\n        //   /** @public */\r\n        //   export enum X { }\r\n        //\r\n        //   /** @internal */\r\n        //   export namespace X { }\r\n        //\r\n        // (The above normally reports an error \"ae-different-release-tags\", but that may be suppressed.)\r\n        needsUnderscore = true;\r\n      } else {\r\n        // If it's marked as @internal and the parent isn't obviously already @internal, then it needs an underscore.\r\n        //\r\n        // For example, we WOULD need an underscore for a merged declaration like this:\r\n        //\r\n        //   /** @internal */\r\n        //   export namespace X {\r\n        //     export interface _Y { }\r\n        //   }\r\n        //\r\n        //   /** @public */\r\n        //   export class X {\r\n        //     /** @internal */\r\n        //     public static _Y(): void { }   // <==== different from parent\r\n        //   }\r\n        const parentSymbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n        if (parentSymbolMetadata.maxEffectiveReleaseTag > ReleaseTag.Internal) {\r\n          needsUnderscore = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (needsUnderscore) {\r\n      for (const exportName of collectorEntity.exportNames) {\r\n        if (exportName[0] !== '_') {\r\n          collector.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.InternalMissingUnderscore,\r\n            `The name \"${exportName}\" should be prefixed with an underscore` +\r\n              ` because the declaration is marked as @internal`,\r\n            astSymbol,\r\n            { exportName }\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkForInconsistentReleaseTags(\r\n    collector: Collector,\r\n    astSymbol: AstSymbol,\r\n    symbolMetadata: SymbolMetadata\r\n  ): void {\r\n    if (astSymbol.isExternal) {\r\n      // For now, don't report errors for external code.  If the developer cares about it, they should run\r\n      // API Extractor separately on the external project\r\n      return;\r\n    }\r\n\r\n    // Normally we will expect all release tags to be the same.  Arbitrarily we choose the maxEffectiveReleaseTag\r\n    // as the thing they should all match.\r\n    const expectedEffectiveReleaseTag: ReleaseTag = symbolMetadata.maxEffectiveReleaseTag;\r\n\r\n    // This is set to true if we find a declaration whose release tag is different from expectedEffectiveReleaseTag\r\n    let mixedReleaseTags: boolean = false;\r\n\r\n    // This is set to false if we find a declaration that is not a function/method overload\r\n    let onlyFunctionOverloads: boolean = true;\r\n\r\n    // This is set to true if we find a declaration that is @internal\r\n    let anyInternalReleaseTags: boolean = false;\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n      switch (astDeclaration.declaration.kind) {\r\n        case ts.SyntaxKind.FunctionDeclaration:\r\n        case ts.SyntaxKind.MethodDeclaration:\r\n          break;\r\n        default:\r\n          onlyFunctionOverloads = false;\r\n      }\r\n\r\n      if (effectiveReleaseTag !== expectedEffectiveReleaseTag) {\r\n        mixedReleaseTags = true;\r\n      }\r\n\r\n      if (effectiveReleaseTag === ReleaseTag.Internal) {\r\n        anyInternalReleaseTags = true;\r\n      }\r\n    }\r\n\r\n    if (mixedReleaseTags) {\r\n      if (!onlyFunctionOverloads) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.DifferentReleaseTags,\r\n          'This symbol has another declaration with a different release tag',\r\n          astSymbol\r\n        );\r\n      }\r\n\r\n      if (anyInternalReleaseTags) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.InternalMixedReleaseTag,\r\n          `Mixed release tags are not allowed for \"${astSymbol.localName}\" because one of its declarations` +\r\n            ` is marked as @internal`,\r\n          astSymbol\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkReferences(\r\n    collector: Collector,\r\n    astDeclaration: AstDeclaration,\r\n    alreadyWarnedSymbols: Set<AstSymbol>\r\n  ): void {\r\n    const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n    const declarationReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n    for (const referencedEntity of astDeclaration.referencedAstEntities) {\r\n      if (referencedEntity instanceof AstSymbol) {\r\n        // If this is e.g. a member of a namespace, then we need to be checking the top-level scope to see\r\n        // whether it's exported.\r\n        //\r\n        // TODO: Technically we should also check each of the nested scopes along the way.\r\n        const rootSymbol: AstSymbol = referencedEntity.rootAstSymbol;\r\n\r\n        if (!rootSymbol.isExternal) {\r\n          const collectorEntity: CollectorEntity | undefined = collector.tryGetCollectorEntity(rootSymbol);\r\n\r\n          if (collectorEntity && collectorEntity.exported) {\r\n            const referencedMetadata: SymbolMetadata = collector.fetchSymbolMetadata(referencedEntity);\r\n            const referencedReleaseTag: ReleaseTag = referencedMetadata.maxEffectiveReleaseTag;\r\n\r\n            if (ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {\r\n              collector.messageRouter.addAnalyzerIssue(\r\n                ExtractorMessageId.IncompatibleReleaseTags,\r\n                `The symbol \"${astDeclaration.astSymbol.localName}\"` +\r\n                  ` is marked as ${ReleaseTag.getTagName(declarationReleaseTag)},` +\r\n                  ` but its signature references \"${referencedEntity.localName}\"` +\r\n                  ` which is marked as ${ReleaseTag.getTagName(referencedReleaseTag)}`,\r\n                astDeclaration\r\n              );\r\n            }\r\n          } else {\r\n            const entryPointFilename: string = path.basename(\r\n              collector.workingPackage.entryPointSourceFile.fileName\r\n            );\r\n\r\n            if (!alreadyWarnedSymbols.has(referencedEntity)) {\r\n              alreadyWarnedSymbols.add(referencedEntity);\r\n\r\n              // The main usage scenario for ECMAScript symbols is to attach private data to a JavaScript object,\r\n              // so as a special case, we do NOT report them as forgotten exports.\r\n              if (!ValidationEnhancer._isEcmaScriptSymbol(referencedEntity)) {\r\n                collector.messageRouter.addAnalyzerIssue(\r\n                  ExtractorMessageId.ForgottenExport,\r\n                  `The symbol \"${rootSymbol.localName}\" needs to be exported` +\r\n                    ` by the entry point ${entryPointFilename}`,\r\n                  astDeclaration\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Detect an AstSymbol that refers to an ECMAScript symbol declaration such as:\r\n  //\r\n  // const mySymbol: unique symbol = Symbol('mySymbol');\r\n  private static _isEcmaScriptSymbol(astSymbol: AstSymbol): boolean {\r\n    if (astSymbol.astDeclarations.length !== 1) {\r\n      return false;\r\n    }\r\n\r\n    // We are matching a form like this:\r\n    //\r\n    // - VariableDeclaration:\r\n    //   - Identifier:  pre=[mySymbol]\r\n    //   - ColonToken:  pre=[:] sep=[ ]\r\n    //   - TypeOperator:\r\n    //     - UniqueKeyword:  pre=[unique] sep=[ ]\r\n    //     - SymbolKeyword:  pre=[symbol]\r\n    const astDeclaration: AstDeclaration = astSymbol.astDeclarations[0];\r\n    if (ts.isVariableDeclaration(astDeclaration.declaration)) {\r\n      const variableTypeNode: ts.TypeNode | undefined = astDeclaration.declaration.type;\r\n      if (variableTypeNode) {\r\n        for (const token of variableTypeNode.getChildren()) {\r\n          if (token.kind === ts.SyntaxKind.SymbolKeyword) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n"]}