{"version":3,"file":"CompilerState.js","sourceRoot":"","sources":["../../src/api/CompilerState.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\nimport colors = require('colors');\r\n\r\nimport { JsonFile } from '@rushstack/node-core-library';\r\n\r\nimport { ExtractorConfig } from './ExtractorConfig';\r\nimport { IExtractorInvokeOptions } from './Extractor';\r\n\r\n/**\r\n * Options for {@link CompilerState.create}\r\n * @public\r\n */\r\nexport interface ICompilerStateCreateOptions {\r\n  /** {@inheritDoc IExtractorInvokeOptions.typescriptCompilerFolder} */\r\n  typescriptCompilerFolder?: string;\r\n\r\n  /**\r\n   * Additional .d.ts files to include in the analysis.\r\n   */\r\n  additionalEntryPoints?: string[];\r\n}\r\n\r\n/**\r\n * This class represents the TypeScript compiler state.  This allows an optimization where multiple invocations\r\n * of API Extractor can reuse the same TypeScript compiler analysis.\r\n *\r\n * @public\r\n */\r\nexport class CompilerState {\r\n  /**\r\n   * The TypeScript compiler's `Program` object, which represents a complete scope of analysis.\r\n   */\r\n  public readonly program: unknown;\r\n\r\n  private constructor(properties: CompilerState) {\r\n    this.program = properties.program;\r\n  }\r\n\r\n  /**\r\n   * Create a compiler state for use with the specified `IExtractorInvokeOptions`.\r\n   */\r\n  public static create(\r\n    extractorConfig: ExtractorConfig,\r\n    options?: ICompilerStateCreateOptions\r\n  ): CompilerState {\r\n    let tsconfig: {} | undefined = extractorConfig.overrideTsconfig;\r\n    let configBasePath: string = extractorConfig.projectFolder;\r\n    if (!tsconfig) {\r\n      // If it wasn't overridden, then load it from disk\r\n      tsconfig = JsonFile.load(extractorConfig.tsconfigFilePath);\r\n      configBasePath = path.resolve(path.dirname(extractorConfig.tsconfigFilePath));\r\n    }\r\n\r\n    const commandLine: ts.ParsedCommandLine = ts.parseJsonConfigFileContent(tsconfig, ts.sys, configBasePath);\r\n\r\n    if (!commandLine.options.skipLibCheck && extractorConfig.skipLibCheck) {\r\n      commandLine.options.skipLibCheck = true;\r\n      console.log(\r\n        colors.cyan(\r\n          'API Extractor was invoked with skipLibCheck. This is not recommended and may cause ' +\r\n            'incorrect type analysis.'\r\n        )\r\n      );\r\n    }\r\n\r\n    const inputFilePaths: string[] = commandLine.fileNames.concat(extractorConfig.mainEntryPointFilePath);\r\n    if (options && options.additionalEntryPoints) {\r\n      inputFilePaths.push(...options.additionalEntryPoints);\r\n    }\r\n\r\n    // Append the entry points and remove any non-declaration files from the list\r\n    const analysisFilePaths: string[] = CompilerState._generateFilePathsForAnalysis(inputFilePaths);\r\n\r\n    const compilerHost: ts.CompilerHost = CompilerState._createCompilerHost(commandLine, options);\r\n\r\n    const program: ts.Program = ts.createProgram(analysisFilePaths, commandLine.options, compilerHost);\r\n\r\n    if (commandLine.errors.length > 0) {\r\n      const errorText: string = ts.flattenDiagnosticMessageText(commandLine.errors[0].messageText, '\\n');\r\n      throw new Error(`Error parsing tsconfig.json content: ${errorText}`);\r\n    }\r\n\r\n    return new CompilerState({\r\n      program\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Given a list of absolute file paths, return a list containing only the declaration\r\n   * files.  Duplicates are also eliminated.\r\n   *\r\n   * @remarks\r\n   * The tsconfig.json settings specify the compiler's input (a set of *.ts source files,\r\n   * plus some *.d.ts declaration files used for legacy typings).  However API Extractor\r\n   * analyzes the compiler's output (a set of *.d.ts entry point files, plus any legacy\r\n   * typings).  This requires API Extractor to generate a special file list when it invokes\r\n   * the compiler.\r\n   *\r\n   * Duplicates are removed so that entry points can be appended without worrying whether they\r\n   * may already appear in the tsconfig.json file list.\r\n   */\r\n  private static _generateFilePathsForAnalysis(inputFilePaths: string[]): string[] {\r\n    const analysisFilePaths: string[] = [];\r\n\r\n    const seenFiles: Set<string> = new Set<string>();\r\n\r\n    for (const inputFilePath of inputFilePaths) {\r\n      const inputFileToUpper: string = inputFilePath.toUpperCase();\r\n      if (!seenFiles.has(inputFileToUpper)) {\r\n        seenFiles.add(inputFileToUpper);\r\n\r\n        if (!path.isAbsolute(inputFilePath)) {\r\n          throw new Error('Input file is not an absolute path: ' + inputFilePath);\r\n        }\r\n\r\n        if (ExtractorConfig.hasDtsFileExtension(inputFilePath)) {\r\n          analysisFilePaths.push(inputFilePath);\r\n        }\r\n      }\r\n    }\r\n\r\n    return analysisFilePaths;\r\n  }\r\n\r\n  private static _createCompilerHost(\r\n    commandLine: ts.ParsedCommandLine,\r\n    options: IExtractorInvokeOptions | undefined\r\n  ): ts.CompilerHost {\r\n    // Create a default CompilerHost that we will override\r\n    const compilerHost: ts.CompilerHost = ts.createCompilerHost(commandLine.options);\r\n\r\n    // Save a copy of the original members.  Note that \"compilerHost\" cannot be the copy, because\r\n    // createCompilerHost() captures that instance in a closure that is used by the members.\r\n    const defaultCompilerHost: ts.CompilerHost = { ...compilerHost };\r\n\r\n    if (options && options.typescriptCompilerFolder) {\r\n      // Prevent a closure parameter\r\n      const typescriptCompilerLibFolder: string = path.join(options.typescriptCompilerFolder, 'lib');\r\n      compilerHost.getDefaultLibLocation = () => typescriptCompilerLibFolder;\r\n    }\r\n\r\n    // Used by compilerHost.fileExists()\r\n    // .d.ts file path --> whether the file exists\r\n    const dtsExistsCache: Map<string, boolean> = new Map<string, boolean>();\r\n\r\n    // Used by compilerHost.fileExists()\r\n    // Example: \"c:/folder/file.part.ts\"\r\n    const fileExtensionRegExp: RegExp = /^(.+)(\\.[a-z0-9_]+)$/i;\r\n\r\n    compilerHost.fileExists = (fileName: string): boolean => {\r\n      // In certain deprecated setups, the compiler may write its output files (.js and .d.ts)\r\n      // in the same folder as the corresponding input file (.ts or .tsx).  When following imports,\r\n      // API Extractor wants to analyze the .d.ts file; however recent versions of the compiler engine\r\n      // will instead choose the .ts file.  To work around this, we hook fileExists() to hide the\r\n      // existence of those files.\r\n\r\n      // Is \"fileName\" a .d.ts file?  The double extension \".d.ts\" needs to be matched specially.\r\n      if (!ExtractorConfig.hasDtsFileExtension(fileName)) {\r\n        // It's not a .d.ts file.  Is the file extension a potential source file?\r\n        const match: RegExpExecArray | null = fileExtensionRegExp.exec(fileName);\r\n        if (match) {\r\n          // Example: \"c:/folder/file.part\"\r\n          const pathWithoutExtension: string = match[1];\r\n          // Example: \".ts\"\r\n          const fileExtension: string = match[2];\r\n\r\n          switch (fileExtension.toLocaleLowerCase()) {\r\n            case '.ts':\r\n            case '.tsx':\r\n            case '.js':\r\n            case '.jsx':\r\n              // Yes, this is a possible source file.  Is there a corresponding .d.ts file in the same folder?\r\n              const dtsFileName: string = `${pathWithoutExtension}.d.ts`;\r\n\r\n              let dtsFileExists: boolean | undefined = dtsExistsCache.get(dtsFileName);\r\n              if (dtsFileExists === undefined) {\r\n                dtsFileExists = defaultCompilerHost.fileExists!(dtsFileName);\r\n                dtsExistsCache.set(dtsFileName, dtsFileExists);\r\n              }\r\n\r\n              if (dtsFileExists) {\r\n                // fileName is a potential source file and a corresponding .d.ts file exists.\r\n                // Thus, API Extractor should ignore this file (so the .d.ts file will get analyzed instead).\r\n                return false;\r\n              }\r\n              break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Fall through to the default implementation\r\n      return defaultCompilerHost.fileExists!(fileName);\r\n    };\r\n\r\n    return compilerHost;\r\n  }\r\n}\r\n"]}