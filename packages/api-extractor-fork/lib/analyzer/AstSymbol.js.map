{"version":3,"file":"AstSymbol.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbol.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAI3D,oEAA6D;AAc7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCG;AACH,MAAa,SAAS;IAsEpB,YAAmB,OAA0B;QAJ7C,sDAAsD;QACtD,qDAAqD;QAC7C,cAAS,GAAY,KAAK,CAAC;QAGjC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,IAAI,CAAC;QACnD,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED;;;;;;;OAOG;IACH,IAAW,eAAe;QACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACtC,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,cAA8B;QAC5D,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,iCAAa,CAAC,sEAAsE,CAAC,CAAC;SACjG;QACD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACI,eAAe;QACpB,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,MAAM,IAAI,iCAAa,CAAC,iEAAiE,CAAC,CAAC;SAC5F;QACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,2BAA2B,CAAC,MAAgD;QACjF,KAAK,MAAM,cAAc,IAAI,IAAI,CAAC,eAAe,EAAE;YACjD,cAAc,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC;SACpD;IACH,CAAC;CACF;AAvID,8BAuIC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * Constructor options for AstSymbol\r\n */\r\nexport interface IAstSymbolOptions {\r\n  readonly followedSymbol: ts.Symbol;\r\n  readonly localName: string;\r\n  readonly isExternal: boolean;\r\n  readonly nominalAnalysis: boolean;\r\n  readonly parentAstSymbol: AstSymbol | undefined;\r\n  readonly rootAstSymbol: AstSymbol | undefined;\r\n}\r\n\r\n/**\r\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\r\n * ts.Declaration and ts.Symbol objects.  They are created by the `AstSymbolTable` class.\r\n *\r\n * @remarks\r\n * The AstSymbol represents the ts.Symbol information for an AstDeclaration.  For example,\r\n * if a method has 3 overloads, each overloaded signature will have its own AstDeclaration,\r\n * but they will all share a common AstSymbol.\r\n *\r\n * For nested definitions, the AstSymbol has a unique parent (i.e. AstSymbol.rootAstSymbol),\r\n * but the parent/children for each AstDeclaration may be different.  Consider this example:\r\n *\r\n * ```ts\r\n * export namespace N {\r\n *   export function f(): void { }\r\n * }\r\n *\r\n * export interface N {\r\n *   g(): void;\r\n * }\r\n * ```\r\n *\r\n * Note how the parent/child relationships are different for the symbol tree versus\r\n * the declaration tree, and the declaration tree has two roots:\r\n *\r\n * ```\r\n * AstSymbol tree:            AstDeclaration tree:\r\n * - N                        - N (namespace)\r\n *   - f                        - f\r\n *   - g                      - N (interface)\r\n *                              - g\r\n * ```\r\n */\r\nexport class AstSymbol {\r\n  /**\r\n   * The original name of the symbol, as exported from the module (i.e. source file)\r\n   * containing the original TypeScript definition.  Constructs such as\r\n   * `import { X as Y } from` may introduce other names that differ from the local name.\r\n   *\r\n   * @remarks\r\n   * For the most part, `localName` corresponds to `followedSymbol.name`, but there\r\n   * are some edge cases.  For example, the symbol name for `export default class X { }`\r\n   * is actually `\"default\"`, not `\"X\"`.\r\n   */\r\n  public readonly localName: string;\r\n\r\n  /**\r\n   * If true, then the `followedSymbol` (i.e. original declaration) of this symbol\r\n   * is not part of the working package.  The working package may still export this symbol,\r\n   * but if so it should be emitted as an alias such as `export { X } from \"package1\";`.\r\n   */\r\n  public readonly isExternal: boolean;\r\n\r\n  /**\r\n   * The compiler symbol where this type was defined, after following any aliases.\r\n   *\r\n   * @remarks\r\n   * This is a normal form that can be reached from any symbol alias by calling\r\n   * `TypeScriptHelpers.followAliases()`.  It can be compared to determine whether two\r\n   * symbols refer to the same underlying type.\r\n   */\r\n  public readonly followedSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * If true, then this AstSymbol represents a foreign object whose structure will be\r\n   * ignored.  The AstDeclaration objects will not have any parent or children, and its references\r\n   * will not be analyzed.\r\n   *\r\n   * Nominal symbols are tracked e.g. when they are reexported by the working package.\r\n   */\r\n  public readonly nominalAnalysis: boolean;\r\n\r\n  /**\r\n   * Returns the symbol of the parent of this AstSymbol, or undefined if there is no parent.\r\n   * @remarks\r\n   * If a symbol has multiple declarations, we assume (as an axiom) that their parent\r\n   * declarations will belong to the same symbol.  This means that the \"parent\" of a\r\n   * symbol is a well-defined concept.  However, the \"children\" of a symbol are not very\r\n   * meaningful, because different declarations may have different nested members,\r\n   * so we usually need to traverse declarations to find children.\r\n   */\r\n  public readonly parentAstSymbol: AstSymbol | undefined;\r\n\r\n  /**\r\n   * Returns the symbol of the root of the AstDeclaration hierarchy.\r\n   * @remarks\r\n   * NOTE: If this AstSymbol is the root, then rootAstSymbol will point to itself.\r\n   */\r\n  public readonly rootAstSymbol: AstSymbol;\r\n\r\n  /**\r\n   * Additional information that is calculated later by the `Collector`.  The actual type is `SymbolMetadata`,\r\n   * but we declare it as `unknown` because consumers must obtain this object by calling\r\n   * `Collector.fetchSymbolMetadata()`.\r\n   */\r\n  public symbolMetadata: unknown;\r\n\r\n  private readonly _astDeclarations: AstDeclaration[];\r\n\r\n  // This flag is unused if this is not the root symbol.\r\n  // Being \"analyzed\" is a property of the root symbol.\r\n  private _analyzed: boolean = false;\r\n\r\n  public constructor(options: IAstSymbolOptions) {\r\n    this.followedSymbol = options.followedSymbol;\r\n    this.localName = options.localName;\r\n    this.isExternal = options.isExternal;\r\n    this.nominalAnalysis = options.nominalAnalysis;\r\n    this.parentAstSymbol = options.parentAstSymbol;\r\n    this.rootAstSymbol = options.rootAstSymbol || this;\r\n    this._astDeclarations = [];\r\n  }\r\n\r\n  /**\r\n   * The one or more declarations for this symbol.\r\n   * @remarks\r\n   * For example, if this symbol is a method, then the declarations might be\r\n   * various method overloads.  If this symbol is a namespace, then the declarations\r\n   * might be separate namespace blocks with the same name that get combined via\r\n   * declaration merging.\r\n   */\r\n  public get astDeclarations(): ReadonlyArray<AstDeclaration> {\r\n    return this._astDeclarations;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\r\n   * See that function for details.\r\n   * @remarks\r\n   * AstSymbolTable.analyze() is always performed on the root AstSymbol.  This function\r\n   * returns true if-and-only-if the root symbol was analyzed.\r\n   */\r\n  public get analyzed(): boolean {\r\n    return this.rootAstSymbol._analyzed;\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the AstSymbolTable attaches a new\r\n   * AstDeclaration to this object.\r\n   * @internal\r\n   */\r\n  public _notifyDeclarationAttach(astDeclaration: AstDeclaration): void {\r\n    if (this.analyzed) {\r\n      throw new InternalError('_notifyDeclarationAttach() called after analysis is already complete');\r\n    }\r\n    this._astDeclarations.push(astDeclaration);\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the AstSymbolTable.analyze()\r\n   * has processed this object.\r\n   * @internal\r\n   */\r\n  public _notifyAnalyzed(): void {\r\n    if (this.parentAstSymbol) {\r\n      throw new InternalError('_notifyAnalyzed() called for an AstSymbol which is not the root');\r\n    }\r\n    this._analyzed = true;\r\n  }\r\n\r\n  /**\r\n   * Helper that calls AstDeclaration.forEachDeclarationRecursive() for each AstDeclaration.\r\n   */\r\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\r\n    for (const astDeclaration of this.astDeclarations) {\r\n      astDeclaration.forEachDeclarationRecursive(action);\r\n    }\r\n  }\r\n}\r\n"]}