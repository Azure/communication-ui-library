{"version":3,"file":"ExportAnalyzer.js","sourceRoot":"","sources":["../../src/analyzer/ExportAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { AstImport, IAstImportOptions, AstImportKind } from './AstImport';\r\nimport { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { TypeScriptInternals } from './TypeScriptInternals';\r\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\r\nimport { IFetchAstSymbolOptions, AstEntity } from './AstSymbolTable';\r\n\r\n/**\r\n * Exposes the minimal APIs from AstSymbolTable that are needed by ExportAnalyzer.\r\n *\r\n * In particular, we want ExportAnalyzer to be able to call AstSymbolTable._fetchAstSymbol() even though it\r\n * is a very private API that should not be exposed to any other components.\r\n */\r\nexport interface IAstSymbolTable {\r\n  fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined;\r\n\r\n  analyze(astSymbol: AstSymbol): void;\r\n}\r\n\r\n/**\r\n * Used with ExportAnalyzer.fetchAstModuleBySourceFile() to provide contextual information about how the source file\r\n * was imported.\r\n */\r\ninterface IAstModuleReference {\r\n  /**\r\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\r\n   * string `\"some-package\"`.\r\n   */\r\n  moduleSpecifier: string;\r\n\r\n  /**\r\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\r\n   * symbol for `X`.\r\n   */\r\n  moduleSpecifierSymbol: ts.Symbol;\r\n}\r\n\r\n/**\r\n * The ExportAnalyzer is an internal part of AstSymbolTable that has been moved out into its own source file\r\n * because it is a complex and mostly self-contained algorithm.\r\n *\r\n * Its job is to build up AstModule objects by crawling import statements to discover where declarations come from.\r\n * This is conceptually the same as the compiler's own TypeChecker.getExportsOfModule(), except that when\r\n * ExportAnalyzer encounters a declaration that was imported from an external package, it remembers how it was imported\r\n * (i.e. the AstImport object).  Today the compiler API does not expose this information, which is crucial for\r\n * generating .d.ts rollups.\r\n */\r\nexport class ExportAnalyzer {\r\n  // Captures \"@a/b\" or \"d\" from these examples:\r\n  //   @a/b\r\n  //   @a/b/c\r\n  //   d\r\n  //   d/\r\n  //   d/e\r\n  private static _modulePathRegExp: RegExp = /^((?:@[^@\\/\\s]+\\/)?[^@\\/\\s]+)(?:.*)$/;\r\n\r\n  private readonly _program: ts.Program;\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _bundledPackageNames: ReadonlySet<string>;\r\n  private readonly _astSymbolTable: IAstSymbolTable;\r\n\r\n  private readonly _astModulesByModuleSymbol: Map<ts.Symbol, AstModule> = new Map<ts.Symbol, AstModule>();\r\n\r\n  // Used with isImportableAmbientSourceFile()\r\n  private readonly _importableAmbientSourceFiles: Set<ts.SourceFile> = new Set<ts.SourceFile>();\r\n\r\n  private readonly _astImportsByKey: Map<string, AstImport> = new Map<string, AstImport>();\r\n\r\n  public constructor(\r\n    program: ts.Program,\r\n    typeChecker: ts.TypeChecker,\r\n    bundledPackageNames: ReadonlySet<string>,\r\n    astSymbolTable: IAstSymbolTable\r\n  ) {\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n    this._bundledPackageNames = bundledPackageNames;\r\n    this._astSymbolTable = astSymbolTable;\r\n  }\r\n\r\n  /**\r\n   * For a given source file, this analyzes all of its exports and produces an AstModule object.\r\n   *\r\n   * @param moduleReference - contextual information about the import statement that took us to this source file.\r\n   * or `undefined` if this source file is the initial entry point\r\n   */\r\n  public fetchAstModuleFromSourceFile(\r\n    sourceFile: ts.SourceFile,\r\n    moduleReference: IAstModuleReference | undefined\r\n  ): AstModule {\r\n    const moduleSymbol: ts.Symbol = this._getModuleSymbolFromSourceFile(sourceFile, moduleReference);\r\n\r\n    // Don't traverse into a module that we already processed before:\r\n    // The compiler allows m1 to have \"export * from 'm2'\" and \"export * from 'm3'\",\r\n    // even if m2 and m3 both have \"export * from 'm4'\".\r\n    let astModule: AstModule | undefined = this._astModulesByModuleSymbol.get(moduleSymbol);\r\n    if (!astModule) {\r\n      // (If moduleReference === undefined, then this is the entry point of the local project being analyzed.)\r\n      let externalModulePath: string | undefined = undefined;\r\n      if (moduleReference !== undefined) {\r\n        // Match:       \"@microsoft/sp-lodash-subset\" or \"lodash/has\"\r\n        // but ignore:  \"../folder/LocalFile\"\r\n        if (this._isExternalModulePath(moduleReference.moduleSpecifier)) {\r\n          externalModulePath = moduleReference.moduleSpecifier;\r\n        }\r\n      }\r\n\r\n      astModule = new AstModule({ sourceFile, moduleSymbol, externalModulePath });\r\n\r\n      this._astModulesByModuleSymbol.set(moduleSymbol, astModule);\r\n\r\n      if (astModule.isExternal) {\r\n        // It's an external package, so do the special simplified analysis that doesn't crawl into referenced modules\r\n        for (const exportedSymbol of this._typeChecker.getExportsOfModule(moduleSymbol)) {\r\n          if (externalModulePath === undefined) {\r\n            throw new InternalError(\r\n              'Failed assertion: externalModulePath=undefined but astModule.isExternal=true'\r\n            );\r\n          }\r\n\r\n          const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(\r\n            exportedSymbol,\r\n            this._typeChecker\r\n          );\r\n\r\n          // Ignore virtual symbols that don't have any declarations\r\n          const arbitraryDeclaration: ts.Declaration | undefined =\r\n            TypeScriptHelpers.tryGetADeclaration(followedSymbol);\r\n          if (arbitraryDeclaration) {\r\n            const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\r\n              followedSymbol: followedSymbol,\r\n              isExternal: astModule.isExternal,\r\n              includeNominalAnalysis: true,\r\n              addIfMissing: true\r\n            });\r\n\r\n            if (!astSymbol) {\r\n              throw new Error(\r\n                `Unsupported export ${JSON.stringify(exportedSymbol.name)}:\\n` +\r\n                  SourceFileLocationFormatter.formatDeclaration(arbitraryDeclaration)\r\n              );\r\n            }\r\n\r\n            astModule.cachedExportedEntities.set(exportedSymbol.name, astSymbol);\r\n          }\r\n        }\r\n      } else {\r\n        // The module is part of the local project, so do the full analysis\r\n\r\n        if (moduleSymbol.exports) {\r\n          // The \"export * from 'module-name';\" declarations are all attached to a single virtual symbol\r\n          // whose name is InternalSymbolName.ExportStar\r\n          const exportStarSymbol: ts.Symbol | undefined = moduleSymbol.exports.get(\r\n            ts.InternalSymbolName.ExportStar\r\n          );\r\n          if (exportStarSymbol) {\r\n            for (const exportStarDeclaration of exportStarSymbol.getDeclarations() || []) {\r\n              if (ts.isExportDeclaration(exportStarDeclaration)) {\r\n                const starExportedModule: AstModule | undefined = this._fetchSpecifierAstModule(\r\n                  exportStarDeclaration,\r\n                  exportStarSymbol\r\n                );\r\n\r\n                if (starExportedModule !== undefined) {\r\n                  astModule.starExportedModules.add(starExportedModule);\r\n                }\r\n              } else {\r\n                // Ignore ExportDeclaration nodes that don't match the expected pattern\r\n                // TODO: Should we report a warning?\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return astModule;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the symbol for the module corresponding to the ts.SourceFile that is being imported/exported.\r\n   *\r\n   * @remarks\r\n   * The `module` keyword can be used to declare multiple TypeScript modules inside a single source file.\r\n   * (This is a deprecated construct and mainly used for typings such as `@types/node`.)  In this situation,\r\n   * `moduleReference` helps us to fish out the correct module symbol.\r\n   */\r\n  private _getModuleSymbolFromSourceFile(\r\n    sourceFile: ts.SourceFile,\r\n    moduleReference: IAstModuleReference | undefined\r\n  ): ts.Symbol {\r\n    const moduleSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\r\n      sourceFile,\r\n      this._typeChecker\r\n    );\r\n    if (moduleSymbol !== undefined) {\r\n      // This is the normal case.  The SourceFile acts is a module and has a symbol.\r\n      return moduleSymbol;\r\n    }\r\n\r\n    if (moduleReference !== undefined) {\r\n      // But there is also an elaborate case where the source file contains one or more \"module\" declarations,\r\n      // and our moduleReference took us to one of those.\r\n\r\n      // eslint-disable-next-line no-bitwise\r\n      if ((moduleReference.moduleSpecifierSymbol.flags & ts.SymbolFlags.Alias) !== 0) {\r\n        // Follow the import/export declaration to one hop the exported item inside the target module\r\n        let followedSymbol: ts.Symbol | undefined = TypeScriptInternals.getImmediateAliasedSymbol(\r\n          moduleReference.moduleSpecifierSymbol,\r\n          this._typeChecker\r\n        );\r\n\r\n        if (followedSymbol === undefined) {\r\n          // This is a workaround for a compiler bug where getImmediateAliasedSymbol() sometimes returns undefined\r\n          followedSymbol = this._typeChecker.getAliasedSymbol(moduleReference.moduleSpecifierSymbol);\r\n        }\r\n\r\n        if (followedSymbol !== undefined && followedSymbol !== moduleReference.moduleSpecifierSymbol) {\r\n          // The parent of the exported symbol will be the module that we're importing from\r\n          const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(followedSymbol);\r\n          if (parent !== undefined) {\r\n            // Make sure the thing we found is a module\r\n            // eslint-disable-next-line no-bitwise\r\n            if ((parent.flags & ts.SymbolFlags.ValueModule) !== 0) {\r\n              // Record that that this is an ambient module that can also be imported from\r\n              this._importableAmbientSourceFiles.add(sourceFile);\r\n              return parent;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    throw new InternalError('Unable to determine module for: ' + sourceFile.fileName);\r\n  }\r\n\r\n  /**\r\n   * Implementation of {@link AstSymbolTable.fetchAstModuleExportInfo}.\r\n   */\r\n  public fetchAstModuleExportInfo(entryPointAstModule: AstModule): AstModuleExportInfo {\r\n    if (entryPointAstModule.isExternal) {\r\n      throw new Error('fetchAstModuleExportInfo() is not supported for external modules');\r\n    }\r\n\r\n    if (entryPointAstModule.astModuleExportInfo === undefined) {\r\n      const astModuleExportInfo: AstModuleExportInfo = new AstModuleExportInfo();\r\n\r\n      this._collectAllExportsRecursive(astModuleExportInfo, entryPointAstModule, new Set<AstModule>());\r\n\r\n      entryPointAstModule.astModuleExportInfo = astModuleExportInfo;\r\n    }\r\n    return entryPointAstModule.astModuleExportInfo;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the module specifier refers to an external package.  Ignores packages listed in the\r\n   * \"bundledPackages\" setting from the api-extractor.json config file.\r\n   *\r\n   * @remarks\r\n   * Examples:\r\n   *\r\n   * - NO:  `./file1`\r\n   * - YES: `library1/path/path`\r\n   * - YES: `@my-scope/my-package`\r\n   */\r\n  private _isExternalModulePath(moduleSpecifier: string): boolean {\r\n    if (ts.isExternalModuleNameRelative(moduleSpecifier)) {\r\n      return false;\r\n    }\r\n\r\n    const match: RegExpExecArray | null = ExportAnalyzer._modulePathRegExp.exec(moduleSpecifier);\r\n    if (match) {\r\n      // Extract \"@my-scope/my-package\" from \"@my-scope/my-package/path/module\"\r\n      const packageName: string = match[1];\r\n      if (this._bundledPackageNames.has(packageName)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns true if when we analyzed sourceFile, we found that it contains an \"export=\" statement that allows\r\n   * it to behave /either/ as an ambient module /or/ as a regular importable module.  In this case,\r\n   * `AstSymbolTable._fetchAstSymbol()` will analyze its symbols even though `TypeScriptHelpers.isAmbient()`\r\n   * returns true.\r\n   */\r\n  public isImportableAmbientSourceFile(sourceFile: ts.SourceFile): boolean {\r\n    return this._importableAmbientSourceFiles.has(sourceFile);\r\n  }\r\n\r\n  private _collectAllExportsRecursive(\r\n    astModuleExportInfo: AstModuleExportInfo,\r\n    astModule: AstModule,\r\n    visitedAstModules: Set<AstModule>\r\n  ): void {\r\n    if (visitedAstModules.has(astModule)) {\r\n      return;\r\n    }\r\n    visitedAstModules.add(astModule);\r\n\r\n    if (astModule.isExternal) {\r\n      astModuleExportInfo.starExportedExternalModules.add(astModule);\r\n    } else {\r\n      // Fetch each of the explicit exports for this module\r\n      if (astModule.moduleSymbol.exports) {\r\n        astModule.moduleSymbol.exports.forEach((exportSymbol, exportName) => {\r\n          switch (exportName) {\r\n            case ts.InternalSymbolName.ExportStar:\r\n            case ts.InternalSymbolName.ExportEquals:\r\n              break;\r\n            default:\r\n              // Don't collect the \"export default\" symbol unless this is the entry point module\r\n              if (exportName !== ts.InternalSymbolName.Default || visitedAstModules.size === 1) {\r\n                if (!astModuleExportInfo.exportedLocalEntities.has(exportSymbol.name)) {\r\n                  const astEntity: AstEntity = this._getExportOfAstModule(exportSymbol.name, astModule);\r\n\r\n                  if (astEntity instanceof AstSymbol && !astEntity.isExternal) {\r\n                    this._astSymbolTable.analyze(astEntity);\r\n                  }\r\n\r\n                  astModuleExportInfo.exportedLocalEntities.set(exportSymbol.name, astEntity);\r\n                }\r\n              }\r\n              break;\r\n          }\r\n        });\r\n      }\r\n\r\n      for (const starExportedModule of astModule.starExportedModules) {\r\n        this._collectAllExportsRecursive(astModuleExportInfo, starExportedModule, visitedAstModules);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a given symbol (which was encountered in the specified sourceFile), this fetches the AstEntity that it\r\n   * refers to.  For example, if a particular interface describes the return value of a function, this API can help\r\n   * us determine a TSDoc declaration reference for that symbol (if the symbol is exported).\r\n   */\r\n  public fetchReferencedAstEntity(\r\n    symbol: ts.Symbol,\r\n    referringModuleIsExternal: boolean\r\n  ): AstEntity | undefined {\r\n    // eslint-disable-next-line no-bitwise\r\n    if ((symbol.flags & ts.SymbolFlags.FunctionScopedVariable) !== 0) {\r\n      // If a symbol refers back to part of its own definition, don't follow that rabbit hole\r\n      // Example:\r\n      //\r\n      // function f(x: number): typeof x {\r\n      //    return 123;\r\n      // }\r\n      return undefined;\r\n    }\r\n\r\n    let current: ts.Symbol = symbol;\r\n\r\n    if (referringModuleIsExternal) {\r\n      current = TypeScriptHelpers.followAliases(symbol, this._typeChecker);\r\n    } else {\r\n      for (;;) {\r\n        // Is this symbol an import/export that we need to follow to find the real declaration?\r\n        for (const declaration of current.declarations || []) {\r\n          let matchedAstEntity: AstEntity | undefined;\r\n          matchedAstEntity = this._tryMatchExportDeclaration(declaration, current);\r\n          if (matchedAstEntity !== undefined) {\r\n            return matchedAstEntity;\r\n          }\r\n          matchedAstEntity = this._tryMatchImportDeclaration(declaration, current);\r\n          if (matchedAstEntity !== undefined) {\r\n            return matchedAstEntity;\r\n          }\r\n        }\r\n\r\n        // eslint-disable-next-line no-bitwise\r\n        if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n          break;\r\n        }\r\n\r\n        const currentAlias: ts.Symbol = TypeScriptInternals.getImmediateAliasedSymbol(\r\n          current,\r\n          this._typeChecker\r\n        );\r\n        // Stop if we reach the end of the chain\r\n        if (!currentAlias || currentAlias === current) {\r\n          break;\r\n        }\r\n\r\n        current = currentAlias;\r\n      }\r\n    }\r\n\r\n    // Otherwise, assume it is a normal declaration\r\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\r\n      followedSymbol: current,\r\n      isExternal: referringModuleIsExternal,\r\n      includeNominalAnalysis: false,\r\n      addIfMissing: true\r\n    });\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  public fetchReferencedAstEntityFromImportTypeNode(\r\n    node: ts.ImportTypeNode,\r\n    referringModuleIsExternal: boolean\r\n  ): AstEntity | undefined {\r\n    const externalModulePath: string | undefined = this._tryGetExternalModulePath(node);\r\n\r\n    if (externalModulePath) {\r\n      return this._fetchAstImport(undefined, {\r\n        importKind: AstImportKind.ImportType,\r\n        exportName: node.qualifier ? node.qualifier.getText().trim() : undefined,\r\n        modulePath: externalModulePath,\r\n        isTypeOnly: false\r\n      });\r\n    }\r\n\r\n    // Internal reference: AstSymbol\r\n    const rightMostToken: ts.Identifier | ts.ImportTypeNode = node.qualifier\r\n      ? node.qualifier.kind === ts.SyntaxKind.QualifiedName\r\n        ? node.qualifier.right\r\n        : node.qualifier\r\n      : node;\r\n\r\n    // There is no symbol property in a ImportTypeNode, obtain the associated export symbol\r\n    const exportSymbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(rightMostToken);\r\n    if (!exportSymbol) {\r\n      throw new Error('Symbol not found for identifier: ' + node.getText());\r\n    }\r\n\r\n    let followedSymbol: ts.Symbol = exportSymbol;\r\n    for (;;) {\r\n      const referencedAstEntity: AstEntity | undefined = this.fetchReferencedAstEntity(\r\n        followedSymbol,\r\n        referringModuleIsExternal\r\n      );\r\n\r\n      if (referencedAstEntity) {\r\n        return referencedAstEntity;\r\n      }\r\n\r\n      const followedSymbolNode: ts.Node | ts.ImportTypeNode | undefined =\r\n        followedSymbol.declarations && (followedSymbol.declarations[0] as ts.Node | undefined);\r\n\r\n      if (followedSymbolNode && followedSymbolNode.kind === ts.SyntaxKind.ImportType) {\r\n        return this.fetchReferencedAstEntityFromImportTypeNode(\r\n          followedSymbolNode as ts.ImportTypeNode,\r\n          referringModuleIsExternal\r\n        );\r\n      }\r\n\r\n      // eslint-disable-next-line no-bitwise\r\n      if (!(followedSymbol.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n\r\n      const currentAlias: ts.Symbol = this._typeChecker.getAliasedSymbol(followedSymbol);\r\n      if (!currentAlias || currentAlias === followedSymbol) {\r\n        break;\r\n      }\r\n\r\n      followedSymbol = currentAlias;\r\n    }\r\n\r\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\r\n      followedSymbol: followedSymbol,\r\n      isExternal: referringModuleIsExternal,\r\n      includeNominalAnalysis: false,\r\n      addIfMissing: true\r\n    });\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  private _tryMatchExportDeclaration(\r\n    declaration: ts.Declaration,\r\n    declarationSymbol: ts.Symbol\r\n  ): AstEntity | undefined {\r\n    const exportDeclaration: ts.ExportDeclaration | undefined =\r\n      TypeScriptHelpers.findFirstParent<ts.ExportDeclaration>(declaration, ts.SyntaxKind.ExportDeclaration);\r\n\r\n    if (exportDeclaration) {\r\n      let exportName: string | undefined = undefined;\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ExportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"export { A } from './file-a';\"\r\n        //\r\n        // ExportDeclaration:\r\n        //   ExportKeyword:  pre=[export] sep=[ ]\r\n        //   NamedExports:\r\n        //     FirstPunctuation:  pre=[{] sep=[ ]\r\n        //     SyntaxList:\r\n        //       ExportSpecifier:  <------------- declaration\r\n        //         Identifier:  pre=[A] sep=[ ]\r\n        //     CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./file-a']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const exportSpecifier: ts.ExportSpecifier = declaration as ts.ExportSpecifier;\r\n        exportName = (exportSpecifier.propertyName || exportSpecifier.name).getText().trim();\r\n      } else {\r\n        throw new InternalError(\r\n          `Unimplemented export declaration kind: ${declaration.getText()}\\n` +\r\n            SourceFileLocationFormatter.formatDeclaration(declaration)\r\n        );\r\n      }\r\n\r\n      // Ignore \"export { A }\" without a module specifier\r\n      if (exportDeclaration.moduleSpecifier) {\r\n        const externalModulePath: string | undefined = this._tryGetExternalModulePath(\r\n          exportDeclaration,\r\n          declarationSymbol\r\n        );\r\n\r\n        if (externalModulePath !== undefined) {\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.NamedImport,\r\n            modulePath: externalModulePath,\r\n            exportName: exportName,\r\n            isTypeOnly: false\r\n          });\r\n        }\r\n\r\n        return this._getExportOfSpecifierAstModule(exportName, exportDeclaration, declarationSymbol);\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private _tryMatchImportDeclaration(\r\n    declaration: ts.Declaration,\r\n    declarationSymbol: ts.Symbol\r\n  ): AstEntity | undefined {\r\n    const importDeclaration: ts.ImportDeclaration | undefined =\r\n      TypeScriptHelpers.findFirstParent<ts.ImportDeclaration>(declaration, ts.SyntaxKind.ImportDeclaration);\r\n\r\n    if (importDeclaration) {\r\n      const externalModulePath: string | undefined = this._tryGetExternalModulePath(\r\n        importDeclaration,\r\n        declarationSymbol\r\n      );\r\n\r\n      if (declaration.kind === ts.SyntaxKind.NamespaceImport) {\r\n        // EXAMPLE:\r\n        // \"import * as theLib from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamespaceImport:  <------------- declaration\r\n        //       AsteriskToken:  pre=[*] sep=[ ]\r\n        //       AsKeyword:  pre=[as] sep=[ ]\r\n        //       Identifier:  pre=[theLib] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        if (externalModulePath === undefined) {\r\n          // The implementation here only works when importing from an external module.\r\n          // The full solution is tracked by: https://github.com/microsoft/rushstack/issues/1029\r\n          throw new Error(\r\n            '\"import * as ___ from ___;\" is not supported yet for local files.\\n' +\r\n              SourceFileLocationFormatter.formatDeclaration(importDeclaration)\r\n          );\r\n        }\r\n\r\n        // Here importSymbol=undefined because {@inheritDoc} and such are not going to work correctly for\r\n        // a package or source file.\r\n        return this._fetchAstImport(undefined, {\r\n          importKind: AstImportKind.StarImport,\r\n          exportName: declarationSymbol.name,\r\n          modulePath: externalModulePath,\r\n          isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\r\n        });\r\n      }\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ImportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"import { A, B } from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:  <------------- declaration\r\n        //           Identifier:  pre=[A]\r\n        //         CommaToken:  pre=[,] sep=[ ]\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const importSpecifier: ts.ImportSpecifier = declaration as ts.ImportSpecifier;\r\n        const exportName: string = (importSpecifier.propertyName || importSpecifier.name).getText().trim();\r\n\r\n        if (externalModulePath !== undefined) {\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.NamedImport,\r\n            modulePath: externalModulePath,\r\n            exportName: exportName,\r\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\r\n          });\r\n        }\r\n\r\n        return this._getExportOfSpecifierAstModule(exportName, importDeclaration, declarationSymbol);\r\n      } else if (declaration.kind === ts.SyntaxKind.ImportClause) {\r\n        // EXAMPLE:\r\n        // \"import A, { B } from './A';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:  <------------- declaration (referring to A)\r\n        //     Identifier:  pre=[A]\r\n        //     CommaToken:  pre=[,] sep=[ ]\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./A']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        const importClause: ts.ImportClause = declaration as ts.ImportClause;\r\n        const exportName: string = importClause.name\r\n          ? importClause.name.getText().trim()\r\n          : ts.InternalSymbolName.Default;\r\n\r\n        if (externalModulePath !== undefined) {\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.DefaultImport,\r\n            modulePath: externalModulePath,\r\n            exportName,\r\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\r\n          });\r\n        }\r\n\r\n        return this._getExportOfSpecifierAstModule(\r\n          ts.InternalSymbolName.Default,\r\n          importDeclaration,\r\n          declarationSymbol\r\n        );\r\n      } else {\r\n        throw new InternalError(\r\n          `Unimplemented import declaration kind: ${declaration.getText()}\\n` +\r\n            SourceFileLocationFormatter.formatDeclaration(declaration)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (ts.isImportEqualsDeclaration(declaration)) {\r\n      // EXAMPLE:\r\n      // import myLib = require('my-lib');\r\n      //\r\n      // ImportEqualsDeclaration:\r\n      //   ImportKeyword:  pre=[import] sep=[ ]\r\n      //   Identifier:  pre=[myLib] sep=[ ]\r\n      //   FirstAssignment:  pre=[=] sep=[ ]\r\n      //   ExternalModuleReference:\r\n      //     RequireKeyword:  pre=[require]\r\n      //     OpenParenToken:  pre=[(]\r\n      //     StringLiteral:  pre=['my-lib']\r\n      //     CloseParenToken:  pre=[)]\r\n      //   SemicolonToken:  pre=[;]\r\n      if (ts.isExternalModuleReference(declaration.moduleReference)) {\r\n        if (ts.isStringLiteralLike(declaration.moduleReference.expression)) {\r\n          const variableName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(declaration.name);\r\n          const externalModuleName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(\r\n            declaration.moduleReference.expression\r\n          );\r\n\r\n          return this._fetchAstImport(declarationSymbol, {\r\n            importKind: AstImportKind.EqualsImport,\r\n            modulePath: externalModuleName,\r\n            exportName: variableName,\r\n            isTypeOnly: false\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private static _getIsTypeOnly(importDeclaration: ts.ImportDeclaration): boolean {\r\n    if (importDeclaration.importClause) {\r\n      return !!importDeclaration.importClause.isTypeOnly;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _getExportOfSpecifierAstModule(\r\n    exportName: string,\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\r\n    exportSymbol: ts.Symbol\r\n  ): AstEntity {\r\n    const specifierAstModule: AstModule = this._fetchSpecifierAstModule(\r\n      importOrExportDeclaration,\r\n      exportSymbol\r\n    );\r\n    const astEntity: AstEntity = this._getExportOfAstModule(exportName, specifierAstModule);\r\n    return astEntity;\r\n  }\r\n\r\n  private _getExportOfAstModule(exportName: string, astModule: AstModule): AstEntity {\r\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\r\n    const astEntity: AstEntity | undefined = this._tryGetExportOfAstModule(\r\n      exportName,\r\n      astModule,\r\n      visitedAstModules\r\n    );\r\n    if (astEntity === undefined) {\r\n      throw new InternalError(\r\n        `Unable to analyze the export ${JSON.stringify(exportName)} in\\n` + astModule.sourceFile.fileName\r\n      );\r\n    }\r\n    return astEntity;\r\n  }\r\n\r\n  /**\r\n   * Implementation of {@link AstSymbolTable.tryGetExportOfAstModule}.\r\n   */\r\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\r\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\r\n    return this._tryGetExportOfAstModule(exportName, astModule, visitedAstModules);\r\n  }\r\n\r\n  private _tryGetExportOfAstModule(\r\n    exportName: string,\r\n    astModule: AstModule,\r\n    visitedAstModules: Set<AstModule>\r\n  ): AstEntity | undefined {\r\n    if (visitedAstModules.has(astModule)) {\r\n      return undefined;\r\n    }\r\n    visitedAstModules.add(astModule);\r\n\r\n    let astEntity: AstEntity | undefined = astModule.cachedExportedEntities.get(exportName);\r\n    if (astEntity !== undefined) {\r\n      return astEntity;\r\n    }\r\n\r\n    // Try the explicit exports\r\n    const escapedExportName: ts.__String = ts.escapeLeadingUnderscores(exportName);\r\n    if (astModule.moduleSymbol.exports) {\r\n      const exportSymbol: ts.Symbol | undefined = astModule.moduleSymbol.exports.get(escapedExportName);\r\n      if (exportSymbol) {\r\n        astEntity = this.fetchReferencedAstEntity(exportSymbol, astModule.isExternal);\r\n\r\n        if (astEntity !== undefined) {\r\n          astModule.cachedExportedEntities.set(exportName, astEntity); // cache for next time\r\n          return astEntity;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Try each of the star imports\r\n    for (const starExportedModule of astModule.starExportedModules) {\r\n      astEntity = this._tryGetExportOfAstModule(exportName, starExportedModule, visitedAstModules);\r\n\r\n      if (astEntity !== undefined) {\r\n        if (starExportedModule.externalModulePath !== undefined) {\r\n          // This entity was obtained from an external module, so return an AstImport instead\r\n          const astSymbol: AstSymbol = astEntity as AstSymbol;\r\n          return this._fetchAstImport(astSymbol.followedSymbol, {\r\n            importKind: AstImportKind.NamedImport,\r\n            modulePath: starExportedModule.externalModulePath,\r\n            exportName: exportName,\r\n            isTypeOnly: false\r\n          });\r\n        }\r\n\r\n        return astEntity;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private _tryGetExternalModulePath(\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode,\r\n    exportSymbol?: ts.Symbol\r\n  ): string | undefined {\r\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\r\n    const moduleSpecifier: string | undefined =\r\n      TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\r\n    if (!moduleSpecifier) {\r\n      throw new InternalError(\r\n        'Unable to parse module specifier\\n' +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    // Match:       \"@microsoft/sp-lodash-subset\" or \"lodash/has\"\r\n    // but ignore:  \"../folder/LocalFile\"\r\n    if (this._isExternalModulePath(moduleSpecifier)) {\r\n      return moduleSpecifier;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Given an ImportDeclaration of the form `export { X } from \"___\";`, this interprets the module specifier (`\"___\"`)\r\n   * and fetches the corresponding AstModule object.\r\n   */\r\n  private _fetchSpecifierAstModule(\r\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\r\n    exportSymbol: ts.Symbol\r\n  ): AstModule {\r\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\r\n    const moduleSpecifier: string | undefined =\r\n      TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\r\n    if (!moduleSpecifier) {\r\n      throw new InternalError(\r\n        'Unable to parse module specifier\\n' +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\r\n      importOrExportDeclaration.getSourceFile(),\r\n      moduleSpecifier\r\n    );\r\n\r\n    if (resolvedModule === undefined) {\r\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\r\n      // found in export declarations for this source file\r\n      //\r\n      // Encountered in https://github.com/microsoft/rushstack/issues/1914\r\n      throw new InternalError(\r\n        `getResolvedModule() could not resolve module name ${JSON.stringify(moduleSpecifier)}\\n` +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    // Map the filename back to the corresponding SourceFile. This circuitous approach is needed because\r\n    // we have no way to access the compiler's internal resolveExternalModuleName() function\r\n    const moduleSourceFile: ts.SourceFile | undefined = this._program.getSourceFile(\r\n      resolvedModule.resolvedFileName\r\n    );\r\n    if (!moduleSourceFile) {\r\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\r\n      // found in export declarations for this source file\r\n      throw new InternalError(\r\n        `getSourceFile() failed to locate ${JSON.stringify(resolvedModule.resolvedFileName)}\\n` +\r\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\r\n      );\r\n    }\r\n\r\n    const moduleReference: IAstModuleReference = {\r\n      moduleSpecifier: moduleSpecifier,\r\n      moduleSpecifierSymbol: exportSymbol\r\n    };\r\n    const specifierAstModule: AstModule = this.fetchAstModuleFromSourceFile(\r\n      moduleSourceFile,\r\n      moduleReference\r\n    );\r\n\r\n    return specifierAstModule;\r\n  }\r\n\r\n  private _fetchAstImport(importSymbol: ts.Symbol | undefined, options: IAstImportOptions): AstImport {\r\n    const key: string = AstImport.getKey(options);\r\n\r\n    let astImport: AstImport | undefined = this._astImportsByKey.get(key);\r\n\r\n    if (!astImport) {\r\n      astImport = new AstImport(options);\r\n      this._astImportsByKey.set(key, astImport);\r\n\r\n      if (importSymbol) {\r\n        const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(importSymbol, this._typeChecker);\r\n\r\n        astImport.astSymbol = this._astSymbolTable.fetchAstSymbol({\r\n          followedSymbol: followedSymbol,\r\n          isExternal: true,\r\n          includeNominalAnalysis: false,\r\n          addIfMissing: true\r\n        });\r\n      }\r\n    } else {\r\n      // If we encounter at least one import that does not use the type-only form,\r\n      // then the .d.ts rollup will NOT use \"import type\".\r\n      if (!options.isTypeOnly) {\r\n        astImport.isTypeOnlyEverywhere = false;\r\n      }\r\n    }\r\n\r\n    return astImport;\r\n  }\r\n}\r\n"]}