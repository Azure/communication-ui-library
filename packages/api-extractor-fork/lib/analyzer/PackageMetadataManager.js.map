{"version":3,"file":"PackageMetadataManager.js","sourceRoot":"","sources":["../../src/analyzer/PackageMetadataManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\n\r\nimport {\r\n  PackageJsonLookup,\r\n  FileSystem,\r\n  JsonFile,\r\n  NewlineKind,\r\n  INodePackageJson,\r\n  JsonObject\r\n} from '@rushstack/node-core-library';\r\nimport { Extractor } from '../api/Extractor';\r\nimport { MessageRouter } from '../collector/MessageRouter';\r\nimport { ConsoleMessageId } from '../api/ConsoleMessageId';\r\n\r\n/**\r\n * Represents analyzed information for a package.json file.\r\n * This object is constructed and returned by PackageMetadataManager.\r\n */\r\nexport class PackageMetadata {\r\n  /**\r\n   * The absolute path to the package.json file being analyzed.\r\n   */\r\n  public readonly packageJsonPath: string;\r\n  /**\r\n   * The parsed contents of package.json.  Note that PackageJsonLookup\r\n   * only includes essential fields.\r\n   */\r\n  public readonly packageJson: INodePackageJson;\r\n  /**\r\n   * If true, then the package's documentation comments can be assumed\r\n   * to contain API Extractor compatible TSDoc tags.\r\n   */\r\n  public readonly aedocSupported: boolean;\r\n\r\n  public constructor(packageJsonPath: string, packageJson: INodePackageJson, aedocSupported: boolean) {\r\n    this.packageJsonPath = packageJsonPath;\r\n    this.packageJson = packageJson;\r\n    this.aedocSupported = aedocSupported;\r\n  }\r\n}\r\n\r\n/**\r\n * This class maintains a cache of analyzed information obtained from package.json\r\n * files.  It is built on top of the PackageJsonLookup class.\r\n *\r\n * @remarks\r\n *\r\n * IMPORTANT: Don't use PackageMetadataManager to analyze source files from the current project:\r\n * 1. Files such as tsdoc-metadata.json may not have been built yet, and thus may contain incorrect information.\r\n * 2. The current project is not guaranteed to have a package.json file at all.  For example, API Extractor can\r\n *    be invoked on a bare .d.ts file.\r\n *\r\n * Use ts.program.isSourceFileFromExternalLibrary() to test source files before passing the to PackageMetadataManager.\r\n */\r\nexport class PackageMetadataManager {\r\n  public static tsdocMetadataFilename: string = 'tsdoc-metadata.json';\r\n\r\n  private readonly _packageJsonLookup: PackageJsonLookup;\r\n  private readonly _messageRouter: MessageRouter;\r\n  private readonly _packageMetadataByPackageJsonPath: Map<string, PackageMetadata> = new Map<\r\n    string,\r\n    PackageMetadata\r\n  >();\r\n\r\n  public constructor(packageJsonLookup: PackageJsonLookup, messageRouter: MessageRouter) {\r\n    this._packageJsonLookup = packageJsonLookup;\r\n    this._messageRouter = messageRouter;\r\n  }\r\n\r\n  // This feature is still being standardized: https://github.com/microsoft/tsdoc/issues/7\r\n  // In the future we will use the @microsoft/tsdoc library to read this file.\r\n  private static _resolveTsdocMetadataPathFromPackageJson(\r\n    packageFolder: string,\r\n    packageJson: INodePackageJson\r\n  ): string {\r\n    const tsdocMetadataFilename: string = PackageMetadataManager.tsdocMetadataFilename;\r\n\r\n    let tsdocMetadataRelativePath: string;\r\n\r\n    if (packageJson.tsdocMetadata) {\r\n      // 1. If package.json contains a field such as \"tsdocMetadata\": \"./path1/path2/tsdoc-metadata.json\",\r\n      // then that takes precedence.  This convention will be rarely needed, since the other rules below generally\r\n      // produce a good result.\r\n      tsdocMetadataRelativePath = packageJson.tsdocMetadata;\r\n    } else if (packageJson.typings) {\r\n      // 2. If package.json contains a field such as \"typings\": \"./path1/path2/index.d.ts\", then we look\r\n      // for the file under \"./path1/path2/tsdoc-metadata.json\"\r\n      tsdocMetadataRelativePath = path.join(path.dirname(packageJson.typings), tsdocMetadataFilename);\r\n    } else if (packageJson.main) {\r\n      // 3. If package.json contains a field such as \"main\": \"./path1/path2/index.js\", then we look for\r\n      // the file under \"./path1/path2/tsdoc-metadata.json\"\r\n      tsdocMetadataRelativePath = path.join(path.dirname(packageJson.main), tsdocMetadataFilename);\r\n    } else {\r\n      // 4. If none of the above rules apply, then by default we look for the file under \"./tsdoc-metadata.json\"\r\n      // since the default entry point is \"./index.js\"\r\n      tsdocMetadataRelativePath = tsdocMetadataFilename;\r\n    }\r\n\r\n    // Always resolve relative to the package folder.\r\n    const tsdocMetadataPath: string = path.resolve(packageFolder, tsdocMetadataRelativePath);\r\n    return tsdocMetadataPath;\r\n  }\r\n\r\n  /**\r\n   * @param tsdocMetadataPath - An explicit path that can be configured in api-extractor.json.\r\n   * If this parameter is not an empty string, it overrides the normal path calculation.\r\n   * @returns the absolute path to the TSDoc metadata file\r\n   */\r\n  public static resolveTsdocMetadataPath(\r\n    packageFolder: string,\r\n    packageJson: INodePackageJson,\r\n    tsdocMetadataPath?: string\r\n  ): string {\r\n    if (tsdocMetadataPath) {\r\n      return path.resolve(packageFolder, tsdocMetadataPath);\r\n    }\r\n    return PackageMetadataManager._resolveTsdocMetadataPathFromPackageJson(packageFolder, packageJson);\r\n  }\r\n\r\n  /**\r\n   * Writes the TSDoc metadata file to the specified output file.\r\n   */\r\n  public static writeTsdocMetadataFile(tsdocMetadataPath: string, newlineKind: NewlineKind): void {\r\n    const fileObject: JsonObject = {\r\n      tsdocVersion: '0.12',\r\n      toolPackages: [\r\n        {\r\n          packageName: '@microsoft/api-extractor',\r\n          packageVersion: Extractor.version\r\n        }\r\n      ]\r\n    };\r\n\r\n    const fileContent: string =\r\n      '// This file is read by tools that parse documentation comments conforming to the TSDoc standard.\\n' +\r\n      '// It should be published with your NPM package.  It should not be tracked by Git.\\n' +\r\n      JsonFile.stringify(fileObject);\r\n\r\n    FileSystem.writeFile(tsdocMetadataPath, fileContent, {\r\n      convertLineEndings: newlineKind,\r\n      ensureFolderExists: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds the package.json in a parent folder of the specified source file, and\r\n   * returns a PackageMetadata object.  If no package.json was found, then undefined\r\n   * is returned.  The results are cached.\r\n   */\r\n  public tryFetchPackageMetadata(sourceFilePath: string): PackageMetadata | undefined {\r\n    const packageJsonFilePath: string | undefined =\r\n      this._packageJsonLookup.tryGetPackageJsonFilePathFor(sourceFilePath);\r\n    if (!packageJsonFilePath) {\r\n      return undefined;\r\n    }\r\n    let packageMetadata: PackageMetadata | undefined =\r\n      this._packageMetadataByPackageJsonPath.get(packageJsonFilePath);\r\n\r\n    if (!packageMetadata) {\r\n      const packageJson: INodePackageJson = this._packageJsonLookup.loadNodePackageJson(packageJsonFilePath);\r\n\r\n      const packageJsonFolder: string = path.dirname(packageJsonFilePath);\r\n\r\n      let aedocSupported: boolean = false;\r\n\r\n      const tsdocMetadataPath: string = PackageMetadataManager._resolveTsdocMetadataPathFromPackageJson(\r\n        packageJsonFolder,\r\n        packageJson\r\n      );\r\n\r\n      if (FileSystem.exists(tsdocMetadataPath)) {\r\n        this._messageRouter.logVerbose(\r\n          ConsoleMessageId.FoundTSDocMetadata,\r\n          'Found metadata in ' + tsdocMetadataPath\r\n        );\r\n        // If the file exists at all, assume it was written by API Extractor\r\n        aedocSupported = true;\r\n      }\r\n\r\n      packageMetadata = new PackageMetadata(packageJsonFilePath, packageJson, aedocSupported);\r\n      this._packageMetadataByPackageJsonPath.set(packageJsonFilePath, packageMetadata);\r\n    }\r\n\r\n    return packageMetadata;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the source file is part of a package whose .d.ts files support AEDoc annotations.\r\n   */\r\n  public isAedocSupportedFor(sourceFilePath: string): boolean {\r\n    const packageMetadata: PackageMetadata | undefined = this.tryFetchPackageMetadata(sourceFilePath);\r\n    if (!packageMetadata) {\r\n      return false;\r\n    }\r\n    return packageMetadata.aedocSupported;\r\n  }\r\n}\r\n"]}