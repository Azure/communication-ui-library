{"version":3,"file":"AstReferenceResolver.js","sourceRoot":"","sources":["../../src/analyzer/AstReferenceResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\n\r\nimport { AstSymbolTable, AstEntity } from './AstSymbolTable';\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { WorkingPackage } from '../collector/WorkingPackage';\r\nimport { AstModule } from './AstModule';\r\nimport { AstImport } from './AstImport';\r\nimport { Collector } from '../collector/Collector';\r\nimport { DeclarationMetadata } from '../collector/DeclarationMetadata';\r\n\r\n/**\r\n * Used by `AstReferenceResolver` to report a failed resolution.\r\n *\r\n * @privateRemarks\r\n * This class is similar to an `Error` object, but the intent of `ResolverFailure` is to describe\r\n * why a reference could not be resolved.  This information could be used to throw an actual `Error` object,\r\n * but normally it is handed off to the `MessageRouter` instead.\r\n */\r\nexport class ResolverFailure {\r\n  /**\r\n   * Details about why the failure occurred.\r\n   */\r\n  public readonly reason: string;\r\n\r\n  public constructor(reason: string) {\r\n    this.reason = reason;\r\n  }\r\n}\r\n\r\n/**\r\n * This resolves a TSDoc declaration reference by walking the `AstSymbolTable` compiler state.\r\n *\r\n * @remarks\r\n *\r\n * This class is analogous to `ModelReferenceResolver` from the `@microsoft/api-extractor-model` project,\r\n * which resolves declaration references by walking the hierarchy loaded from an .api.json file.\r\n */\r\nexport class AstReferenceResolver {\r\n  private readonly _collector: Collector;\r\n  private readonly _astSymbolTable: AstSymbolTable;\r\n  private readonly _workingPackage: WorkingPackage;\r\n\r\n  public constructor(collector: Collector) {\r\n    this._collector = collector;\r\n    this._astSymbolTable = collector.astSymbolTable;\r\n    this._workingPackage = collector.workingPackage;\r\n  }\r\n\r\n  public resolve(declarationReference: tsdoc.DocDeclarationReference): AstDeclaration | ResolverFailure {\r\n    // Is it referring to the working package?\r\n    if (\r\n      declarationReference.packageName !== undefined &&\r\n      declarationReference.packageName !== this._workingPackage.name\r\n    ) {\r\n      return new ResolverFailure('External package references are not supported');\r\n    }\r\n\r\n    // Is it a path-based import?\r\n    if (declarationReference.importPath) {\r\n      return new ResolverFailure('Import paths are not supported');\r\n    }\r\n\r\n    const astModule: AstModule = this._astSymbolTable.fetchAstModuleFromWorkingPackage(\r\n      this._workingPackage.entryPointSourceFile\r\n    );\r\n\r\n    if (declarationReference.memberReferences.length === 0) {\r\n      return new ResolverFailure('Package references are not supported');\r\n    }\r\n\r\n    const rootMemberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[0];\r\n\r\n    const exportName: string | ResolverFailure = this._getMemberReferenceIdentifier(rootMemberReference);\r\n    if (exportName instanceof ResolverFailure) {\r\n      return exportName;\r\n    }\r\n\r\n    const rootAstEntity: AstEntity | undefined = this._astSymbolTable.tryGetExportOfAstModule(\r\n      exportName,\r\n      astModule\r\n    );\r\n\r\n    if (rootAstEntity === undefined) {\r\n      return new ResolverFailure(\r\n        `The package \"${this._workingPackage.name}\" does not have an export \"${exportName}\"`\r\n      );\r\n    }\r\n\r\n    if (rootAstEntity instanceof AstImport) {\r\n      return new ResolverFailure('Reexported declarations are not supported');\r\n    }\r\n\r\n    let currentDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(\r\n      rootAstEntity.astDeclarations,\r\n      rootMemberReference,\r\n      rootAstEntity.localName\r\n    );\r\n\r\n    if (currentDeclaration instanceof ResolverFailure) {\r\n      return currentDeclaration;\r\n    }\r\n\r\n    for (let index: number = 1; index < declarationReference.memberReferences.length; ++index) {\r\n      const memberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[index];\r\n\r\n      const memberName: string | ResolverFailure = this._getMemberReferenceIdentifier(memberReference);\r\n      if (memberName instanceof ResolverFailure) {\r\n        return memberName;\r\n      }\r\n\r\n      const matchingChildren: ReadonlyArray<AstDeclaration> =\r\n        currentDeclaration.findChildrenWithName(memberName);\r\n      if (matchingChildren.length === 0) {\r\n        return new ResolverFailure(`No member was found with name \"${memberName}\"`);\r\n      }\r\n\r\n      const selectedDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(\r\n        matchingChildren,\r\n        memberReference,\r\n        memberName\r\n      );\r\n\r\n      if (selectedDeclaration instanceof ResolverFailure) {\r\n        return selectedDeclaration;\r\n      }\r\n\r\n      currentDeclaration = selectedDeclaration;\r\n    }\r\n\r\n    return currentDeclaration;\r\n  }\r\n\r\n  private _getMemberReferenceIdentifier(memberReference: tsdoc.DocMemberReference): string | ResolverFailure {\r\n    if (memberReference.memberSymbol !== undefined) {\r\n      return new ResolverFailure('ECMAScript symbol selectors are not supported');\r\n    }\r\n    if (memberReference.memberIdentifier === undefined) {\r\n      return new ResolverFailure('The member identifier is missing in the root member reference');\r\n    }\r\n    return memberReference.memberIdentifier.identifier;\r\n  }\r\n\r\n  private _selectDeclaration(\r\n    astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberReference: tsdoc.DocMemberReference,\r\n    astSymbolName: string\r\n  ): AstDeclaration | ResolverFailure {\r\n    const memberSelector: tsdoc.DocMemberSelector | undefined = memberReference.selector;\r\n\r\n    if (memberSelector === undefined) {\r\n      if (astDeclarations.length === 1) {\r\n        return astDeclarations[0];\r\n      } else {\r\n        // If we found multiple matches, but the extra ones are all ancillary declarations,\r\n        // then return the main declaration.\r\n        const nonAncillaryMatch: AstDeclaration | undefined =\r\n          this._tryDisambiguateAncillaryMatches(astDeclarations);\r\n        if (nonAncillaryMatch) {\r\n          return nonAncillaryMatch;\r\n        }\r\n\r\n        return new ResolverFailure(\r\n          `The reference is ambiguous because \"${astSymbolName}\"` +\r\n            ` has more than one declaration; you need to add a TSDoc member reference selector`\r\n        );\r\n      }\r\n    }\r\n\r\n    switch (memberSelector.selectorKind) {\r\n      case tsdoc.SelectorKind.System:\r\n        return this._selectUsingSystemSelector(astDeclarations, memberSelector, astSymbolName);\r\n      case tsdoc.SelectorKind.Index:\r\n        return this._selectUsingIndexSelector(astDeclarations, memberSelector, astSymbolName);\r\n    }\r\n\r\n    return new ResolverFailure(`The selector \"${memberSelector.selector}\" is not a supported selector type`);\r\n  }\r\n\r\n  private _selectUsingSystemSelector(\r\n    astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberSelector: tsdoc.DocMemberSelector,\r\n    astSymbolName: string\r\n  ): AstDeclaration | ResolverFailure {\r\n    const selectorName: string = memberSelector.selector;\r\n\r\n    let selectorSyntaxKind: ts.SyntaxKind;\r\n\r\n    switch (selectorName) {\r\n      case 'class':\r\n        selectorSyntaxKind = ts.SyntaxKind.ClassDeclaration;\r\n        break;\r\n      case 'enum':\r\n        selectorSyntaxKind = ts.SyntaxKind.EnumDeclaration;\r\n        break;\r\n      case 'function':\r\n        selectorSyntaxKind = ts.SyntaxKind.FunctionDeclaration;\r\n        break;\r\n      case 'interface':\r\n        selectorSyntaxKind = ts.SyntaxKind.InterfaceDeclaration;\r\n        break;\r\n      case 'namespace':\r\n        selectorSyntaxKind = ts.SyntaxKind.ModuleDeclaration;\r\n        break;\r\n      case 'type':\r\n        selectorSyntaxKind = ts.SyntaxKind.TypeAliasDeclaration;\r\n        break;\r\n      case 'variable':\r\n        selectorSyntaxKind = ts.SyntaxKind.VariableDeclaration;\r\n        break;\r\n      default:\r\n        return new ResolverFailure(`Unsupported system selector \"${selectorName}\"`);\r\n    }\r\n\r\n    const matches: AstDeclaration[] = astDeclarations.filter(\r\n      (x) => x.declaration.kind === selectorSyntaxKind\r\n    );\r\n    if (matches.length === 0) {\r\n      return new ResolverFailure(\r\n        `A declaration for \"${astSymbolName}\" was not found that matches the` +\r\n          ` TSDoc selector \"${selectorName}\"`\r\n      );\r\n    }\r\n    if (matches.length > 1) {\r\n      // If we found multiple matches, but the extra ones are all ancillary declarations,\r\n      // then return the main declaration.\r\n      const nonAncillaryMatch: AstDeclaration | undefined = this._tryDisambiguateAncillaryMatches(matches);\r\n      if (nonAncillaryMatch) {\r\n        return nonAncillaryMatch;\r\n      }\r\n\r\n      return new ResolverFailure(\r\n        `More than one declaration \"${astSymbolName}\" matches the TSDoc selector \"${selectorName}\"`\r\n      );\r\n    }\r\n    return matches[0];\r\n  }\r\n\r\n  private _selectUsingIndexSelector(\r\n    astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberSelector: tsdoc.DocMemberSelector,\r\n    astSymbolName: string\r\n  ): AstDeclaration | ResolverFailure {\r\n    const selectorOverloadIndex: number = parseInt(memberSelector.selector);\r\n\r\n    const matches: AstDeclaration[] = [];\r\n    for (const astDeclaration of astDeclarations) {\r\n      const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\r\n      if (overloadIndex === selectorOverloadIndex) {\r\n        matches.push(astDeclaration);\r\n      }\r\n    }\r\n\r\n    if (matches.length === 0) {\r\n      return new ResolverFailure(\r\n        `An overload for \"${astSymbolName}\" was not found that matches the` +\r\n          ` TSDoc selector \":${selectorOverloadIndex}\"`\r\n      );\r\n    }\r\n    if (matches.length > 1) {\r\n      // If we found multiple matches, but the extra ones are all ancillary declarations,\r\n      // then return the main declaration.\r\n      const nonAncillaryMatch: AstDeclaration | undefined = this._tryDisambiguateAncillaryMatches(matches);\r\n      if (nonAncillaryMatch) {\r\n        return nonAncillaryMatch;\r\n      }\r\n\r\n      return new ResolverFailure(\r\n        `More than one declaration for \"${astSymbolName}\" matches the` +\r\n          ` TSDoc selector \":${selectorOverloadIndex}\"`\r\n      );\r\n    }\r\n    return matches[0];\r\n  }\r\n\r\n  /**\r\n   * This resolves an ambiguous match in the case where the extra matches are all ancillary declarations,\r\n   * except for one match that is the main declaration.\r\n   */\r\n  private _tryDisambiguateAncillaryMatches(\r\n    matches: ReadonlyArray<AstDeclaration>\r\n  ): AstDeclaration | undefined {\r\n    let result: AstDeclaration | undefined = undefined;\r\n\r\n    for (const match of matches) {\r\n      const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(match);\r\n      if (!declarationMetadata.isAncillary) {\r\n        if (result) {\r\n          return undefined; // more than one match\r\n        }\r\n        result = match;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n"]}