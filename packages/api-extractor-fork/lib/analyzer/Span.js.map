{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/analyzer/Span.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { StringBuilder } from '@microsoft/tsdoc';\r\nimport { Sort } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * Specifies various transformations that will be performed by Span.getModifiedText().\r\n */\r\nexport class SpanModification {\r\n  /**\r\n   * If true, all of the child spans will be omitted from the Span.getModifiedText() output.\r\n   * @remarks\r\n   * Also, the modify() operation will not recurse into these spans.\r\n   */\r\n  public omitChildren: boolean = false;\r\n\r\n  /**\r\n   * If true, then the Span.separator will be removed from the Span.getModifiedText() output.\r\n   */\r\n  public omitSeparatorAfter: boolean = false;\r\n\r\n  /**\r\n   * If true, then Span.getModifiedText() will sort the immediate children according to their Span.sortKey\r\n   * property.  The separators will also be fixed up to ensure correct indentation.  If the Span.sortKey is undefined\r\n   * for some items, those items will not be moved, i.e. their array indexes will be unchanged.\r\n   */\r\n  public sortChildren: boolean = false;\r\n\r\n  /**\r\n   * Used if the parent span has Span.sortChildren=true.\r\n   */\r\n  public sortKey: string | undefined;\r\n\r\n  private readonly _span: Span;\r\n  private _prefix: string | undefined;\r\n  private _suffix: string | undefined;\r\n\r\n  public constructor(span: Span) {\r\n    this._span = span;\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.prefix text to be changed.\r\n   */\r\n  public get prefix(): string {\r\n    return this._prefix !== undefined ? this._prefix : this._span.prefix;\r\n  }\r\n\r\n  public set prefix(value: string) {\r\n    this._prefix = value;\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.suffix text to be changed.\r\n   */\r\n  public get suffix(): string {\r\n    return this._suffix !== undefined ? this._suffix : this._span.suffix;\r\n  }\r\n\r\n  public set suffix(value: string) {\r\n    this._suffix = value;\r\n  }\r\n\r\n  /**\r\n   * Reverts any modifications made to this object.\r\n   */\r\n  public reset(): void {\r\n    this.omitChildren = false;\r\n    this.omitSeparatorAfter = false;\r\n    this.sortChildren = false;\r\n    this.sortKey = undefined;\r\n    this._prefix = undefined;\r\n    this._suffix = undefined;\r\n  }\r\n\r\n  /**\r\n   * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,\r\n   * and setting its prefix/suffix to the empty string.\r\n   */\r\n  public skipAll(): void {\r\n    this.prefix = '';\r\n    this.suffix = '';\r\n    this.omitChildren = true;\r\n    this.omitSeparatorAfter = true;\r\n  }\r\n}\r\n\r\n/**\r\n * The Span class provides a simple way to rewrite TypeScript source files\r\n * based on simple syntax transformations, i.e. without having to process deeper aspects\r\n * of the underlying grammar.  An example transformation might be deleting JSDoc comments\r\n * from a source file.\r\n *\r\n * @remarks\r\n * TypeScript's abstract syntax tree (AST) is represented using Node objects.\r\n * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.\r\n * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though\r\n * the actual comment precedes the function in the input stream.\r\n *\r\n * The Span class is a wrapper for a single Node, that provides access to every character\r\n * in the input stream, such that Span.getText() will exactly reproduce the corresponding\r\n * full Node.getText() output.\r\n *\r\n * A Span is comprised of these parts, which appear in sequential order:\r\n * - A prefix\r\n * - A collection of child spans\r\n * - A suffix\r\n * - A separator (e.g. whitespace between this span and the next item in the tree)\r\n *\r\n * These parts can be modified via Span.modification.  The modification is applied by\r\n * calling Span.getModifiedText().\r\n */\r\nexport class Span {\r\n  public readonly node: ts.Node;\r\n\r\n  // To improve performance, substrings are not allocated until actually needed\r\n  public readonly startIndex: number;\r\n  public readonly endIndex: number;\r\n\r\n  public readonly children: Span[];\r\n\r\n  public readonly modification: SpanModification;\r\n\r\n  private _parent: Span | undefined;\r\n  private _previousSibling: Span | undefined;\r\n  private _nextSibling: Span | undefined;\r\n\r\n  private _separatorStartIndex: number;\r\n  private _separatorEndIndex: number;\r\n\r\n  public constructor(node: ts.Node) {\r\n    this.node = node;\r\n    this.startIndex = node.kind === ts.SyntaxKind.SourceFile ? node.getFullStart() : node.getStart();\r\n    this.endIndex = node.end;\r\n    this._separatorStartIndex = 0;\r\n    this._separatorEndIndex = 0;\r\n    this.children = [];\r\n    this.modification = new SpanModification(this);\r\n\r\n    let previousChildSpan: Span | undefined = undefined;\r\n\r\n    const visitedChildren: Set<ts.Node> = new Set();\r\n\r\n    for (const childNode of this.node.getChildren() || []) {\r\n      // FIX ME: This is a temporary workaround for a problem introduced by TypeScript 4.3.\r\n      // https://github.com/microsoft/TypeScript/issues/44422\r\n      if (visitedChildren.has(childNode)) {\r\n        continue;\r\n      }\r\n      visitedChildren.add(childNode);\r\n\r\n      const childSpan: Span = new Span(childNode);\r\n      childSpan._parent = this;\r\n      childSpan._previousSibling = previousChildSpan;\r\n\r\n      if (previousChildSpan) {\r\n        previousChildSpan._nextSibling = childSpan;\r\n      }\r\n\r\n      this.children.push(childSpan);\r\n\r\n      // Normalize the bounds so that a child is never outside its parent\r\n      if (childSpan.startIndex < this.startIndex) {\r\n        this.startIndex = childSpan.startIndex;\r\n      }\r\n\r\n      if (childSpan.endIndex > this.endIndex) {\r\n        // This has never been observed empirically, but here's how we would handle it\r\n        this.endIndex = childSpan.endIndex;\r\n        throw new Error('Unexpected AST case');\r\n      }\r\n\r\n      if (previousChildSpan) {\r\n        if (previousChildSpan.endIndex < childSpan.startIndex) {\r\n          // There is some leftover text after previous child -- assign it as the separator for\r\n          // the preceding span.  If the preceding span has no suffix, then assign it to the\r\n          // deepest preceding span with no suffix.  This heuristic simplifies the most\r\n          // common transformations, and otherwise it can be fished out using getLastInnerSeparator().\r\n          let separatorRecipient: Span = previousChildSpan;\r\n          while (separatorRecipient.children.length > 0) {\r\n            const lastChild: Span = separatorRecipient.children[separatorRecipient.children.length - 1];\r\n            if (lastChild.endIndex !== separatorRecipient.endIndex) {\r\n              // There is a suffix, so we cannot push the separator any further down, or else\r\n              // it would get printed before this suffix.\r\n              break;\r\n            }\r\n            separatorRecipient = lastChild;\r\n          }\r\n          separatorRecipient._separatorStartIndex = previousChildSpan.endIndex;\r\n          separatorRecipient._separatorEndIndex = childSpan.startIndex;\r\n        }\r\n      }\r\n\r\n      previousChildSpan = childSpan;\r\n    }\r\n  }\r\n\r\n  public get kind(): ts.SyntaxKind {\r\n    return this.node.kind;\r\n  }\r\n\r\n  /**\r\n   * The parent Span, if any.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a parent in the AST.\r\n   */\r\n  public get parent(): Span | undefined {\r\n    return this._parent;\r\n  }\r\n\r\n  /**\r\n   * If the current object is this.parent.children[i], then previousSibling corresponds\r\n   * to this.parent.children[i-1] if it exists.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a previous sibling in the AST.\r\n   */\r\n  public get previousSibling(): Span | undefined {\r\n    return this._previousSibling;\r\n  }\r\n\r\n  /**\r\n   * If the current object is this.parent.children[i], then previousSibling corresponds\r\n   * to this.parent.children[i+1] if it exists.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a previous sibling in the AST.\r\n   */\r\n  public get nextSibling(): Span | undefined {\r\n    return this._nextSibling;\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, up to its first child.\r\n   */\r\n  public get prefix(): string {\r\n    if (this.children.length) {\r\n      // Everything up to the first child\r\n      return this._getSubstring(this.startIndex, this.children[0].startIndex);\r\n    } else {\r\n      return this._getSubstring(this.startIndex, this.endIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, after its last child.\r\n   * If there are no children, this is always an empty string.\r\n   */\r\n  public get suffix(): string {\r\n    if (this.children.length) {\r\n      // Everything after the last child\r\n      return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whitespace that appeared after this node, and before the \"next\" node in the tree.\r\n   * Here we mean \"next\" according to an inorder traversal, not necessarily a sibling.\r\n   */\r\n  public get separator(): string {\r\n    return this._getSubstring(this._separatorStartIndex, this._separatorEndIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()\r\n   * on the last child.\r\n   */\r\n  public getLastInnerSeparator(): string {\r\n    if (this.separator) {\r\n      return this.separator;\r\n    }\r\n    if (this.children.length > 0) {\r\n      return this.children[this.children.length - 1].getLastInnerSeparator();\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\r\n   */\r\n  public findFirstParent(kindToMatch: ts.SyntaxKind): Span | undefined {\r\n    let current: Span | undefined = this;\r\n\r\n    while (current) {\r\n      if (current.kind === kindToMatch) {\r\n        return current;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Starting from the first character of this span, walk backwards until we find the start of the line,\r\n   * and return whitespace after that position.\r\n   *\r\n   * @remarks\r\n   * For example, suppose the character buffer contains this text:\r\n   * ```\r\n   *              1111111111222222\r\n   *  012345 6 7890123456789012345\r\n   * \"line 1\\r\\n  line 2 Example\"\r\n   * ```\r\n   *\r\n   * And suppose the span starts at index 17, i.e. the the \"E\" in example.  The `getIndent()` method would return\r\n   * two spaces corresponding to the range from index 8 through and including index 9.\r\n   */\r\n  public getIndent(): string {\r\n    const buffer: string = this.node.getSourceFile().text;\r\n\r\n    let lineStartIndex: number = 0;\r\n    let firstNonSpaceIndex: number = this.startIndex;\r\n\r\n    let i: number = this.startIndex - 1;\r\n    while (i >= 0) {\r\n      const c: number = buffer.charCodeAt(i);\r\n      if (c === 13 /* \\r */ || c === 10 /* \\n */) {\r\n        lineStartIndex = i + 1;\r\n        break;\r\n      }\r\n      if (c !== 32 /* space */ && c !== 9 /* tab */) {\r\n        // We encountered a non-spacing character, so move the firstNonSpaceIndex backwards\r\n        firstNonSpaceIndex = i;\r\n      }\r\n      --i;\r\n    }\r\n\r\n    return buffer.substring(lineStartIndex, firstNonSpaceIndex);\r\n  }\r\n\r\n  /**\r\n   * Recursively invokes the callback on this Span and all its children.  The callback\r\n   * can make changes to Span.modification for each node.\r\n   */\r\n  public forEach(callback: (span: Span) => void): void {\r\n    callback(this);\r\n    for (const child of this.children) {\r\n      child.forEach(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the original unmodified text represented by this Span.\r\n   */\r\n  public getText(): string {\r\n    let result: string = '';\r\n    result += this.prefix;\r\n\r\n    for (const child of this.children) {\r\n      result += child.getText();\r\n    }\r\n\r\n    result += this.suffix;\r\n    result += this.separator;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the text represented by this Span, after applying all requested modifications.\r\n   */\r\n  public getModifiedText(): string {\r\n    const output: StringBuilder = new StringBuilder();\r\n\r\n    this._writeModifiedText({\r\n      output,\r\n      separatorOverride: undefined\r\n    });\r\n\r\n    return output.toString();\r\n  }\r\n\r\n  public writeModifiedText(output: StringBuilder): void {\r\n    this._writeModifiedText({\r\n      output,\r\n      separatorOverride: undefined\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for\r\n   * each node.\r\n   */\r\n  public getDump(indent: string = ''): string {\r\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\r\n\r\n    if (this.prefix) {\r\n      result += ' pre=[' + this._getTrimmed(this.prefix) + ']';\r\n    }\r\n    if (this.suffix) {\r\n      result += ' suf=[' + this._getTrimmed(this.suffix) + ']';\r\n    }\r\n    if (this.separator) {\r\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\r\n    }\r\n    result += '\\n';\r\n\r\n    for (const child of this.children) {\r\n      result += child.getDump(indent + '  ');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private _writeModifiedText(options: IWriteModifiedTextOptions): void {\r\n    options.output.append(this.modification.prefix);\r\n\r\n    const childCount: number = this.children.length;\r\n\r\n    if (!this.modification.omitChildren) {\r\n      if (this.modification.sortChildren && childCount > 1) {\r\n        // We will only sort the items with a sortKey\r\n        const sortedSubset: Span[] = this.children.filter((x) => x.modification.sortKey !== undefined);\r\n        const sortedSubsetCount: number = sortedSubset.length;\r\n\r\n        // Is there at least one of them?\r\n        if (sortedSubsetCount > 1) {\r\n          // Remember the separator for the first and last ones\r\n          const firstSeparator: string = sortedSubset[0].getLastInnerSeparator();\r\n          const lastSeparator: string = sortedSubset[sortedSubsetCount - 1].getLastInnerSeparator();\r\n\r\n          Sort.sortBy(sortedSubset, (x) => x.modification.sortKey);\r\n\r\n          const childOptions: IWriteModifiedTextOptions = { ...options };\r\n\r\n          let sortedSubsetIndex: number = 0;\r\n          for (let index: number = 0; index < childCount; ++index) {\r\n            let current: Span;\r\n\r\n            // Is this an item that we sorted?\r\n            if (this.children[index].modification.sortKey === undefined) {\r\n              // No, take the next item from the original array\r\n              current = this.children[index];\r\n              childOptions.separatorOverride = undefined;\r\n            } else {\r\n              // Yes, take the next item from the sortedSubset\r\n              current = sortedSubset[sortedSubsetIndex++];\r\n\r\n              if (sortedSubsetIndex < sortedSubsetCount) {\r\n                childOptions.separatorOverride = firstSeparator;\r\n              } else {\r\n                childOptions.separatorOverride = lastSeparator;\r\n              }\r\n            }\r\n\r\n            current._writeModifiedText(childOptions);\r\n          }\r\n\r\n          return;\r\n        }\r\n        // (fall through to the other implementations)\r\n      }\r\n\r\n      if (options.separatorOverride !== undefined) {\r\n        // Special case where the separatorOverride is passed down to the \"last inner separator\" span\r\n        for (let i: number = 0; i < childCount; ++i) {\r\n          const child: Span = this.children[i];\r\n\r\n          if (\r\n            // Only the last child inherits the separatorOverride, because only it can contain\r\n            // the \"last inner separator\" span\r\n            i < childCount - 1 ||\r\n            // If this.separator is specified, then we will write separatorOverride below, so don't pass it along\r\n            this.separator\r\n          ) {\r\n            const childOptions: IWriteModifiedTextOptions = { ...options };\r\n            childOptions.separatorOverride = undefined;\r\n            child._writeModifiedText(childOptions);\r\n          } else {\r\n            child._writeModifiedText(options);\r\n          }\r\n        }\r\n      } else {\r\n        // The normal simple case\r\n        for (const child of this.children) {\r\n          child._writeModifiedText(options);\r\n        }\r\n      }\r\n    }\r\n\r\n    options.output.append(this.modification.suffix);\r\n\r\n    if (options.separatorOverride !== undefined) {\r\n      if (this.separator || childCount === 0) {\r\n        options.output.append(options.separatorOverride);\r\n      }\r\n    } else {\r\n      if (!this.modification.omitSeparatorAfter) {\r\n        options.output.append(this.separator);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _getTrimmed(text: string): string {\r\n    const trimmed: string = text.replace(/\\r?\\n/g, '\\\\n');\r\n\r\n    if (trimmed.length > 100) {\r\n      return trimmed.substr(0, 97) + '...';\r\n    }\r\n    return trimmed;\r\n  }\r\n\r\n  private _getSubstring(startIndex: number, endIndex: number): string {\r\n    if (startIndex === endIndex) {\r\n      return '';\r\n    }\r\n    return this.node.getSourceFile().text.substring(startIndex, endIndex);\r\n  }\r\n}\r\n\r\ninterface IWriteModifiedTextOptions {\r\n  output: StringBuilder;\r\n  separatorOverride: string | undefined;\r\n}\r\n"]}