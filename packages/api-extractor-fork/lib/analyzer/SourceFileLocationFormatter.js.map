{"version":3,"file":"SourceFileLocationFormatter.js","sourceRoot":"","sources":["../../src/analyzer/SourceFileLocationFormatter.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAG3D,2CAA6B;AAC7B,oEAA0D;AAQ1D,MAAa,2BAA2B;IACtC;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,IAAa,EAAE,wBAAiC;QAC9E,MAAM,UAAU,GAAkB,IAAI,CAAC,aAAa,EAAE,CAAC;QACvD,MAAM,gBAAgB,GAAwB,UAAU,CAAC,6BAA6B,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAExG,OAAO,2BAA2B,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE;YACjE,cAAc,EAAE,gBAAgB,CAAC,IAAI,GAAG,CAAC;YACzC,gBAAgB,EAAE,gBAAgB,CAAC,SAAS,GAAG,CAAC;YAChD,wBAAwB;SACzB,CAAC,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,cAAsB,EAAE,OAA0C;QACzF,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,EAAE,CAAC;SACd;QAED,IAAI,MAAM,GAAW,EAAE,CAAC;QAExB,yDAAyD;QACzD,IAAI,YAAY,GAAW,cAAc,CAAC;QAE1C,IAAI,OAAO,CAAC,wBAAwB,EAAE;YACpC,4DAA4D;YAC5D,IAAI,wBAAI,CAAC,cAAc,CAAC,cAAc,EAAE,OAAO,CAAC,wBAAwB,CAAC,EAAE;gBACzE,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,wBAAwB,EAAE,cAAc,CAAC,CAAC;aAChF;SACF;QAED,kCAAkC;QAClC,YAAY,GAAG,wBAAI,CAAC,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;QACxD,MAAM,IAAI,YAAY,CAAC;QAEvB,IAAI,OAAO,CAAC,cAAc,EAAE;YAC1B,MAAM,IAAI,IAAI,OAAO,CAAC,cAAc,EAAE,CAAC;YAEvC,IAAI,OAAO,CAAC,gBAAgB,EAAE;gBAC5B,MAAM,IAAI,IAAI,OAAO,CAAC,gBAAgB,EAAE,CAAC;aAC1C;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA/CD,kEA+CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as path from 'path';\r\nimport { Path, Text } from '@rushstack/node-core-library';\r\n\r\nexport interface ISourceFileLocationFormatOptions {\r\n  sourceFileLine?: number;\r\n  sourceFileColumn?: number;\r\n  workingPackageFolderPath?: string;\r\n}\r\n\r\nexport class SourceFileLocationFormatter {\r\n  /**\r\n   * Returns a string such as this, based on the context information in the provided node:\r\n   *   \"[C:\\Folder\\File.ts#123]\"\r\n   */\r\n  public static formatDeclaration(node: ts.Node, workingPackageFolderPath?: string): string {\r\n    const sourceFile: ts.SourceFile = node.getSourceFile();\r\n    const lineAndCharacter: ts.LineAndCharacter = sourceFile.getLineAndCharacterOfPosition(node.getStart());\r\n\r\n    return SourceFileLocationFormatter.formatPath(sourceFile.fileName, {\r\n      sourceFileLine: lineAndCharacter.line + 1,\r\n      sourceFileColumn: lineAndCharacter.character + 1,\r\n      workingPackageFolderPath\r\n    });\r\n  }\r\n\r\n  public static formatPath(sourceFilePath: string, options?: ISourceFileLocationFormatOptions): string {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    let result: string = '';\r\n\r\n    // Make the path relative to the workingPackageFolderPath\r\n    let scrubbedPath: string = sourceFilePath;\r\n\r\n    if (options.workingPackageFolderPath) {\r\n      // If it's under the working folder, make it a relative path\r\n      if (Path.isUnderOrEqual(sourceFilePath, options.workingPackageFolderPath)) {\r\n        scrubbedPath = path.relative(options.workingPackageFolderPath, sourceFilePath);\r\n      }\r\n    }\r\n\r\n    // Convert it to a Unix-style path\r\n    scrubbedPath = Text.replaceAll(scrubbedPath, '\\\\', '/');\r\n    result += scrubbedPath;\r\n\r\n    if (options.sourceFileLine) {\r\n      result += `:${options.sourceFileLine}`;\r\n\r\n      if (options.sourceFileColumn) {\r\n        result += `:${options.sourceFileColumn}`;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"]}