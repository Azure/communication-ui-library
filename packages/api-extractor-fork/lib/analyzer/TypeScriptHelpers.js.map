{"version":3,"file":"TypeScriptHelpers.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\r\nimport { TypeScriptInternals } from './TypeScriptInternals';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\nexport class TypeScriptHelpers {\r\n  // Matches TypeScript's encoded names for well-known ECMAScript symbols like\r\n  // \"__@iterator\" or \"__@toStringTag\".\r\n  private static readonly _wellKnownSymbolNameRegExp: RegExp = /^__@(\\w+)$/;\r\n\r\n  // Matches TypeScript's encoded names for late-bound symbols derived from `unique symbol` declarations\r\n  // which have the form of \"__@<variableName>@<symbolId>\", i.e. \"__@someSymbol@12345\".\r\n  private static readonly _uniqueSymbolNameRegExp: RegExp = /^__@.*@\\d+$/;\r\n\r\n  /**\r\n   * This traverses any symbol aliases to find the original place where an item was defined.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, calling followAliases() on the _MyClass symbol will return the\r\n   * original definition of MyClass, traversing any intermediary places where the\r\n   * symbol was imported and re-exported.\r\n   */\r\n  public static followAliases(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    let current: ts.Symbol = symbol;\r\n    for (;;) {\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n      const currentAlias: ts.Symbol = typeChecker.getAliasedSymbol(current);\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n      current = currentAlias;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Returns true if TypeScriptHelpers.followAliases() would return something different\r\n   * from the input `symbol`.\r\n   */\r\n  public static isFollowableAlias(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean {\r\n    if (!(symbol.flags & ts.SymbolFlags.Alias)) {\r\n      return false;\r\n    }\r\n\r\n    const alias: ts.Symbol = typeChecker.getAliasedSymbol(symbol);\r\n    if (!alias || alias === symbol) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Certain virtual symbols do not have any declarations.  For example, `ts.TypeChecker.getExportsOfModule()` can\r\n   * sometimes return a \"prototype\" symbol for an object, even though there is no corresponding declaration in the\r\n   * source code.  API Extractor generally ignores such symbols.\r\n   */\r\n  public static tryGetADeclaration(symbol: ts.Symbol): ts.Declaration | undefined {\r\n    if (symbol.declarations && symbol.declarations.length > 0) {\r\n      return symbol.declarations[0];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the specified symbol is an ambient declaration.\r\n   */\r\n  public static isAmbient(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean {\r\n    const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(symbol, typeChecker);\r\n\r\n    if (followedSymbol.declarations && followedSymbol.declarations.length > 0) {\r\n      const firstDeclaration: ts.Declaration = followedSymbol.declarations[0];\r\n\r\n      // Test 1: Are we inside the sinister \"declare global {\" construct?\r\n      const highestModuleDeclaration: ts.ModuleDeclaration | undefined = TypeScriptHelpers.findHighestParent(\r\n        firstDeclaration,\r\n        ts.SyntaxKind.ModuleDeclaration\r\n      );\r\n      if (highestModuleDeclaration) {\r\n        if (highestModuleDeclaration.name.getText().trim() === 'global') {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // Test 2: Otherwise, the main heuristic for ambient declarations is by looking at the\r\n      // ts.SyntaxKind.SourceFile node to see whether it has a symbol or not (i.e. whether it\r\n      // is acting as a module or not).\r\n      const sourceFile: ts.SourceFile = firstDeclaration.getSourceFile();\r\n\r\n      if (typeChecker.getSymbolAtLocation(sourceFile)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Same semantics as tryGetSymbolForDeclaration(), but throws an exception if the symbol\r\n   * cannot be found.\r\n   */\r\n  public static getSymbolForDeclaration(declaration: ts.Declaration, checker: ts.TypeChecker): ts.Symbol {\r\n    const symbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\r\n      declaration,\r\n      checker\r\n    );\r\n    if (!symbol) {\r\n      throw new InternalError(\r\n        'Unable to determine semantic information for declaration:\\n' +\r\n          SourceFileLocationFormatter.formatDeclaration(declaration)\r\n      );\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  // Return name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\r\n  public static getModuleSpecifier(\r\n    nodeWithModuleSpecifier: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode\r\n  ): string | undefined {\r\n    if (nodeWithModuleSpecifier.kind === ts.SyntaxKind.ImportType) {\r\n      // As specified internally in typescript:/src/compiler/types.ts#ValidImportTypeNode\r\n      if (\r\n        nodeWithModuleSpecifier.argument.kind !== ts.SyntaxKind.LiteralType ||\r\n        (nodeWithModuleSpecifier.argument as ts.LiteralTypeNode).literal.kind !== ts.SyntaxKind.StringLiteral\r\n      ) {\r\n        throw new InternalError('Invalid ImportTypeNode:\\n' + nodeWithModuleSpecifier.getText());\r\n      }\r\n\r\n      return ((nodeWithModuleSpecifier.argument as ts.LiteralTypeNode)\r\n        .literal as ts.StringLiteral).text.trim();\r\n    }\r\n\r\n    // Node is a declaration\r\n    if (\r\n      nodeWithModuleSpecifier.moduleSpecifier &&\r\n      ts.isStringLiteralLike(nodeWithModuleSpecifier.moduleSpecifier)\r\n    ) {\r\n      return TypeScriptInternals.getTextOfIdentifierOrLiteral(nodeWithModuleSpecifier.moduleSpecifier);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns an ancestor of \"node\", such that the ancestor, any intermediary nodes,\r\n   * and the starting node match a list of expected kinds.  Undefined is returned\r\n   * if there aren't enough ancestors, or if the kinds are incorrect.\r\n   *\r\n   * For example, suppose child \"C\" has parents A --> B --> C.\r\n   *\r\n   * Calling _matchAncestor(C, [ExportSpecifier, NamedExports, ExportDeclaration])\r\n   * would return A only if A is of kind ExportSpecifier, B is of kind NamedExports,\r\n   * and C is of kind ExportDeclaration.\r\n   *\r\n   * Calling _matchAncestor(C, [ExportDeclaration]) would return C.\r\n   */\r\n  public static matchAncestor<T extends ts.Node>(\r\n    node: ts.Node,\r\n    kindsToMatch: ts.SyntaxKind[]\r\n  ): T | undefined {\r\n    // (slice(0) clones an array)\r\n    const reversedParentKinds: ts.SyntaxKind[] = kindsToMatch.slice(0).reverse();\r\n\r\n    let current: ts.Node | undefined = undefined;\r\n\r\n    for (const parentKind of reversedParentKinds) {\r\n      if (!current) {\r\n        // The first time through, start with node\r\n        current = node;\r\n      } else {\r\n        // Then walk the parents\r\n        current = current.parent;\r\n      }\r\n\r\n      // If we ran out of items, or if the kind doesn't match, then fail\r\n      if (!current || current.kind !== parentKind) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    // If we matched everything, then return the node that matched the last parentKinds item\r\n    return current as T;\r\n  }\r\n\r\n  /**\r\n   * Does a depth-first search of the children of the specified node.  Returns the first child\r\n   * with the specified kind, or undefined if there is no match.\r\n   */\r\n  public static findFirstChildNode<T extends ts.Node>(\r\n    node: ts.Node,\r\n    kindToMatch: ts.SyntaxKind\r\n  ): T | undefined {\r\n    for (const child of node.getChildren()) {\r\n      if (child.kind === kindToMatch) {\r\n        return child as T;\r\n      }\r\n\r\n      const recursiveMatch: T | undefined = TypeScriptHelpers.findFirstChildNode(child, kindToMatch);\r\n      if (recursiveMatch) {\r\n        return recursiveMatch;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\r\n   */\r\n  public static findFirstParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined {\r\n    let current: ts.Node | undefined = node.parent;\r\n\r\n    while (current) {\r\n      if (current.kind === kindToMatch) {\r\n        return current as T;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the highest parent node with the specified SyntaxKind, or undefined if there is no match.\r\n   * @remarks\r\n   * Whereas findFirstParent() returns the first match, findHighestParent() returns the last match.\r\n   */\r\n  public static findHighestParent<T extends ts.Node>(\r\n    node: ts.Node,\r\n    kindToMatch: ts.SyntaxKind\r\n  ): T | undefined {\r\n    let current: ts.Node | undefined = node;\r\n    let highest: T | undefined = undefined;\r\n\r\n    for (;;) {\r\n      current = TypeScriptHelpers.findFirstParent<T>(current, kindToMatch);\r\n      if (!current) {\r\n        break;\r\n      }\r\n      highest = current as T;\r\n    }\r\n\r\n    return highest;\r\n  }\r\n\r\n  /**\r\n   * Decodes the names that the compiler generates for a built-in ECMAScript symbol.\r\n   *\r\n   * @remarks\r\n   * TypeScript binds well-known ECMAScript symbols like `[Symbol.iterator]` as `__@iterator`.\r\n   * If `name` is of this form, then `tryGetWellKnownSymbolName()` converts it back into e.g. `[Symbol.iterator]`.\r\n   * If the string does not start with `__@` then `undefined` is returned.\r\n   */\r\n  public static tryDecodeWellKnownSymbolName(name: ts.__String): string | undefined {\r\n    const match: RegExpExecArray | null = TypeScriptHelpers._wellKnownSymbolNameRegExp.exec(name as string);\r\n    if (match) {\r\n      const identifier: string = match[1];\r\n      return `[Symbol.${identifier}]`;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided name was generated for a TypeScript `unique symbol`.\r\n   */\r\n  public static isUniqueSymbolName(name: ts.__String): boolean {\r\n    return TypeScriptHelpers._uniqueSymbolNameRegExp.test(name as string);\r\n  }\r\n\r\n  /**\r\n   * Derives the string representation of a TypeScript late-bound symbol.\r\n   */\r\n  public static tryGetLateBoundName(declarationName: ts.ComputedPropertyName): string | undefined {\r\n    // Create a node printer that ignores comments and indentation that we can use to convert\r\n    // declarationName to a string.\r\n    const printer: ts.Printer = ts.createPrinter(\r\n      { removeComments: true },\r\n      {\r\n        onEmitNode(\r\n          hint: ts.EmitHint,\r\n          node: ts.Node,\r\n          emitCallback: (hint: ts.EmitHint, node: ts.Node) => void\r\n        ): void {\r\n          ts.setEmitFlags(declarationName, ts.EmitFlags.NoIndentation | ts.EmitFlags.SingleLine);\r\n          emitCallback(hint, node);\r\n        }\r\n      }\r\n    );\r\n    const sourceFile: ts.SourceFile = declarationName.getSourceFile();\r\n    const text: string = printer.printNode(ts.EmitHint.Unspecified, declarationName, sourceFile);\r\n    // clean up any emit flags we've set on any nodes in the tree.\r\n    ts.disposeEmitNodes(sourceFile);\r\n    return text;\r\n  }\r\n}\r\n"]}