{"version":3,"file":"AstSymbolTable.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { PackageJsonLookup, InternalError } from '@rushstack/node-core-library';\r\n\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { PackageMetadataManager } from './PackageMetadataManager';\r\nimport { ExportAnalyzer } from './ExportAnalyzer';\r\nimport { AstImport } from './AstImport';\r\nimport { MessageRouter } from '../collector/MessageRouter';\r\nimport { TypeScriptInternals, IGlobalVariableAnalyzer } from './TypeScriptInternals';\r\nimport { StringChecks } from './StringChecks';\r\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\r\n\r\nexport type AstEntity = AstSymbol | AstImport;\r\n\r\n/**\r\n * Options for `AstSymbolTable._fetchAstSymbol()`\r\n */\r\nexport interface IFetchAstSymbolOptions {\r\n  /**\r\n   * The symbol after any symbol aliases have been followed using TypeScriptHelpers.followAliases()\r\n   */\r\n  followedSymbol: ts.Symbol;\r\n  /**\r\n   * True if followedSymbol is not part of the working package\r\n   */\r\n  isExternal: boolean;\r\n\r\n  /**\r\n   * If true, symbols with AstSymbol.nominalAnalysis=true will be returned.\r\n   * Otherwise `undefined` will be returned for such symbols.\r\n   */\r\n  includeNominalAnalysis: boolean;\r\n\r\n  /**\r\n   * True while populating the `AstSymbolTable`; false if we're doing a passive lookup\r\n   * without adding anything new to the table\r\n   */\r\n  addIfMissing: boolean;\r\n\r\n  /**\r\n   * A hint to help `_fetchAstSymbol()` determine the `AstSymbol.localName`.\r\n   */\r\n  localName?: string;\r\n}\r\n\r\n/**\r\n * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.\r\n * It maintains a cache of already constructed objects.  AstSymbolTable constructs\r\n * AstModule objects, but otherwise the state that it maintains is agnostic of\r\n * any particular entry point.  (For example, it does not track whether a given AstSymbol\r\n * is \"exported\" or not.)\r\n *\r\n * Internally, AstSymbolTable relies on ExportAnalyzer to crawl import statements and determine where symbols\r\n * are declared (i.e. the AstImport information needed to import them).\r\n */\r\nexport class AstSymbolTable {\r\n  private readonly _program: ts.Program;\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _messageRouter: MessageRouter;\r\n  private readonly _globalVariableAnalyzer: IGlobalVariableAnalyzer;\r\n  private readonly _packageMetadataManager: PackageMetadataManager;\r\n  private readonly _exportAnalyzer: ExportAnalyzer;\r\n  private readonly _alreadyWarnedGlobalNames: Set<string>;\r\n\r\n  /**\r\n   * A mapping from ts.Symbol --> AstSymbol\r\n   * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys\r\n   * are possible.\r\n   *\r\n   * After following type aliases, we use this map to look up the corresponding AstSymbol.\r\n   */\r\n  private readonly _astSymbolsBySymbol: Map<ts.Symbol, AstSymbol> = new Map<ts.Symbol, AstSymbol>();\r\n\r\n  /**\r\n   * A mapping from ts.Declaration --> AstDeclaration\r\n   */\r\n  private readonly _astDeclarationsByDeclaration: Map<ts.Node, AstDeclaration> = new Map<\r\n    ts.Node,\r\n    AstDeclaration\r\n  >();\r\n\r\n  // Note that this is a mapping from specific AST nodes that we analyzed, based on the underlying symbol\r\n  // for that node.\r\n  private readonly _entitiesByNode: Map<ts.Identifier | ts.ImportTypeNode, AstEntity | undefined> = new Map<\r\n    ts.Identifier,\r\n    AstEntity | undefined\r\n  >();\r\n\r\n  public constructor(\r\n    program: ts.Program,\r\n    typeChecker: ts.TypeChecker,\r\n    packageJsonLookup: PackageJsonLookup,\r\n    bundledPackageNames: ReadonlySet<string>,\r\n    messageRouter: MessageRouter\r\n  ) {\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n    this._messageRouter = messageRouter;\r\n    this._globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(program);\r\n    this._packageMetadataManager = new PackageMetadataManager(packageJsonLookup, messageRouter);\r\n\r\n    this._exportAnalyzer = new ExportAnalyzer(this._program, this._typeChecker, bundledPackageNames, {\r\n      analyze: this.analyze.bind(this),\r\n      fetchAstSymbol: this._fetchAstSymbol.bind(this)\r\n    });\r\n\r\n    this._alreadyWarnedGlobalNames = new Set<string>();\r\n  }\r\n\r\n  /**\r\n   * Used to analyze an entry point that belongs to the working package.\r\n   */\r\n  public fetchAstModuleFromWorkingPackage(sourceFile: ts.SourceFile): AstModule {\r\n    return this._exportAnalyzer.fetchAstModuleFromSourceFile(sourceFile, undefined);\r\n  }\r\n\r\n  /**\r\n   * This crawls the specified entry point and collects the full set of exported AstSymbols.\r\n   */\r\n  public fetchAstModuleExportInfo(astModule: AstModule): AstModuleExportInfo {\r\n    return this._exportAnalyzer.fetchAstModuleExportInfo(astModule);\r\n  }\r\n\r\n  /**\r\n   * Attempts to retrieve an export by name from the specified `AstModule`.\r\n   * Returns undefined if no match was found.\r\n   */\r\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\r\n    return this._exportAnalyzer.tryGetExportOfAstModule(exportName, astModule);\r\n  }\r\n\r\n  /**\r\n   * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation\r\n   * starts from the root symbol and then fills out all children of all declarations, and\r\n   * also calculates AstDeclaration.referencedAstSymbols for all declarations.\r\n   * If the symbol is not imported, any non-imported references are also analyzed.\r\n   *\r\n   * @remarks\r\n   * This is an expensive operation, so we only perform it for top-level exports of an\r\n   * the AstModule.  For example, if some code references a nested class inside\r\n   * a namespace from another library, we do not analyze any of that class's siblings\r\n   * or members.  (We do always construct its parents however, since AstDefinition.parent\r\n   * is immutable, and needed e.g. to calculate release tag inheritance.)\r\n   */\r\n  public analyze(astSymbol: AstSymbol): void {\r\n    if (astSymbol.analyzed) {\r\n      return;\r\n    }\r\n\r\n    if (astSymbol.nominalAnalysis) {\r\n      // We don't analyze nominal symbols\r\n      astSymbol._notifyAnalyzed();\r\n      return;\r\n    }\r\n\r\n    // Start at the root of the tree\r\n    const rootAstSymbol: AstSymbol = astSymbol.rootAstSymbol;\r\n\r\n    // Calculate the full child tree for each definition\r\n    for (const astDeclaration of rootAstSymbol.astDeclarations) {\r\n      this._analyzeChildTree(astDeclaration.declaration, astDeclaration);\r\n    }\r\n\r\n    rootAstSymbol._notifyAnalyzed();\r\n\r\n    if (!astSymbol.isExternal) {\r\n      // If this symbol is non-external (i.e. it belongs to the working package), then we also analyze any\r\n      // referencedAstSymbols that are non-external.  For example, this ensures that forgotten exports\r\n      // get analyzed.\r\n      rootAstSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\r\n          // Walk up to the root of the tree, looking for any imports along the way\r\n          if (referencedAstEntity instanceof AstSymbol) {\r\n            if (!referencedAstEntity.isExternal) {\r\n              this.analyze(referencedAstEntity);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a given astDeclaration, this efficiently finds the child corresponding to the\r\n   * specified ts.Node.  It is assumed that AstDeclaration.isSupportedSyntaxKind() would return true for\r\n   * that node type, and that the node is an immediate child of the provided AstDeclaration.\r\n   */\r\n  // NOTE: This could be a method of AstSymbol if it had a backpointer to its AstSymbolTable.\r\n  public getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration {\r\n    if (!parentAstDeclaration.astSymbol.analyzed) {\r\n      throw new Error('getChildDeclarationByNode() cannot be used for an AstSymbol that was not analyzed');\r\n    }\r\n\r\n    const childAstDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\r\n    if (!childAstDeclaration) {\r\n      throw new Error('Child declaration not found for the specified node');\r\n    }\r\n    if (childAstDeclaration.parent !== parentAstDeclaration) {\r\n      throw new InternalError('The found child is not attached to the parent AstDeclaration');\r\n    }\r\n\r\n    return childAstDeclaration;\r\n  }\r\n\r\n  /**\r\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the AstEntity that\r\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\r\n   * @remarks\r\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\r\n   */\r\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): AstEntity | undefined {\r\n    if (!this._entitiesByNode.has(identifier)) {\r\n      throw new InternalError('tryGetEntityForIdentifier() called for an identifier that was not analyzed');\r\n    }\r\n    return this._entitiesByNode.get(identifier);\r\n  }\r\n\r\n  /**\r\n   * Builds an AstSymbol.localName for a given ts.Symbol.  In the current implementation, the localName is\r\n   * a TypeScript-like expression that may be a string literal or ECMAScript symbol expression.\r\n   *\r\n   * ```ts\r\n   * class X {\r\n   *   // localName=\"identifier\"\r\n   *   public identifier: number = 1;\r\n   *   // localName=\"\\\"identifier\\\"\"\r\n   *   public \"quoted string!\": number = 2;\r\n   *   // localName=\"[MyNamespace.MySymbol]\"\r\n   *   public [MyNamespace.MySymbol]: number = 3;\r\n   * }\r\n   * ```\r\n   */\r\n  public static getLocalNameForSymbol(symbol: ts.Symbol): string {\r\n    // TypeScript binds well-known ECMAScript symbols like \"[Symbol.iterator]\" as \"__@iterator\".\r\n    // Decode it back into \"[Symbol.iterator]\".\r\n    const wellKnownSymbolName: string | undefined = TypeScriptHelpers.tryDecodeWellKnownSymbolName(\r\n      symbol.escapedName\r\n    );\r\n    if (wellKnownSymbolName) {\r\n      return wellKnownSymbolName;\r\n    }\r\n\r\n    const isUniqueSymbol: boolean = TypeScriptHelpers.isUniqueSymbolName(symbol.escapedName);\r\n\r\n    // We will try to obtain the name from a declaration; otherwise we'll fall back to the symbol name.\r\n    let unquotedName: string = symbol.name;\r\n\r\n    for (const declaration of symbol.declarations || []) {\r\n      // Handle cases such as \"export default class X { }\" where the symbol name is \"default\"\r\n      // but the local name is \"X\".\r\n      const localSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetLocalSymbol(declaration);\r\n      if (localSymbol) {\r\n        unquotedName = localSymbol.name;\r\n      }\r\n\r\n      // If it is a non-well-known symbol, then return the late-bound name.  For example, \"X.Y.z\" in this example:\r\n      //\r\n      //   namespace X {\r\n      //     export namespace Y {\r\n      //       export const z: unique symbol = Symbol(\"z\");\r\n      //     }\r\n      //  }\r\n      //\r\n      //  class C {\r\n      //    public [X.Y.z](): void { }\r\n      //  }\r\n      //\r\n      if (isUniqueSymbol) {\r\n        const declarationName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n        if (declarationName && ts.isComputedPropertyName(declarationName)) {\r\n          const lateBoundName: string | undefined = TypeScriptHelpers.tryGetLateBoundName(declarationName);\r\n          if (lateBoundName) {\r\n            // Here the string may contain an expression such as \"[X.Y.z]\".  Names starting with \"[\" are always\r\n            // expressions.  If a string literal contains those characters, the code below will JSON.stringify() it\r\n            // to avoid a collision.\r\n            return lateBoundName;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Otherwise that name may come from a quoted string or pseudonym like `__constructor`.\r\n    // If the string is not a safe identifier, then we must add quotes.\r\n    // Note that if it was quoted but did not need to be quoted, here we will remove the quotes.\r\n    if (!StringChecks.isSafeUnquotedMemberIdentifier(unquotedName)) {\r\n      // For API Extractor's purposes, a canonical form is more appropriate than trying to reflect whatever\r\n      // appeared in the source code.  The code is not even guaranteed to be consistent, for example:\r\n      //\r\n      //   class X {\r\n      //     public \"f1\"(x: string): void;\r\n      //     public f1(x: boolean): void;\r\n      //     public 'f1'(x: string | boolean): void { }\r\n      //   }\r\n      return JSON.stringify(unquotedName);\r\n    }\r\n\r\n    return unquotedName;\r\n  }\r\n\r\n  /**\r\n   * Used by analyze to recursively analyze the entire child tree.\r\n   */\r\n  private _analyzeChildTree(node: ts.Node, governingAstDeclaration: AstDeclaration): void {\r\n    switch (node.kind) {\r\n      case ts.SyntaxKind.JSDocComment: // Skip JSDoc comments - TS considers @param tags TypeReference nodes\r\n        return;\r\n\r\n      // Is this a reference to another AstSymbol?\r\n      case ts.SyntaxKind.TypeReference: // general type references\r\n      case ts.SyntaxKind.ExpressionWithTypeArguments: // special case for e.g. the \"extends\" keyword\r\n      case ts.SyntaxKind.ComputedPropertyName: // used for EcmaScript \"symbols\", e.g. \"[toPrimitive]\".\r\n      case ts.SyntaxKind.TypeQuery: // represents for \"typeof X\" as a type\r\n        {\r\n          // Sometimes the type reference will involve multiple identifiers, e.g. \"a.b.C\".\r\n          // In this case, we only need to worry about importing the first identifier,\r\n          // so do a depth-first search for it:\r\n          const identifierNode: ts.Identifier | undefined = TypeScriptHelpers.findFirstChildNode(\r\n            node,\r\n            ts.SyntaxKind.Identifier\r\n          );\r\n\r\n          if (identifierNode) {\r\n            let referencedAstEntity: AstEntity | undefined =\r\n              this._entitiesByNode.get(identifierNode);\r\n            if (!referencedAstEntity) {\r\n              const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(identifierNode);\r\n              if (!symbol) {\r\n                throw new Error('Symbol not found for identifier: ' + identifierNode.getText());\r\n              }\r\n\r\n              // Normally we expect getSymbolAtLocation() to take us to a declaration within the same source\r\n              // file, or else to an explicit \"import\" statement within the same source file.  But in certain\r\n              // situations (e.g. a global variable) the symbol will refer to a declaration in some other\r\n              // source file.  We'll call that case a \"displaced symbol\".\r\n              //\r\n              // For more info, see this discussion:\r\n              // https://github.com/microsoft/rushstack/issues/1765#issuecomment-595559849\r\n              let displacedSymbol: boolean = true;\r\n              for (const declaration of symbol.declarations || []) {\r\n                if (declaration.getSourceFile() === identifierNode.getSourceFile()) {\r\n                  displacedSymbol = false;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              if (displacedSymbol) {\r\n                if (this._globalVariableAnalyzer.hasGlobalName(identifierNode.text)) {\r\n                  // If the displaced symbol is a global variable, then API Extractor simply ignores it.\r\n                  // Ambient declarations typically describe the runtime environment (provided by an API consumer),\r\n                  // so we don't bother analyzing them as an API contract.  (There are probably some packages\r\n                  // that include interesting global variables in their API, but API Extractor doesn't support\r\n                  // that yet; it would be a feature request.)\r\n\r\n                  if (this._messageRouter.showDiagnostics) {\r\n                    if (!this._alreadyWarnedGlobalNames.has(identifierNode.text)) {\r\n                      this._alreadyWarnedGlobalNames.add(identifierNode.text);\r\n                      this._messageRouter.logDiagnostic(\r\n                        `Ignoring reference to global variable \"${identifierNode.text}\"` +\r\n                          ` in ` +\r\n                          SourceFileLocationFormatter.formatDeclaration(identifierNode)\r\n                      );\r\n                    }\r\n                  }\r\n                } else {\r\n                  // If you encounter this, please report a bug with a repro.  We're interested to know\r\n                  // how it can occur.\r\n                  throw new InternalError(`Unable to follow symbol for \"${identifierNode.text}\"`);\r\n                }\r\n              } else {\r\n                referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntity(\r\n                  symbol,\r\n                  governingAstDeclaration.astSymbol.isExternal\r\n                );\r\n\r\n                this._entitiesByNode.set(identifierNode, referencedAstEntity);\r\n              }\r\n            }\r\n\r\n            if (referencedAstEntity) {\r\n              governingAstDeclaration._notifyReferencedAstEntity(referencedAstEntity);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n      // Is this the identifier for the governingAstDeclaration?\r\n      case ts.SyntaxKind.Identifier:\r\n        {\r\n          const identifierNode: ts.Identifier = node as ts.Identifier;\r\n          if (!this._entitiesByNode.has(identifierNode)) {\r\n            const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(identifierNode);\r\n\r\n            let referencedAstEntity: AstEntity | undefined = undefined;\r\n\r\n            if (symbol === governingAstDeclaration.astSymbol.followedSymbol) {\r\n              referencedAstEntity = this._fetchEntityForNode(identifierNode, governingAstDeclaration);\r\n            }\r\n\r\n            this._entitiesByNode.set(identifierNode, referencedAstEntity);\r\n          }\r\n        }\r\n        break;\r\n\r\n      case ts.SyntaxKind.ImportType:\r\n        {\r\n          const importTypeNode: ts.ImportTypeNode = node as ts.ImportTypeNode;\r\n          let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(importTypeNode);\r\n\r\n          if (!this._entitiesByNode.has(importTypeNode)) {\r\n            referencedAstEntity = this._fetchEntityForNode(importTypeNode, governingAstDeclaration);\r\n\r\n            if (!referencedAstEntity) {\r\n              // This should never happen\r\n              throw new Error('Failed to fetch entity for import() type node: ' + importTypeNode.getText());\r\n            }\r\n\r\n            this._entitiesByNode.set(importTypeNode, referencedAstEntity);\r\n          }\r\n\r\n          if (referencedAstEntity) {\r\n            governingAstDeclaration._notifyReferencedAstEntity(referencedAstEntity);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Is this node declaring a new AstSymbol?\r\n    const newGoverningAstDeclaration: AstDeclaration | undefined = this._fetchAstDeclaration(\r\n      node,\r\n      governingAstDeclaration.astSymbol.isExternal\r\n    );\r\n\r\n    for (const childNode of node.getChildren()) {\r\n      this._analyzeChildTree(childNode, newGoverningAstDeclaration || governingAstDeclaration);\r\n    }\r\n  }\r\n\r\n  private _fetchEntityForNode(\r\n    node: ts.Identifier | ts.ImportTypeNode,\r\n    governingAstDeclaration: AstDeclaration\r\n  ): AstEntity | undefined {\r\n    let referencedAstEntity: AstEntity | undefined = this._entitiesByNode.get(node);\r\n    if (!referencedAstEntity) {\r\n      if (node.kind === ts.SyntaxKind.ImportType) {\r\n        referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntityFromImportTypeNode(\r\n          node,\r\n          governingAstDeclaration.astSymbol.isExternal\r\n        );\r\n      } else {\r\n        const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(node);\r\n        if (!symbol) {\r\n          throw new Error('Symbol not found for identifier: ' + node.getText());\r\n        }\r\n\r\n        referencedAstEntity = this._exportAnalyzer.fetchReferencedAstEntity(\r\n          symbol,\r\n          governingAstDeclaration.astSymbol.isExternal\r\n        );\r\n      }\r\n\r\n      this._entitiesByNode.set(node, referencedAstEntity);\r\n    }\r\n    return referencedAstEntity;\r\n  }\r\n\r\n  private _fetchAstDeclaration(node: ts.Node, isExternal: boolean): AstDeclaration | undefined {\r\n    if (!AstDeclaration.isSupportedSyntaxKind(node.kind)) {\r\n      return undefined;\r\n    }\r\n\r\n    const symbol: ts.Symbol | undefined = TypeScriptHelpers.getSymbolForDeclaration(\r\n      node as ts.Declaration,\r\n      this._typeChecker\r\n    );\r\n    if (!symbol) {\r\n      throw new InternalError('Unable to find symbol for node');\r\n    }\r\n\r\n    const astSymbol: AstSymbol | undefined = this._fetchAstSymbol({\r\n      followedSymbol: symbol,\r\n      isExternal: isExternal,\r\n      includeNominalAnalysis: true,\r\n      addIfMissing: true\r\n    });\r\n\r\n    if (!astSymbol) {\r\n      return undefined;\r\n    }\r\n\r\n    const astDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\r\n\r\n    if (!astDeclaration) {\r\n      throw new InternalError('Unable to find constructed AstDeclaration');\r\n    }\r\n\r\n    return astDeclaration;\r\n  }\r\n\r\n  private _fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined {\r\n    const followedSymbol: ts.Symbol = options.followedSymbol;\r\n\r\n    // Filter out symbols representing constructs that we don't care about\r\n    const arbitraryDeclaration: ts.Declaration | undefined =\r\n      TypeScriptHelpers.tryGetADeclaration(followedSymbol);\r\n    if (!arbitraryDeclaration) {\r\n      return undefined;\r\n    }\r\n\r\n    if (\r\n      // eslint-disable-next-line no-bitwise\r\n      followedSymbol.flags &\r\n        // eslint-disable-next-line no-bitwise\r\n        (ts.SymbolFlags.TypeParameter | ts.SymbolFlags.TypeLiteral | ts.SymbolFlags.Transient) &&\r\n      !TypeScriptInternals.isLateBoundSymbol(followedSymbol)\r\n    ) {\r\n      return undefined;\r\n    }\r\n\r\n    // API Extractor doesn't analyze ambient declarations at all\r\n    if (TypeScriptHelpers.isAmbient(followedSymbol, this._typeChecker)) {\r\n      // We make a special exemption for ambient declarations that appear in a source file containing\r\n      // an \"export=\" declaration that allows them to be imported as non-ambient.\r\n      if (!this._exportAnalyzer.isImportableAmbientSourceFile(arbitraryDeclaration.getSourceFile())) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    // Make sure followedSymbol isn't an alias for something else\r\n    if (TypeScriptHelpers.isFollowableAlias(followedSymbol, this._typeChecker)) {\r\n      // We expect the caller to have already followed any aliases\r\n      throw new InternalError('AstSymbolTable._fetchAstSymbol() cannot be called with a symbol alias');\r\n    }\r\n\r\n    let astSymbol: AstSymbol | undefined = this._astSymbolsBySymbol.get(followedSymbol);\r\n\r\n    if (!astSymbol) {\r\n      // None of the above lookups worked, so create a new entry...\r\n      let nominalAnalysis: boolean = false;\r\n\r\n      if (options.isExternal) {\r\n        // If the file is from an external package that does not support AEDoc, normally we ignore it completely.\r\n        // But in some cases (e.g. checking star exports of an external package) we need an AstSymbol to\r\n        // represent it, but we don't need to analyze its sibling/children.\r\n        const followedSymbolSourceFileName: string = arbitraryDeclaration.getSourceFile().fileName;\r\n\r\n        if (!this._packageMetadataManager.isAedocSupportedFor(followedSymbolSourceFileName)) {\r\n          nominalAnalysis = true;\r\n\r\n          if (!options.includeNominalAnalysis) {\r\n            return undefined;\r\n          }\r\n        }\r\n      }\r\n\r\n      let parentAstSymbol: AstSymbol | undefined = undefined;\r\n\r\n      if (!nominalAnalysis) {\r\n        for (const declaration of followedSymbol.declarations || []) {\r\n          if (!AstDeclaration.isSupportedSyntaxKind(declaration.kind)) {\r\n            throw new InternalError(\r\n              `The \"${followedSymbol.name}\" symbol has a` +\r\n                ` ts.SyntaxKind.${ts.SyntaxKind[declaration.kind]} declaration which is not (yet?)` +\r\n                ` supported by API Extractor`\r\n            );\r\n          }\r\n        }\r\n\r\n        // We always fetch the entire chain of parents for each declaration.\r\n        // (Children/siblings are only analyzed on demand.)\r\n\r\n        // Key assumptions behind this squirrely logic:\r\n        //\r\n        // IF a given symbol has two declarations D1 and D2; AND\r\n        // If D1 has a parent P1, then\r\n        // - D2 will also have a parent P2; AND\r\n        // - P1 and P2's symbol will be the same\r\n        // - but P1 and P2 may be different (e.g. merged namespaces containing merged interfaces)\r\n\r\n        // Is there a parent AstSymbol?  First we check to see if there is a parent declaration:\r\n        const arbitraryDeclaration: ts.Node | undefined =\r\n          TypeScriptHelpers.tryGetADeclaration(followedSymbol);\r\n\r\n        if (arbitraryDeclaration) {\r\n          const arbitraryParentDeclaration: ts.Node | undefined =\r\n            this._tryFindFirstAstDeclarationParent(arbitraryDeclaration);\r\n\r\n          if (arbitraryParentDeclaration) {\r\n            const parentSymbol: ts.Symbol = TypeScriptHelpers.getSymbolForDeclaration(\r\n              arbitraryParentDeclaration as ts.Declaration,\r\n              this._typeChecker\r\n            );\r\n\r\n            parentAstSymbol = this._fetchAstSymbol({\r\n              followedSymbol: parentSymbol,\r\n              isExternal: options.isExternal,\r\n              includeNominalAnalysis: false,\r\n              addIfMissing: true\r\n            });\r\n            if (!parentAstSymbol) {\r\n              throw new InternalError('Unable to construct a parent AstSymbol for ' + followedSymbol.name);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const localName: string | undefined =\r\n        options.localName || AstSymbolTable.getLocalNameForSymbol(followedSymbol);\r\n\r\n      astSymbol = new AstSymbol({\r\n        followedSymbol: followedSymbol,\r\n        localName: localName,\r\n        isExternal: options.isExternal,\r\n        nominalAnalysis: nominalAnalysis,\r\n        parentAstSymbol: parentAstSymbol,\r\n        rootAstSymbol: parentAstSymbol ? parentAstSymbol.rootAstSymbol : undefined\r\n      });\r\n\r\n      this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\r\n\r\n      // Okay, now while creating the declarations we will wire them up to the\r\n      // their corresponding parent declarations\r\n      for (const declaration of followedSymbol.declarations || []) {\r\n        let parentAstDeclaration: AstDeclaration | undefined = undefined;\r\n        if (parentAstSymbol) {\r\n          const parentDeclaration: ts.Node | undefined = this._tryFindFirstAstDeclarationParent(declaration);\r\n\r\n          if (!parentDeclaration) {\r\n            throw new InternalError('Missing parent declaration');\r\n          }\r\n\r\n          parentAstDeclaration = this._astDeclarationsByDeclaration.get(parentDeclaration);\r\n          if (!parentAstDeclaration) {\r\n            throw new InternalError('Missing parent AstDeclaration');\r\n          }\r\n        }\r\n\r\n        const astDeclaration: AstDeclaration = new AstDeclaration({\r\n          declaration,\r\n          astSymbol,\r\n          parent: parentAstDeclaration\r\n        });\r\n\r\n        this._astDeclarationsByDeclaration.set(declaration, astDeclaration);\r\n      }\r\n    }\r\n\r\n    if (options.isExternal !== astSymbol.isExternal) {\r\n      throw new InternalError(\r\n        `Cannot assign isExternal=${options.isExternal} for` +\r\n          ` the symbol ${astSymbol.localName} because it was previously registered` +\r\n          ` with isExternal=${astSymbol.isExternal}`\r\n      );\r\n    }\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.\r\n   */\r\n  private _tryFindFirstAstDeclarationParent(node: ts.Node): ts.Node | undefined {\r\n    let currentNode: ts.Node | undefined = node.parent;\r\n    while (currentNode) {\r\n      if (AstDeclaration.isSupportedSyntaxKind(currentNode.kind)) {\r\n        return currentNode;\r\n      }\r\n      currentNode = currentNode.parent;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}