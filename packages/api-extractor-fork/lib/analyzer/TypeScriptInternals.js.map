{"version":3,"file":"TypeScriptInternals.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptInternals.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAE3D,uDAAuD;AAEvD,+CAAiC;AACjC,oEAA6D;AAS7D,MAAa,mBAAmB;IACvB,MAAM,CAAC,yBAAyB,CAAC,MAAiB,EAAE,WAA2B;QACpF,qBAAqB;QACrB,8EAA8E;QAC9E,OAAQ,WAAmB,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC,CAAC,yDAAyD;IAC1H,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,0BAA0B,CACtC,WAA2B,EAC3B,OAAuB;QAEvB,IAAI,MAAM,GAA2B,WAAmB,CAAC,MAAM,CAAC;QAChE,IAAI,MAAM,IAAI,MAAM,CAAC,WAAW,KAAK,EAAE,CAAC,kBAAkB,CAAC,QAAQ,EAAE;YACnE,MAAM,IAAI,GAAmC,EAAE,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;YAClF,MAAM,GAAG,CAAC,IAAI,IAAI,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,IAAI,MAAM,CAAC;SAChE;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,MAAiB;QAC/C;QACE,sCAAsC;QACtC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,SAAS;YACtC,MAAc,CAAC,UAAU,KAAM,EAAU,CAAC,UAAU,CAAC,IAAI,EAC1D;YACA,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CAAC,IAAa,EAAE,IAAY;QAC7D,qBAAqB;QACrB,qFAAqF;QAErF,OAAQ,EAAU,CAAC,qBAAqB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,4BAA4B,CACxC,IAA8D;QAE9D,qBAAqB;QACrB,sFAAsF;QAEtF,OAAQ,EAAU,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAC7B,UAAyB,EACzB,cAAsB;QAEtB,qBAAqB;QACrB,qFAAqF;QAErF,OAAQ,EAAU,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,eAAe,CAAC,MAAiB;QAC7C,OAAQ,MAAc,CAAC,MAAM,CAAC;IAChC,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,WAA2B;QACzD,OAAQ,WAAmB,CAAC,WAAW,CAAC;IAC1C,CAAC;IAEM,MAAM,CAAC,yBAAyB,CAAC,OAAmB;QACzD,MAAM,UAAU,GAAQ,OAAO,CAAC;QAChC,IAAI,CAAC,UAAU,CAAC,kCAAkC,EAAE;YAClD,MAAM,IAAI,iCAAa,CAAC,oDAAoD,CAAC,CAAC;SAC/E;QACD,MAAM,WAAW,GAAQ,UAAU,CAAC,kCAAkC,EAAE,CAAC;QACzE,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE;YAChC,MAAM,IAAI,iCAAa,CAAC,qCAAqC,CAAC,CAAC;SAChE;QACD,MAAM,QAAQ,GAAQ,WAAW,CAAC,eAAe,EAAE,CAAC;QACpD,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE;YAC3B,MAAM,IAAI,iCAAa,CAAC,oCAAoC,CAAC,CAAC;SAC/D;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF;AA5GD,kDA4GC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError } from '@rushstack/node-core-library';\r\n\r\n/**\r\n * Exposes the TypeScript compiler internals for detecting global variable names.\r\n */\r\nexport interface IGlobalVariableAnalyzer {\r\n  hasGlobalName(name: string): boolean;\r\n}\r\n\r\nexport class TypeScriptInternals {\r\n  public static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/checker.ts\r\n    return (typeChecker as any).getImmediateAliasedSymbol(symbol); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n  }\r\n\r\n  /**\r\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\r\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\r\n   * certain data structures, and seems to always work, but is not officially documented.\r\n   *\r\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\r\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\r\n   */\r\n  public static tryGetSymbolForDeclaration(\r\n    declaration: ts.Declaration,\r\n    checker: ts.TypeChecker\r\n  ): ts.Symbol | undefined {\r\n    let symbol: ts.Symbol | undefined = (declaration as any).symbol;\r\n    if (symbol && symbol.escapedName === ts.InternalSymbolName.Computed) {\r\n      const name: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n      symbol = (name && checker.getSymbolAtLocation(name)) || symbol;\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided Symbol is a TypeScript \"late-bound\" Symbol (i.e. was created by the Checker\r\n   * for a computed property based on its type, rather than by the Binder).\r\n   */\r\n  public static isLateBoundSymbol(symbol: ts.Symbol): boolean {\r\n    if (\r\n      // eslint-disable-next-line no-bitwise\r\n      symbol.flags & ts.SymbolFlags.Transient &&\r\n      (symbol as any).checkFlags === (ts as any).CheckFlags.Late\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the comment ranges associated with the specified node.\r\n   */\r\n  public static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v2.4.2/src/compiler/utilities.ts#L616\r\n\r\n    return (ts as any).getJSDocCommentRanges.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (unescaped) value of an string literal, numeric literal, or identifier.\r\n   */\r\n  public static getTextOfIdentifierOrLiteral(\r\n    node: ts.Identifier | ts.StringLiteralLike | ts.NumericLiteral\r\n  ): string {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L2721\r\n\r\n    return (ts as any).getTextOfIdentifierOrLiteral(node);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (cached) module resolution information for a module name that was exported from a SourceFile.\r\n   * The compiler populates this cache as part of analyzing the source file.\r\n   */\r\n  public static getResolvedModule(\r\n    sourceFile: ts.SourceFile,\r\n    moduleNameText: string\r\n  ): ts.ResolvedModuleFull | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L218\r\n\r\n    return (ts as any).getResolvedModule(sourceFile, moduleNameText);\r\n  }\r\n\r\n  /**\r\n   * Returns ts.Symbol.parent if it exists.\r\n   */\r\n  public static getSymbolParent(symbol: ts.Symbol): ts.Symbol | undefined {\r\n    return (symbol as any).parent;\r\n  }\r\n\r\n  /**\r\n   * In an statement like `export default class X { }`, the `Symbol.name` will be `default`\r\n   * whereas the `localSymbol` is `X`.\r\n   */\r\n  public static tryGetLocalSymbol(declaration: ts.Declaration): ts.Symbol | undefined {\r\n    return (declaration as any).localSymbol;\r\n  }\r\n\r\n  public static getGlobalVariableAnalyzer(program: ts.Program): IGlobalVariableAnalyzer {\r\n    const anyProgram: any = program;\r\n    if (!anyProgram.getDiagnosticsProducingTypeChecker) {\r\n      throw new InternalError('Missing Program.getDiagnosticsProducingTypeChecker');\r\n    }\r\n    const typeChecker: any = anyProgram.getDiagnosticsProducingTypeChecker();\r\n    if (!typeChecker.getEmitResolver) {\r\n      throw new InternalError('Missing TypeChecker.getEmitResolver');\r\n    }\r\n    const resolver: any = typeChecker.getEmitResolver();\r\n    if (!resolver.hasGlobalName) {\r\n      throw new InternalError('Missing EmitResolver.hasGlobalName');\r\n    }\r\n    return resolver;\r\n  }\r\n}\r\n"]}