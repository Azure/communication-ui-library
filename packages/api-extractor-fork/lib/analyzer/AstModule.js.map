{"version":3,"file":"AstModule.js","sourceRoot":"","sources":["../../src/analyzer/AstModule.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAO3D;;GAEG;AACH,MAAa,mBAAmB;IAAhC;QACkB,0BAAqB,GAA2B,IAAI,GAAG,EAAqB,CAAC;QAC7E,gCAA2B,GAAmB,IAAI,GAAG,EAAa,CAAC;IACrF,CAAC;CAAA;AAHD,kDAGC;AAWD;;;;;;;;GAQG;AACH,MAAa,SAAS;IAkCpB,YAAmB,OAA0B;QAC3C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QAEzC,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;QAErD,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAa,CAAC;QAEhD,IAAI,CAAC,sBAAsB,GAAG,IAAI,GAAG,EAAqB,CAAC;QAE3D,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,kBAAkB,KAAK,SAAS,CAAC;IAC/C,CAAC;CACF;AArDD,8BAqDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\n\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { AstEntity } from './AstSymbolTable';\r\n\r\n/**\r\n * Represents information collected by {@link AstSymbolTable.fetchAstModuleExportInfo}\r\n */\r\nexport class AstModuleExportInfo {\r\n  public readonly exportedLocalEntities: Map<string, AstEntity> = new Map<string, AstEntity>();\r\n  public readonly starExportedExternalModules: Set<AstModule> = new Set<AstModule>();\r\n}\r\n\r\n/**\r\n * Constructor parameters for AstModule\r\n */\r\nexport interface IAstModuleOptions {\r\n  sourceFile: ts.SourceFile;\r\n  moduleSymbol: ts.Symbol;\r\n  externalModulePath: string | undefined;\r\n}\r\n\r\n/**\r\n * An internal data structure that represents a source file that is analyzed by AstSymbolTable.\r\n *\r\n * @privateRemarks\r\n * Our naming convention is to use I____Parameters for constructor options and\r\n * I____Options for general function options.  However the word \"parameters\" is\r\n * confusingly similar to the terminology for function parameters modeled by API Extractor,\r\n * so we use I____Options for both cases in this code base.\r\n */\r\nexport class AstModule {\r\n  /**\r\n   * The source file that declares this TypeScript module.  In most cases, the source file's\r\n   * top-level exports constitute the module.\r\n   */\r\n  public readonly sourceFile: ts.SourceFile;\r\n\r\n  /**\r\n   * The symbol for the module.  Typically this corresponds to ts.SourceFile itself, however\r\n   * in some cases the ts.SourceFile may contain multiple modules declared using the `module` keyword.\r\n   */\r\n  public readonly moduleSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * Example:  \"@rushstack/node-core-library/lib/FileSystem\"\r\n   * but never: \"./FileSystem\"\r\n   */\r\n  public readonly externalModulePath: string | undefined;\r\n\r\n  /**\r\n   * A list of other `AstModule` objects that appear in `export * from \"___\";` statements.\r\n   */\r\n  public readonly starExportedModules: Set<AstModule>;\r\n\r\n  /**\r\n   * A partial map of entities exported by this module.  The key is the exported name.\r\n   */\r\n  public readonly cachedExportedEntities: Map<string, AstEntity>; // exportName --> entity\r\n\r\n  /**\r\n   * Additional state calculated by `AstSymbolTable.fetchWorkingPackageModule()`.\r\n   */\r\n  public astModuleExportInfo: AstModuleExportInfo | undefined;\r\n\r\n  public constructor(options: IAstModuleOptions) {\r\n    this.sourceFile = options.sourceFile;\r\n    this.moduleSymbol = options.moduleSymbol;\r\n\r\n    this.externalModulePath = options.externalModulePath;\r\n\r\n    this.starExportedModules = new Set<AstModule>();\r\n\r\n    this.cachedExportedEntities = new Map<string, AstSymbol>();\r\n\r\n    this.astModuleExportInfo = undefined;\r\n  }\r\n\r\n  /**\r\n   * If false, then this source file is part of the working package being processed by the `Collector`.\r\n   */\r\n  public get isExternal(): boolean {\r\n    return this.externalModulePath !== undefined;\r\n  }\r\n}\r\n"]}