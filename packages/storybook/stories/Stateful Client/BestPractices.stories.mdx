import { Meta } from '@storybook/addon-docs';

<Meta
  id="statefulclient-bestpractices"
  title="Stateful Client/Best Practices"
  parameters={{ previewTabs: { canvas: { disable: true, hidden: true } } }}
/>

# Best Practices

We are sharing some of our recommended best practices when handling state with Azure Communication Services UI Library.

## Use the Stateful Clients

Managing the complex state of a calling or chat session can be problematic. We identified managing state was going to be a common challenge for our developer community. We challenged ourselves to find a way to store this information on the client to better support our UI components.
By using the stateful client for calling or chat scenarios, developers will be on the recommended path for powering your own communications experience. The `CallComposite` and the `ChatComposite` both internally use
the stateful client.

## Use usePropsFor

If you are using our out-of-the-box UI components, `usePropsFor` will help you get integrated with the underlying functionality quickly. `UsePropsFor` is a React hook that is able to assign props to a React component
from information held in the stateful client. This hook is able to properly map properties from the state because we are aware of relevant UI components ahead of time. If you are using your own UI components, you will
not be able to use `usePropsFor`.

## You can use your own UI Components

If you are using your own UI components, we recommend using the `useSelector` React hook. `useSelector` is designed to connect your data from the stateful client to your UI components.
You could skip using `useSelector` however it is designed to make it simple to connect any underlying communications data to your UI components.
The `useSelector` hook is quite versatile and we use it under the hood in our `usePropsFor` React hook.

## Populating the `DeviceManager` State

When using the stateful calling client, the call related state will be automatically retrieved for you.
However, this is not the case for `DeviceManager` state.
To be able to retrieve `DeviceManager` state from the `StatefulCallClient`’s state, you must trigger the appropriate APIs to populate the `DeviceManager` state.

- `DeviceManager.askPermission()` – this must be called to ask for device permissions from the user. The result of their decisions will be stored in DeviceManagerState.deviceAccess.
- `DeviceManager.getCameras()` – When called, the result will be stored in DeviceManagerState.cameras.
- `DeviceManager.getMicrophones()` – When called, the result will be stored in DeviceManagerState.microphones.
- `DeviceManager.getSpeakers()` – When called, the result will be stored in DeviceManagerState.speakers

## Use of `selectedCamera` inside the `DeviceManager`

To make Stateful Calling easier to use we’ve added a property to the `DeviceManagerState` called `selectedCamera`.
This is not a proxy of the SDK state and is completely controlled by you.
It is populated when you set it and updated when you update it. It has no bearing on the function of the SDK and not automatically used by the SDK.

## Use of `createView` and `disposeView` on the StatefulCallClient

To allow developers to generate a HTMLElement/view of a Stateful VideoStream, we provide a createView and disposeView API.
These APIs are located in StatefulCallClient and should only be used for scenarios where developers want to generate their own components to use in conjunction with the UI Library.
There are three scenarios to using these APIs:

1. _Rendering a RemoteVideoStreamState_
   You are required to call `createView` with a valid `callId`, `participantIdentifier`, and `remoteVideoStreamState`.
   The `createView` is async and if your architecture can support awaiting for it we recommend you do that.
   Once the `createView` completes the view will be stored under `CallState.RemoteParticipants.[your remote participant].videoStream.[your videostream].view`.
   If you cannot await the result of `createView`, it is fine to call `createView` again, `createView` will no-op the second call. Once the view has been created, the call state will be automatically updated and you can check the state for the view.
   `CreateView` will not allow creating multiple view of the same stream.

2. _Rendering a LocalVideoStreamState in a Call_
   Same as #1 except this time `createView` only requires a valid `callId` and `LocalVideoStreamState`.
   Note that this will only work if the `LocalVideoStream` is already part of the call (you’ll have to first call `Call.startVideo` to add the `LocalVideoStream` to the Call).
   Everything else is the same as #1 after this except the view can be found in `CallState.localVideoStreams.(your videostream).view`.

3. _Rendering a LocalVideoStreamState when not in a call_
   This scenario supports the case if you want to see a video render without adding that stream to the call, for instance `LocalPreview` scenario.
   In this case `createView` requires only a valid `LocalVideoStreamState`.
   `CreateView` will put the created view under `DeviceManagerState.unparentedViews.(your videostream).view`.
   You can access this Map using your original `LocalVideoStreamState` as the key.

To debug `createView` and `disposeView`, they emit `console.warns` when used incorrectly that can be tracked.

## Track Changes to `callId`

One major gotcha with using the stateful calling client is that `callId` may change and `callId` is used to look up data in stateful state.
If you have an old callId and the callId changed, you will not be able to access or find `CallState` in `CallClientState`.
To work around, we recommend you do not cache the `callId` and instead cache the entire call object.
The id in the call object will be kept up to date and when ever you access `CallClientState` use the `call.id`.

## Detecting Screenshare Participant

To make the stateful calling client easier to use we added a `screenshareRemoteParticipant` property to `CallState`.
If there is a remote participant screensharing, this will allow you to quickly look up that participant’s state by doing something like this:

```tsx
CallState.remoteParticipants.get(CallState.screenshareRemoteParticipant);
```

This property will be undefined if there are no remote participants screensharing.
Note that this only applies to remote screenshares and not local screenshares.

## Detecting Transcription and Recording

The stateful calling client will manage transcription/recording for you.
You only need to simply check the states under `CallState.transcription` and `CallState.recording`.
