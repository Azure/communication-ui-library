import { Meta } from '@storybook/addon-docs/blocks';
import { Canvas, Description, Heading, Props, Source, Title } from '@storybook/addon-docs/blocks';

<Meta id="statefulclient-reacthooks-setup" title="Stateful Client/React Hooks/Adapters" />

# Adapters for Composites

Composites deliver turn-key communication experiences for developers.
They make it easy for developers to add end-to-end communication experiences to their apps with only a couple lines of code.
To power Composites, the `communication-react` library provides `Adapters`, one for calling and one for chat Composites.
These adapters make use of the stateful clients for calling and chat in conjunction with React Hooks like usePropsFor, to provide developers a single interface to configure Composites.

## Setting Up Adapters

To setup the adapters, you will need to provide the adapter with key metadata required.
This includes most importantly an access token for your Azure Communication Services resource and context information for the call or chat thread you want to join.
To create the adapters we will use the `createAzureCommunicationCallAdapter` and `createAzureCommunicationChatAdapter` helper methods.
This methods are asynchronous so we will will `useEffect` to create them.

### Calling Adapters

To initialize the calling adapter, you will be required to provide a call locator with the information of the group or meeting you are trying to join.
Group Id for Azure Communication Services take the shape of GUID generated by the developer to identify a call inside their tenant.
Teams Meeting information can be acquired through [Microsoft Graph](https://docs.microsoft.com/en-us/graph/overview).

```typescript
import { CallAdapter, createAzureCommunicationCallAdapter } from '@azure/communication-react';

const [callAdapter, setCallAdapter] = useState<CallAdapter>();
const accessToken = 'INSERT ACCESS TOKEN';
const displayName = 'INSERT DISPLAY NAME FOR LOCAL USER';
const callLocator = { groupId: 'INSERT GROUP ID' };
//CallLocator for Teams Meeting = const callLocator = {meetingLink: 'INSERT MEETING LINK'};

useEffect(() => {
  (async () => {
    if (accessToken && callLocator && displayName) {
      const createAdapter = async (): Promise<void> => {
        setCallAdapter(await createAzureCommunicationCallAdapter(accessToken, callLocator, displayName));
      };
      createAdapter();
    }
  })();
});
```

### Chat Adapter

To initialize the chat adapter, you will be required to provide an endpoint url for the Azure Communication Services resource on [Azure Portal](https://portal.azure.com).
In addition, you will need to provide a thread Id. Thread Id is provisioned from the Azure Communication Services by creating a new thread or adding the user to an existing thread.
For more information on thread Id, see our [documentation](https://docs.microsoft.com/azure/communication-services/concepts/chat/concepts).

```typescript
import { ChatAdapter, createAzureCommunicationChatAdapter } from '@azure/communication-react';

const [chatAdapter, setChatAdapter] = useState<ChatAdapter>();
const accessToken = 'INSERT ACCESS TOKEN';
const displayName = 'INSERT DISPLAY NAME FOR LOCAL USER';
const endpointUrl = 'INSERT AZURE RESOURCE ENDPOINT';
const threadId = 'INSERT THREAD ID FOR CHAT';

useEffect(() => {
  if (props) {
    const createAdapter = async (): Promise<void> => {
      setChatAdapter(await createAzureCommunicationChatAdapter(accessToken, endpointUrl, threadId, displayName));
    };
    createAdapter();
  }
});
```

## Using Adapters

Once initialized, adapters can be used to initialize Composites as well as to pragmatically take actions on the call or chat experience.

### Initializing Composites with Adapters

With the initialized adapters, we can now hook them into the calling and chat composites.

```typescript

import { CallComposite, ChatComposite} from '@azure/communication-react';

<CallComposite adapter={callAdapter} />

<ChatComposite adapter={chatAdapter} />

```

### Accessing Adapter Contents

The adapters provide developers access to state, actions and events related to the underlying chat and calling SDKs.
Below are some examples that might be helpful, but additional methods are available.

#### Calling Adapter Examples

```typescript

//Access state and state changes, including CallClient and UI
callAdapter.onStateChange(() => {})
callAdapter.getState().userId
callAdapter.getState().call
callAdapter.getState().devices

//Access actions for the call
callAdapter.mute()
callAdapter.queryMicrophones()
callAdapter.startCamera()

//Call events
callAdapter.on('participantsJoined, ()=>{})
callAdapter.on('callEnded, ()=>{})
callAdapter.on('error', () => {})

```

#### Chat Adapter Examples

```typescript

//Access state and state changes, including ChatClient and UI
chatAdapter.onStateChange(() => {})
chatAdapter.getState().thread
chatAdapter.getState().userId

//Access actions for the chat
chatAdapter.sendMessage()
chatAdapter.removeParticipants()
chatAdapter.setTopic()

//Chat events
chatAdapter.on('messageReceived, ()=>{})
chatAdapter.on('messageSent, ()=>{})
chatAdapter.on('topicChanged', () => {})

```
