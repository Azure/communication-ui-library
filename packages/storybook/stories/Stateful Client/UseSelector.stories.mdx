import { Meta } from '@storybook/addon-docs/blocks';
import { Canvas, Description, Heading, Props, Source, Title } from '@storybook/addon-docs/blocks';

<Meta title="Stateful Client/React Hooks/UseSelector" />

## useSelector() <a name="useSelector"></a>

`useSelector` allows you to provide your own selector function that maps the stateful SDK state to your own props for your own component. It subscribes to state changes and runs the selector every time when anything changes in the state, but note that it will only trigger a component re-render when the return value of the selector changes.
`useSelector` comes in two flavors: `useCallSelector` and `useChatSelector` for each of the modalities.

### When to call useSelector

By default, if you are satisfied with props we prepared for component library, all you need is to call `usePropsFor` to power our component. If just one or two props need to be filtered or modified, directly overriding properties from return value of `usePropsFor` is recommended. But sometimes you might want to call use selector instead when:

1. Override the way how it generates props from state
2. Write your own components (which we don't provide dedicated selectors for it)

### Basic Example:

```tsx
const userInfoSelector = (state) => ({
  id: state.userId
  userName: state.displayName
});

const chatInfoProps = useChatSelector(userInfoSelector);

const ChatInfo = ({id: string, userName: string}) => {
  return <div> userName: {userName}, id: {id} </div>;
}

<ChatInfo {...chatInfoProps} />
```

### Memoizing your selector (Recommended for optimized perf)

While this basic example will work without problems, but it is not a good way to optimize your app perf, we recommend to use the reselect library to enable memoization for selectors to get better performance, check [reselect's official docs](https://redux-toolkit.js.org/api/createSelector#createselector) for more information.

```tsx
import { createSelector } from 'reselect';

const userInfoSelector = createSelector([(state) => state.userId, (state) => state.displayName], (id, userName) => ({
  id,
  userName
}));

const chatInfoProps = useChatSelector(userInfoSelector);

const ChatInfo = ({ id: string, userName: string }) => {
  return (
    <div>
      {' '}
      userName: {userName}, id: {id}{' '}
    </div>
  );
};

<ChatInfo {...chatInfoProps} />;
```

## Override default behaviors

While we provide a set of default props(which includes data and handler functions) for our UI library component, you might find it doesn't fit all you needs, there are several different ways you can choose to override the default behavior.

### Write your own handler function

In some situations, you may want to override default behavior and place your own API call (like call another service, or call another API in our stateful SDK). Here is an example of how to change the message before using the stateful client to send it.

```tsx
const sendBoxProps = useChatPropsFor(SendBox);
// This hook will get stateful client you created
const chatThreadClient = useChatThreadClient();

const onSendMessage = useCallback(
  (message: string) => {
    const sendMessageRequest = {
      `âœ‰: ${content}`,
      senderDisplayName: chatClient.getState().displayName
    };
    // directly call into stateful client
    await chatThreadClient.sendMessage(sendMessageRequest);
  },
  [chatThreadClient]
);

<SendBox {...sendBoxProps} onSendMessage={onSendMessage} />;
```

### Override selector

With the hooks that we provide it is also possible to override a selector without re-writing the default handlers.

```tsx
const customSelector = createSelector(....); // create your own selector
const messageThreadProps = useChatSelector(customSelector);
const messageThreadHandlers = useChatHandlers(MessageThread);


<MessageThread {...messageThreadProps} {...messageThreadHandlers} />
```

### Choose your own overridden combination

By calling `useSelector`/`usePropsFor`, you can get the right combination of default selector + overrided handler/default handler + overrided selector for your own needs. You can even entirely override the whole behavior by writing your own handler and selectors:

```tsx
const customSelector = createSelector(....); // create your own selector
const messageThreadProps = useChatSelector(customSelector);
// This hook will get stateful client you created
const chatThreadClient = useChatThreadClient();

// Create your own handlers
const onMessageSeen = useCallback((message: string) => {
  await chatThreadClient.sendReadReceipt({ chatMessageId });
}, [chatThreadClient]);

<MessageThread {...messageThreadProps} onMessageSeen={onMessageSeen} />
```
