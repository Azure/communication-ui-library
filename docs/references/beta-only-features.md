# Adding features to be released in the beta channel (only)

The primary NPM package released from this repository is @azure/communication-react.

We maintain two "release channels" for this package.

* Stable releases - follow semantic versioning, e.g. 1.0.0
* Beta releases - do not follow sematnic versioning. These are packages with a `-beta.X` suffix, e.g. 1.0.1-beta.3

Our beta releases often carry features that are not yet stabilized. A feature may be restricted to beta channel for
one of two reasons.

* A feature that is actively being developed. Feature will be released in a stable package once it is beta-tested.
* A feature that depends on a feature from underlying Azure Communication Service features that are in themselves in the beta phase.
  This feature can only be released in a stable package once the underlying features are released in a stable package.

The key difference from many standard NPM packages is that some features can stay in the beta packages across intervening stable package releases.

# Overall process
Before a feature hits stable release, there are 2 stages the feature will go through:
In-Progress beta -> Beta -> Stable

**In progress Beta feature**: the feature is still in progress, not beta release ready. It will living in the main branch, but will be excluded when doing the beta release.
**Beta Feature**: the feature is ready for beta release, but will be removed in stable release.
**Stable Feature**: the feature is ready for stable release.

```
                    beta feature
 ──────────────────────────────────────────────────────►

    in-progress feature
 ─────────────────────────►

┌───────────────────────┐      ┌─────────────────────┐      ┌──────────────────────┐
│                       │      │                     │      │                      │
│      Main branch      │ ───► │     Beta release    │ ───► │    Stable release    │
│     (beta flavor)     │      │  (beta-release flv) │      │    (stable flavor)   │
│                       │      │                     │      │                      │
└────────────┬──────────┘      └─────────────────────┘      └──────────────────────┘
             │
             │
             ▼
       Alpha release
```
# Conditional compilation

We follow a green-trunk development practice. This means that all development happens on the `main` branch, and all releases are generated by creating short-lived branches off of `main`. The need to carry some features that are released in the beta channel but not in intervening stable package releases means that we need a way to enable / disable these features in the releases. Additionally, we need to be able to switch between beta and stable dependencies for underlying Azure Communication Service libraries.

We achieve this by conditionally compiling away code to drop features from the stable package release.

All build, test, local development server scripts can compile the code in this repository in one of two flavors:

* `beta`: This is the default build flavor. It includes all code in the packages, and depends on the beta flavors of some of our dependencies.
* `beta-release`: This is the default build flavor. It removes in-progress feature, but still keep most of the beta feature in the build.
* `stable`: Conditionally compiled code is removed when building this flavor. It also depends on only the stable flavors of our dependencies.

# Tooling

To switch between flavors:

```bash
rush switch-flavor:stable
# Need to rebuild from scratch because that command cleans all build caches.
rush build
```

To switch back to beta-release flavor:
```bash
rush switch-flavor:beta-release
# Need to rebuild from scratch because that command cleans all build caches.
rush build
```

To switch back to beta flavor:

```bash
rush switch-flavor:beta
# Need to rebuild from scratch because that command cleans all build caches.
rush build
```



All the build tooling is aware of build flavor and works as expected:

```bash
rush build
rush test
rush lint
# ... etc.
```

Similarly, commands you use to work on a packlet locally, continue to work for both flavors:

```bash
cd samples/Chat
rushx build
rushx test
rushx start
# ... etc.
```

This is especially useful because `rush build` may hide detailed errors upon failure.

The only exception is `rush update` for stable flavor. There is a separate command to update dependencies for stable flavored build:

```bash
rush update:stable
```

# Conditionally adding a feature

You must first define your new feature by adding it to the [features file](../../common/config/babel/features.js). Add to `alpha` until your feature is ready for public preview consumptions.

You will need to make your feature [independently removable](#independently-removable-feature) when you are adding them, otherwise you might see some CI failures when raising your PR.

This repository contains a [live document](../../packages/acs-ui-common/src/conditional-compilation-sample/index.tsx) that describes how you can then add code that is conditionally compiled, and also walks through common scenarios you might encounter when trying to add a beta-only
feature.

## When the feature is ready for beta release
When your feature is ready for beta release, move it in the [features file](../../common/config/babel/features.js) from alpha to beta.

## Stabilizing a feature

Careful scoping of defined features will allow you to easily stabilize the feature. When you are ready to add your feature to the stable build:

- Move your feature to `stable` in the [features file](../../common/config/babel/features.js).
  - Do not remove conditional compilation directives yet. These are only removed after the feature is shipped in a stable release. This allows for quick rollbacks.
  - Switch to stable flavor and build, test and run samples to try out your stabilized feature.
  - You will also get the updated API files for the stable build from this step. You can use this for API review.
- Clean up: Once your feature is shipped in a stable release, remove all references to conditional compilation directive for your feature, and remove your feature from the [features file](../../common/config/babel/features.js).
  - Note: If some code has other conditional compilation directives along with your (now stable) feature, remove all directives (not only yours), so that the code is included in the stable flavor build unconditionally.

This [example PR](https://github.com/Azure/communication-ui-library/pull/1547) for stabilizing a feature includes the [generated API diff](https://github.com/Azure/communication-ui-library/pull/1547/files#diff-e76b64bd635283f256ec46065d2e58b277d9fad73ff4e4a774e4509c0290acfe) for this feature.

This [example PR](https://github.com/Azure/communication-ui-library/pull/1846) cleans up previously stabilized feature flag.

# Developing conditional compilation feature
One of the challenge to develop conditional compilation feature is you will have to imagine what code would be generated after adding your comments, and run preprocess comment, compile them and compare two files side by side.
To solve this problem, we introduce a vscode extension named Before After Diff Checker, which is a small tool to do all the preprocess automation and compare files side by side for you.

To install the extension: 

1. Press Ctrl + Shift + P when you have your VSCode open, type `Extensions: Show Recommended Extensions`, press Enter, or you can directly search for `Before After Diff Checker` in Extension search bar
2. You will see `Before After Diff Checker` on the left side panel, install it
3. Restart your VSCode to activate the extension

To use the extension:
1. Switch stable flavor using `rush switch-flavor:stable` or switch beta-release flavor using `rush switch-flavor:beta-release`
2. Press Ctrl + Shift + P when you have your VSCode open, type `Before-after Diff: Enable On Save Feature`, press Enter
3. Start editing your code, once you save the file, the extension will run the preprocess command and beautify the generated file
4. Once finished, a side by side diff window will be opened, left side will be generated code, and right side will be original code
5. You can start edit original file from right side, and you will see left side file changes within seconds after you save it.
6. Don't forget to disable it by Ctrl + Shift + P -> `Before-after Diff: Disable On Save Feature` when you finish developing conditional compilation code.

The extension is just a small tool to run a specific command to generate code and compare them based on relative path, you can easily check and edit settings for the extension:
`.vscode/settings.json`

## Independently removable feature
Independently removable means that your single feature can be removed from the source code without causing any errors. All our current CC features are beta-removable, which means they could be removed altogether under stable flavor, but this does not necessarily mean they are independently removable. 

If your code passes the CC check but not CCC check, it is a high chance that your code is not independently removable. And most likely that means your beta feature and some other beta features share same lines, which breaks the build when only one feature gets removed.

There is [a good example commit](https://github.com/Azure/communication-ui-library/pull/3088/commits/710e2c47b9b845c3041ff6d815ceae8155d9184d) on what is not independently removable and how to fix it.

# Releases

Conditional compilation necessitates a few extra steps when we release a package:

* Remove beta-only code: This is taken care of by the same tooling that we use `rush switch-flavor:stable && rush build`
* Change dependencies to be the beta vs stable versions

Both of these steps are implemented in the GitHub actions that create a release branch.

You an help with the manual step of figuring out what the CHANGELOG is in each release. When running `rush changelog`, use the change type

* `prerelease` for a change that affects only the beta flavor build
* `patch`, `minor` or `major` for changes that affect the stable (and of course beta) flavor build as appropriate.
* `none` for documentation changes etc that don't affect the NPM bundle meaningfully.

## Creating an API View for ACS and ARB Reviews

To create an API view for ACS and ARB reviews, you can use the following command:

```sh
rushx generate-api-diff --feature <FEATURE_NAME>
```

This will generate two files:

* `baseline.api.json`: This file contains the API of `@azure/communication-react` of the current branch _without_ the feature included.
* `feature.api.json`: This file contains the API of `@azure/communication-react` of the current branch _with_ the feature included.

You can then use these files to create an API view for ACS and ARB reviews on <https://apiview.dev>.

## Writing changelog of in progress feature
1. When you are developing in-progress features, choose `none` when you do the `rush changelog`, so release driver can ignore them when grooming the release log. 

2. We expect there is a single PR to remove feature from in-progress list, at that time, write a better general (in 1-2 sentences) introduction to your feature, so release driver knows what to write in the release log. 

## Look for release thread
If you are a in-progress feature owner, please look for release thread posted by release driver, which contains api snapshot updates and UI snapshot updates, please make sure your in-progress feature are correctly removed in api snapshots and behaves correctly in UI snapshots. If you find anything not working well, that might be an indicator that some more sentences needed to be conditional compiled.
