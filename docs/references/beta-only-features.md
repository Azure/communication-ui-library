# Adding features to be released in the beta channel (only)

The primary NPM package released from this repository is @azure/communication-react.

We maintain two "release channels" for this package.

* Stable releases - follow semantic versioning, e.g. 1.0.0
* Beta releases - do not follow sematnic versioning. These are packages with a `-beta.X` suffix, e.g. 1.0.1-beta.3

Our beta releases often carry features that are not yet stabilized. A feature may be restricted to beta channel for
one of two reasons.

* A feature that is actively being developed. Feature will be released in a stable package once it is beta-tested.
* A feature that depends on a feature from underlying Azure Communication Service features that are in themselves in the beta phase.
  This feature can only be released in a stable package once the underlying features are released in a stable package.

The key difference from many standard NPM packages is that some features can stay in the beta packages across intervening stable package releases.

# Overall process
Before a feature hits stable release, there are 2 stages the feature will go through:
In-Progress beta -> Beta -> Stable

**In progress Beta feature**: the feature is still in progress, not beta release ready. It will living in the main branch, but will be excluded when doing the beta release.
**Beta Feature**: the feature is ready for beta release, but will be removed in stable release.
**Stable Feature**: the feature is ready for stable release.

```
                    beta feature
 ──────────────────────────────────────────────────────►

    in-progress feature
 ─────────────────────────►

┌───────────────────────┐      ┌─────────────────────┐      ┌──────────────────────┐
│                       │      │                     │      │                      │
│      Main branch      │ ───► │     Beta release    │ ───► │    Stable release    │
│     (beta flavor)     │      │  (beta-release flv) │      │    (stable flavor)   │
│                       │      │                     │      │                      │
└────────────┬──────────┘      └─────────────────────┘      └──────────────────────┘
             │
             │
             ▼
       Alpha release
```
# Conditional compilation

We follow a green-trunk development practice. This means that all development happens on the `main` branch, and all releases are generated by creating short-lived branches off of `main`. The need to carry some features that are released in the beta channel but not in intervening stable package releases means that we need a way to enable / disable these features in the releases. Additionally, we need to be able to switch between beta and stable dependencies for underlying Azure Communication Service libraries.

We achieve this by conditionally compiling away code to drop features from the stable package release.

All build, test, local development server scripts can compile the code in this repository in one of two flavors:

* `beta`: This is the default build flavor. It includes all code in the packages, and depends on the beta flavors of some of our dependencies.
* `beta-release`: This is the default build flavor. It removes in-progress feature, but still keep most of the beta feature in the build.
* `stable`: Conditionally compiled code is removed when building this flavor. It also depends on only the stable flavors of our dependencies.

# Tooling

To switch between flavors:

```bash
rush switch-flavor:stable
# Need to rebuild from scratch because that command cleans all build caches.
rush build
```

To switch back to beta-release flavor:
```bash
rush switch-flavor:beta
# Need to rebuild from scratch because that command cleans all build caches.
rush build
```

To switch back to beta flavor:

```bash
rush switch-flavor:beta
# Need to rebuild from scratch because that command cleans all build caches.
rush build
```



All the build tooling is aware of build flavor and works as expected:

```bash
rush build
rush test
rush lint
# ... etc.
```

Similarly, commands you use to work on a packlet locally, continue to work for both flavors:

```bash
cd samples/Chat
rushx build
rushx test
rushx start
# ... etc.
```

This is especially useful because `rush build` may hide detailed errors upon failure.

The only exception is `rush update` for stable flavor. There is a separate command to update dependencies for stable flavored build:

```bash
rush update:stable
```

# Conditionally adding a feature

You must first define your new feature by adding it to the `features` and `inProgressFeatures` (not ready for release) list in [this config file](../../common/config/babel/.babelrc.js).

You will need to make your feature [independently removable](#independently-removable-feature) when you are adding them, otherwise you might see some CI failures when raising your PR.

This repository contains a [live document](../../packages/acs-ui-common/src/conditional-compilation-sample/index.tsx) that describes how you can then add code that is conditionally compiled, and also walks through common scenarios you might encounter when trying to add a beta-only
feature.

## When the feature is ready for beta release
When your feature are ready for beta release, remove it from inProgressFeatures, but keep it in features list, in [this config file](../../common/config/babel/.babelrc.js).

## Stabilizing a feature

Careful scoping of defined features will allow you to easily stabilize the feature. When you are ready to add your feature to the stable build:

- One-step stabilization: Include all associated conditionally compiled code in the stable flavored build by moving your feature to `stabilizedFeatures` in the [defined features config file]((../../common/config/babel/.babelrc.js)).
  - Switch to stable flavor and build, test and run samples to try out your stabilized feature.
  - You will also get the updated API files for the stable build from this step. You can use this for API review.
- Clean up: Once your feature is shipped in a stable release, remove all references to conditional compilation directive for your feature, and remove your feature from `stabilizedFeatures` list.
  - Note: If some code has other conditional compilation directives along with your (now stable) feature, remove all directives (not only yours), so that the code is included in the stable flavor build unconditionally.

This [example PR](https://github.com/Azure/communication-ui-library/pull/1547) for stabilizing a feature includes the [generated API diff](https://github.com/Azure/communication-ui-library/pull/1547/files#diff-e76b64bd635283f256ec46065d2e58b277d9fad73ff4e4a774e4509c0290acfe) for this feature.

This [example PR](https://github.com/Azure/communication-ui-library/pull/1846) cleans up previously stabilized feature flag.

# Developing conditional compilation feature
One of the challenge to develop conditional compilation feature is you will have to imagine what code would be generated after adding your comments, and run preprocess comment, compile them and compare two files side by side.
To solve this problem, we introduce a vscode extension named Before After Diff Checker, which is a small tool to do all the preprocess automation and compare files side by side for you.

To install the extension: 

1. Press Ctrl + Shift + P when you have your VSCode open, type `Extensions: Show Recommended Extensions`, press Enter, or you can directly search for `Before After Diff Checker` in Extension search bar
2. You will see `Before After Diff Checker` on the left side panel, install it
3. Restart your VSCode to activate the extension

To use the extension:
1. Switch stable flavor using `rush switch-flavor:stable` or switch beta-release flavor using `rush switch-flavor:beta-release`
2. Press Ctrl + Shift + P when you have your VSCode open, type `Before-after Diff: Enable On Save Feature`, press Enter
3. Start editing your code, once you save the file, the extension will run the preprocess command and beautify the generated file
4. Once finished, a side by side diff window will be opened, left side will be generated code, and right side will be original code
5. You can start edit original file from right side, and you will see left side file changes within seconds after you save it.
6. Don't forget to disable it by Ctrl + Shift + P -> `Before-after Diff: Disable On Save Feature` when you finish developing conditional compilation code.

The extension is just a small tool to run a specific command to generate code and compare them based on relative path, you can easily check and edit settings for the extension:
`.vscode/settings.json`

## Independently removable feature
Independently removable means that your single feature can be removed from the source code without causing any errors. All our current CC features are beta-removable, which means they could be removed altogether under stable flavor, but this does not necessarily mean they are independently removable. 

If your code passes the CC check but not CCC check, it is a high chance that your code is not independently removable. And most likely that means your beta feature and some other beta features share same lines, which breaks the build when only one feature gets removed.

There is [a good example commit](https://github.com/Azure/communication-ui-library/pull/3088/commits/710e2c47b9b845c3041ff6d815ceae8155d9184d) on what is not independently removable and how to fix it.

# Releases

Conditional compilation necessitates a few extra steps when we release a package:

* Remove beta-only code: This is taken care of by the same tooling that we use `rush switch-flavor:stable && rush build`
* Change dependencies to be the beta vs stable versions

Both of these steps are implemented in the GitHub actions that create a release branch.

You an help with the manual step of figuring out what the CHANGELOG is in each release. When running `rush changelog`, use the change type

* `prerelease` for a change that affects only the beta flavor build
* `patch`, `minor` or `major` for changes that affect the stable (and of course beta) flavor build as appropriate.
* `none` for documentation changes etc that don't affect the NPM bundle meaningfully.

## Writing changelog of in progress feature
1. When you are developing in-progress features, choose `none` when you do the `rush changelog`, so release driver can ignore them when grooming the release log. 

2. We expect there is a single PR to remove feature from in-progress list, at that time, write a better general (in 1-2 sentences) introduction to your feature, so release driver knows what to write in the release log. 

## Look for release thread
If you are a in-progress feature owner, please look for release thread posted by release driver, which contains api snapshot updates and UI snapshot updates, please make sure your in-progress feature are correctly removed in api snapshots and behaves correctly in UI snapshots. If you find anything not working well, that might be an indicator that some more sentences needed to be conditional compiled.